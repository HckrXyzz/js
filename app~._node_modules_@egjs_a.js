(("undefined"!=typeof self?self:this).webpackJsonp=("undefined"!=typeof self?self:this).webpackJsonp||[]).push([["app~._node_modules_@egjs_a"],{"./node_modules/@egjs/axes/dist/axes.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/@egjs/axes/dist/axes.esm.js ***!
  \**************************************************/
/*! exports provided: default, PanInput, RotatePanInput, PinchInput, WheelInput, MoveKeyInput */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanInput", function() { return PanInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotatePanInput", function() { return RotatePanInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PinchInput", function() { return PinchInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WheelInput", function() { return WheelInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MoveKeyInput", function() { return MoveKeyInput; });\n/* harmony import */ var _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @egjs/hammerjs */ "./node_modules/@egjs/hammerjs/dist/hammer.esm.js");\n/* harmony import */ var _egjs_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @egjs/agent */ "./node_modules/@egjs/agent/dist/agent.esm.js");\n/* harmony import */ var _egjs_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @egjs/component */ "./node_modules/@egjs/axes/node_modules/@egjs/component/dist/component.esm.js");\n/*\nCopyright (c) 2015 NAVER Corp.\nname: @egjs/axes\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-axes\nversion: 2.8.0\n*/\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction getInsidePosition(destPos, range, circular, bounce) {\n  var toDestPos = destPos;\n  var targetRange = [circular[0] ? range[0] : bounce ? range[0] - bounce[0] : range[0], circular[1] ? range[1] : bounce ? range[1] + bounce[1] : range[1]];\n  toDestPos = Math.max(targetRange[0], toDestPos);\n  toDestPos = Math.min(targetRange[1], toDestPos);\n  return toDestPos;\n} // determine outside\n\nfunction isOutside(pos, range) {\n  return pos < range[0] || pos > range[1];\n}\nfunction getDuration(distance, deceleration) {\n  var duration = Math.sqrt(distance / deceleration * 2); // when duration is under 100, then value is zero\n\n  return duration < 100 ? 0 : duration;\n}\nfunction isCircularable(destPos, range, circular) {\n  return circular[1] && destPos > range[1] || circular[0] && destPos < range[0];\n}\nfunction getCirculatedPos(pos, range, circular) {\n  var toPos = pos;\n  var min = range[0];\n  var max = range[1];\n  var length = max - min;\n\n  if (circular[1] && pos > max) {\n    // right\n    toPos = (toPos - max) % length + min;\n  }\n\n  if (circular[0] && pos < min) {\n    // left\n    toPos = (toPos - min) % length + max;\n  }\n\n  return toPos;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\n\nif (typeof window === "undefined") {\n  // window is undefined in node.js\n  win = {\n    navigator: {\n      userAgent: ""\n    }\n  };\n} else {\n  win = window;\n}\n\nfunction toArray(nodes) {\n  // const el = Array.prototype.slice.call(nodes);\n  // for IE8\n  var el = [];\n\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    el.push(nodes[i]);\n  }\n\n  return el;\n}\nfunction $(param, multi) {\n  if (multi === void 0) {\n    multi = false;\n  }\n\n  var el;\n\n  if (typeof param === "string") {\n    // String (HTML, Selector)\n    // check if string is HTML tag format\n    var match = param.match(/^<([a-z]+)\\s*([^>]*)>/); // creating element\n\n    if (match) {\n      // HTML\n      var dummy = document.createElement("div");\n      dummy.innerHTML = param;\n      el = toArray(dummy.childNodes);\n    } else {\n      // Selector\n      el = toArray(document.querySelectorAll(param));\n    }\n\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  } else if (param === win) {\n    // window\n    el = param;\n  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n    // HTMLElement, Document\n    el = param;\n  } else if ("jQuery" in win && param instanceof jQuery || param.constructor.prototype.jquery) {\n    // jQuery\n    el = multi ? param.toArray() : param.get(0);\n  } else if (Array.isArray(param)) {\n    el = param.map(function (v) {\n      return $(v);\n    });\n\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  }\n\n  return el;\n}\nvar raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame;\nvar caf = win.cancelAnimationFrame || win.webkitCancelAnimationFrame;\n\nif (raf && !caf) {\n  var keyInfo_1 = {};\n  var oldraf_1 = raf;\n\n  raf = function (callback) {\n    function wrapCallback(timestamp) {\n      if (keyInfo_1[key]) {\n        callback(timestamp);\n      }\n    }\n\n    var key = oldraf_1(wrapCallback);\n    keyInfo_1[key] = true;\n    return key;\n  };\n\n  caf = function (key) {\n    delete keyInfo_1[key];\n  };\n} else if (!(raf && caf)) {\n  raf = function (callback) {\n    return win.setTimeout(function () {\n      callback(win.performance && win.performance.now && win.performance.now() || new Date().getTime());\n    }, 16);\n  };\n\n  caf = win.clearTimeout;\n}\n/**\n * A polyfill for the window.requestAnimationFrame() method.\n * @see  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n * @private\n */\n\n\nfunction requestAnimationFrame(fp) {\n  return raf(fp);\n}\n/**\n* A polyfill for the window.cancelAnimationFrame() method. It cancels an animation executed through a call to the requestAnimationFrame() method.\n* @param {Number} key −\tThe ID value returned through a call to the requestAnimationFrame() method. <ko>requestAnimationFrame() 메서드가 반환한 아이디 값</ko>\n* @see  https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame\n* @private\n*/\n\nfunction cancelAnimationFrame(key) {\n  caf(key);\n}\nfunction map(obj, callback) {\n  var tranformed = {};\n\n  for (var k in obj) {\n    k && (tranformed[k] = callback(obj[k], k));\n  }\n\n  return tranformed;\n}\nfunction filter(obj, callback) {\n  var filtered = {};\n\n  for (var k in obj) {\n    k && callback(obj[k], k) && (filtered[k] = obj[k]);\n  }\n\n  return filtered;\n}\nfunction every(obj, callback) {\n  for (var k in obj) {\n    if (k && !callback(obj[k], k)) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction equal(target, base) {\n  return every(target, function (v, k) {\n    return v === base[k];\n  });\n}\nvar roundNumFunc = {};\nfunction roundNumber(num, roundUnit) {\n  // Cache for performance\n  if (!roundNumFunc[roundUnit]) {\n    roundNumFunc[roundUnit] = getRoundFunc(roundUnit);\n  }\n\n  return roundNumFunc[roundUnit](num);\n}\nfunction roundNumbers(num, roundUnit) {\n  if (!num || !roundUnit) {\n    return num;\n  }\n\n  var isNumber = typeof roundUnit === "number";\n  return map(num, function (value, key) {\n    return roundNumber(value, isNumber ? roundUnit : roundUnit[key]);\n  });\n}\nfunction getDecimalPlace(val) {\n  if (!isFinite(val)) {\n    return 0;\n  }\n\n  var v = val + "";\n\n  if (v.indexOf("e") >= 0) {\n    // Exponential Format\n    // 1e-10, 1e-12\n    var p = 0;\n    var e = 1;\n\n    while (Math.round(val * e) / e !== val) {\n      e *= 10;\n      p++;\n    }\n\n    return p;\n  } // In general, following has performance benefit.\n  // https://jsperf.com/precision-calculation\n\n\n  return v.indexOf(".") >= 0 ? v.length - v.indexOf(".") - 1 : 0;\n}\nfunction inversePow(n) {\n  // replace Math.pow(10, -n) to solve floating point issue.\n  // eg. Math.pow(10, -4) => 0.00009999999999999999\n  return 1 / Math.pow(10, n);\n}\nfunction getRoundFunc(v) {\n  var p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;\n  return function (n) {\n    if (v === 0) {\n      return 0;\n    }\n\n    return Math.round(Math.round(n / v) * v * p) / p;\n  };\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n}\n\nvar AnimationManager =\n/*#__PURE__*/\nfunction () {\n  function AnimationManager(_a) {\n    var options = _a.options,\n        itm = _a.itm,\n        em = _a.em,\n        axm = _a.axm;\n    this.options = options;\n    this.itm = itm;\n    this.em = em;\n    this.axm = axm;\n    this.animationEnd = this.animationEnd.bind(this);\n  }\n\n  var __proto = AnimationManager.prototype;\n\n  __proto.getDuration = function (depaPos, destPos, wishDuration) {\n    var _this = this;\n\n    var duration;\n\n    if (typeof wishDuration !== "undefined") {\n      duration = wishDuration;\n    } else {\n      var durations_1 = map(destPos, function (v, k) {\n        return getDuration(Math.abs(v - depaPos[k]), _this.options.deceleration);\n      });\n      duration = Object.keys(durations_1).reduce(function (max, v) {\n        return Math.max(max, durations_1[v]);\n      }, -Infinity);\n    }\n\n    return minMax(duration, this.options.minimumDuration, this.options.maximumDuration);\n  };\n\n  __proto.createAnimationParam = function (pos, duration, option) {\n    var depaPos = this.axm.get();\n    var destPos = pos;\n    var inputEvent = option && option.event || null;\n    return {\n      depaPos: depaPos,\n      destPos: destPos,\n      duration: minMax(duration, this.options.minimumDuration, this.options.maximumDuration),\n      delta: this.axm.getDelta(depaPos, destPos),\n      inputEvent: inputEvent,\n      input: option && option.input || null,\n      isTrusted: !!inputEvent,\n      done: this.animationEnd\n    };\n  };\n\n  __proto.grab = function (axes, option) {\n    if (this._animateParam && axes.length) {\n      var orgPos_1 = this.axm.get(axes);\n      var pos = this.axm.map(orgPos_1, function (v, opt) {\n        return getCirculatedPos(v, opt.range, opt.circular);\n      });\n\n      if (!every(pos, function (v, k) {\n        return orgPos_1[k] === v;\n      })) {\n        this.em.triggerChange(pos, false, orgPos_1, option, !!option);\n      }\n\n      this._animateParam = null;\n      this._raf && cancelAnimationFrame(this._raf);\n      this._raf = null;\n      this.em.triggerAnimationEnd(!!(option && option.event));\n    }\n  };\n\n  __proto.getEventInfo = function () {\n    if (this._animateParam && this._animateParam.input && this._animateParam.inputEvent) {\n      return {\n        input: this._animateParam.input,\n        event: this._animateParam.inputEvent\n      };\n    } else {\n      return null;\n    }\n  };\n\n  __proto.restore = function (option) {\n    var pos = this.axm.get();\n    var destPos = this.axm.map(pos, function (v, opt) {\n      return Math.min(opt.range[1], Math.max(opt.range[0], v));\n    });\n    this.animateTo(destPos, this.getDuration(pos, destPos), option);\n  };\n\n  __proto.animationEnd = function () {\n    var beforeParam = this.getEventInfo();\n    this._animateParam = null; // for Circular\n\n    var circularTargets = this.axm.filter(this.axm.get(), function (v, opt) {\n      return isCircularable(v, opt.range, opt.circular);\n    });\n    Object.keys(circularTargets).length > 0 && this.setTo(this.axm.map(circularTargets, function (v, opt) {\n      return getCirculatedPos(v, opt.range, opt.circular);\n    }));\n    this.itm.setInterrupt(false);\n    this.em.triggerAnimationEnd(!!beforeParam);\n\n    if (this.axm.isOutside()) {\n      this.restore(beforeParam);\n    } else {\n      this.finish(!!beforeParam);\n    }\n  };\n\n  __proto.finish = function (isTrusted) {\n    this._animateParam = null;\n    this.itm.setInterrupt(false);\n    this.em.triggerFinish(isTrusted);\n  };\n\n  __proto.animateLoop = function (param, complete) {\n    if (param.duration) {\n      this._animateParam = __assign({}, param);\n      var info_1 = this._animateParam;\n      var self_1 = this;\n      var destPos_1 = info_1.destPos;\n      var prevPos_1 = info_1.depaPos;\n      var prevEasingPer_1 = 0;\n      var directions_1 = map(prevPos_1, function (value, key) {\n        return value <= destPos_1[key] ? 1 : -1;\n      });\n      var originalIntendedPos_1 = map(destPos_1, function (v) {\n        return v;\n      });\n      var prevTime_1 = new Date().getTime();\n      info_1.startTime = prevTime_1;\n\n      (function loop() {\n        self_1._raf = null;\n        var currentTime = new Date().getTime();\n        var ratio = (currentTime - info_1.startTime) / param.duration;\n        var easingPer = self_1.easing(ratio);\n        var toPos = self_1.axm.map(prevPos_1, function (pos, options, key) {\n          var nextPos = ratio >= 1 ? destPos_1[key] : pos + info_1.delta[key] * (easingPer - prevEasingPer_1); // Subtract distance from distance already moved.\n          // Recalculate the remaining distance.\n          // Fix the bouncing phenomenon by changing the range.\n\n          var circulatedPos = getCirculatedPos(nextPos, options.range, options.circular);\n\n          if (nextPos !== circulatedPos) {\n            // circular\n            var rangeOffset = directions_1[key] * (options.range[1] - options.range[0]);\n            destPos_1[key] -= rangeOffset;\n            prevPos_1[key] -= rangeOffset;\n          }\n\n          return circulatedPos;\n        });\n        var isCanceled = !self_1.em.triggerChange(toPos, false, prevPos_1);\n        prevPos_1 = toPos;\n        prevTime_1 = currentTime;\n        prevEasingPer_1 = easingPer;\n\n        if (easingPer >= 1) {\n          destPos_1 = self_1.getFinalPos(destPos_1, originalIntendedPos_1);\n\n          if (!equal(destPos_1, self_1.axm.get(Object.keys(destPos_1)))) {\n            self_1.em.triggerChange(destPos_1, true, prevPos_1);\n          }\n\n          complete();\n          return;\n        } else if (isCanceled) {\n          self_1.finish(false);\n        } else {\n          // animationEnd\n          self_1._raf = requestAnimationFrame(loop);\n        }\n      })();\n    } else {\n      this.em.triggerChange(param.destPos, true);\n      complete();\n    }\n  };\n  /**\n   * Get estimated final value.\n   *\n   * If destPos is within the \'error range\' of the original intended position, the initial intended position is returned.\n   *   - eg. original intended pos: 100, destPos: 100.0000000004 ==> return 100;\n   * If dest Pos is outside the \'range of error\' compared to the originally intended pos, it is returned rounded based on the originally intended pos.\n   *   - eg. original intended pos: 100.123 destPos: 50.12345 => return 50.123\n   *\n   * @param originalIntendedPos\n   * @param destPos\n   */\n\n\n  __proto.getFinalPos = function (destPos, originalIntendedPos) {\n    var _this = this; // compare destPos and originalIntendedPos\n\n\n    var ERROR_LIMIT = 0.000001;\n    var finalPos = map(destPos, function (value, key) {\n      if (value >= originalIntendedPos[key] - ERROR_LIMIT && value <= originalIntendedPos[key] + ERROR_LIMIT) {\n        // In error range, return original intended\n        return originalIntendedPos[key];\n      } else {\n        // Out of error range, return rounded pos.\n        var roundUnit = _this.getRoundUnit(value, key);\n\n        var result = roundNumber(value, roundUnit);\n        return result;\n      }\n    });\n    return finalPos;\n  };\n\n  __proto.getRoundUnit = function (val, key) {\n    var roundUnit = this.options.round; // manual mode\n\n    var minRoundUnit = null; // auto mode\n    // auto mode\n\n    if (!roundUnit) {\n      // Get minimum round unit\n      var options = this.axm.getAxisOptions(key);\n      minRoundUnit = inversePow(Math.max(getDecimalPlace(options.range[0]), getDecimalPlace(options.range[1]), getDecimalPlace(val)));\n    }\n\n    return minRoundUnit || roundUnit;\n  };\n\n  __proto.getUserControll = function (param) {\n    var userWish = param.setTo();\n    userWish.destPos = this.axm.get(userWish.destPos);\n    userWish.duration = minMax(userWish.duration, this.options.minimumDuration, this.options.maximumDuration);\n    return userWish;\n  };\n\n  __proto.animateTo = function (destPos, duration, option) {\n    var _this = this;\n\n    var param = this.createAnimationParam(destPos, duration, option);\n\n    var depaPos = __assign({}, param.depaPos);\n\n    var retTrigger = this.em.triggerAnimationStart(param); // to control\n\n    var userWish = this.getUserControll(param); // You can\'t stop the \'animationStart\' event when \'circular\' is true.\n\n    if (!retTrigger && this.axm.every(userWish.destPos, function (v, opt) {\n      return isCircularable(v, opt.range, opt.circular);\n    })) {\n      console.warn("You can\'t stop the \'animation\' event when \'circular\' is true.");\n    }\n\n    if (retTrigger && !equal(userWish.destPos, depaPos)) {\n      var inputEvent = option && option.event || null;\n      this.animateLoop({\n        depaPos: depaPos,\n        destPos: userWish.destPos,\n        duration: userWish.duration,\n        delta: this.axm.getDelta(depaPos, userWish.destPos),\n        isTrusted: !!inputEvent,\n        inputEvent: inputEvent,\n        input: option && option.input || null\n      }, function () {\n        return _this.animationEnd();\n      });\n    }\n  };\n\n  __proto.easing = function (p) {\n    return p > 1 ? 1 : this.options.easing(p);\n  };\n\n  __proto.setTo = function (pos, duration) {\n    if (duration === void 0) {\n      duration = 0;\n    }\n\n    var axes = Object.keys(pos);\n    this.grab(axes);\n    var orgPos = this.axm.get(axes);\n\n    if (equal(pos, orgPos)) {\n      return this;\n    }\n\n    this.itm.setInterrupt(true);\n    var movedPos = filter(pos, function (v, k) {\n      return orgPos[k] !== v;\n    });\n\n    if (!Object.keys(movedPos).length) {\n      return this;\n    }\n\n    movedPos = this.axm.map(movedPos, function (v, opt) {\n      var range = opt.range,\n          circular = opt.circular;\n\n      if (circular && (circular[0] || circular[1])) {\n        return v;\n      } else {\n        return getInsidePosition(v, range, circular);\n      }\n    });\n\n    if (equal(movedPos, orgPos)) {\n      return this;\n    }\n\n    if (duration > 0) {\n      this.animateTo(movedPos, duration);\n    } else {\n      this.em.triggerChange(movedPos);\n      this.finish(false);\n    }\n\n    return this;\n  };\n\n  __proto.setBy = function (pos, duration) {\n    if (duration === void 0) {\n      duration = 0;\n    }\n\n    return this.setTo(map(this.axm.get(Object.keys(pos)), function (v, k) {\n      return v + pos[k];\n    }), duration);\n  };\n\n  return AnimationManager;\n}();\n\nvar EventManager =\n/*#__PURE__*/\nfunction () {\n  function EventManager(axes) {\n    this.axes = axes;\n  }\n  /**\n   * This event is fired when a user holds an element on the screen of the device.\n   * @ko 사용자가 기기의 화면에 손을 대고 있을 때 발생하는 이벤트\n   * @name eg.Axes#hold\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} pos coordinate <ko>좌표 정보</ko>\n   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("hold", function(event) {\n   *   // event.pos\n   *   // event.input\n   *   // event.inputEvent\n   *   // isTrusted\n   * });\n   */\n\n\n  var __proto = EventManager.prototype;\n\n  __proto.triggerHold = function (pos, option) {\n    var roundPos = this.getRoundPos(pos).roundPos;\n    this.axes.trigger("hold", {\n      pos: roundPos,\n      input: option.input || null,\n      inputEvent: option.event || null,\n      isTrusted: true\n    });\n  };\n  /**\n   * Specifies the coordinates to move after the \'change\' event. It works when the holding value of the change event is true.\n   * @ko \'change\' 이벤트 이후 이동할 좌표를 지정한다. change이벤트의 holding 값이 true일 경우에 동작한다\n   * @name set\n  * @function\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("change", function(event) {\n   *   event.holding && event.set({x: 10});\n   * });\n   */\n\n  /** Specifies the animation coordinates to move after the \'release\' or \'animationStart\' events.\n   * @ko \'release\' 또는 \'animationStart\' 이벤트 이후 이동할 좌표를 지정한다.\n   * @name setTo\n  * @function\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("animationStart", function(event) {\n   *   event.setTo({x: 10}, 2000);\n   * });\n   */\n\n  /**\n   * This event is fired when a user release an element on the screen of the device.\n   * @ko 사용자가 기기의 화면에서 손을 뗐을 때 발생하는 이벤트\n   * @name eg.Axes#release\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} depaPos The coordinates when releasing an element<ko>손을 뗐을 때의 좌표 </ko>\n   * @property {Object.<string, number>} destPos The coordinates to move to after releasing an element<ko>손을 뗀 뒤에 이동할 좌표</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>\n   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("release", function(event) {\n   *   // event.depaPos\n   *   // event.destPos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.setTo\n   *   // event.isTrusted\n   *\n   *   // if you want to change the animation coordinates to move after the \'release\' event.\n   *   event.setTo({x: 10}, 2000);\n   * });\n   */\n\n\n  __proto.triggerRelease = function (param) {\n    var _a = this.getRoundPos(param.destPos, param.depaPos),\n        roundPos = _a.roundPos,\n        roundDepa = _a.roundDepa;\n\n    param.destPos = roundPos;\n    param.depaPos = roundDepa;\n    param.setTo = this.createUserControll(param.destPos, param.duration);\n    this.axes.trigger("release", param);\n  };\n  /**\n   * This event is fired when coordinate changes.\n   * @ko 좌표가 변경됐을 때 발생하는 이벤트\n   * @name eg.Axes#change\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} pos  The coordinate <ko>좌표</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Boolean} holding Indicates whether a user holds an element on the screen of the device.<ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>\n   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns \'null\'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 \'null\'을 반환한다.</ko>\n   * @property {Object} inputEvent The event object received from inputType. If the value is changed by animation, it returns \'null\'.<ko>inputType으로 부터 받은 이벤트 객체. 애니메이션에 의해 값이 변경될 경우에는 \'null\'을 반환한다.</ko>\n   * @property {set} set Specifies the coordinates to move after the event. It works when the holding value is true <ko>이벤트 이후 이동할 좌표를 지정한다. holding 값이 true일 경우에 동작한다.</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("change", function(event) {\n   *   // event.pos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.holding\n   *   // event.set\n   *   // event.isTrusted\n   *\n   *   // if you want to change the coordinates to move after the \'change\' event.\n   *   // it works when the holding value of the change event is true.\n   *   event.holding && event.set({x: 10});\n   * });\n   */\n\n\n  __proto.triggerChange = function (pos, isAccurate, depaPos, option, holding) {\n    if (holding === void 0) {\n      holding = false;\n    }\n\n    var am = this.am;\n    var axm = am.axm;\n    var eventInfo = am.getEventInfo();\n\n    var _a = this.getRoundPos(pos, depaPos),\n        roundPos = _a.roundPos,\n        roundDepa = _a.roundDepa;\n\n    var moveTo = axm.moveTo(roundPos, roundDepa);\n    var inputEvent = option && option.event || eventInfo && eventInfo.event || null;\n    var param = {\n      pos: moveTo.pos,\n      delta: moveTo.delta,\n      holding: holding,\n      inputEvent: inputEvent,\n      isTrusted: !!inputEvent,\n      input: option && option.input || eventInfo && eventInfo.input || null,\n      set: inputEvent ? this.createUserControll(moveTo.pos) : function () {}\n    };\n    var result = this.axes.trigger("change", param);\n    inputEvent && axm.set(param.set()["destPos"]);\n    return result;\n  };\n  /**\n   * This event is fired when animation starts.\n   * @ko 에니메이션이 시작할 때 발생한다.\n   * @name eg.Axes#animationStart\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} depaPos The coordinates when animation starts<ko>애니메이션이 시작 되었을 때의 좌표 </ko>\n   * @property {Object.<string, number>} destPos The coordinates to move to. If you change this value, you can run the animation<ko>이동할 좌표. 이값을 변경하여 애니메이션을 동작시킬수 있다</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Number} duration Duration of the animation (unit: ms). If you change this value, you can control the animation duration time.<ko>애니메이션 진행 시간(단위: ms). 이값을 변경하여 애니메이션의 이동시간을 조절할 수 있다.</ko>\n   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns \'null\'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 \'null\'을 반환한다.</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("release", function(event) {\n   *   // event.depaPos\n   *   // event.destPos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.setTo\n   *   // event.isTrusted\n   *\n   *   // if you want to change the animation coordinates to move after the \'animationStart\' event.\n   *   event.setTo({x: 10}, 2000);\n   * });\n   */\n\n\n  __proto.triggerAnimationStart = function (param) {\n    var _a = this.getRoundPos(param.destPos, param.depaPos),\n        roundPos = _a.roundPos,\n        roundDepa = _a.roundDepa;\n\n    param.destPos = roundPos;\n    param.depaPos = roundDepa;\n    param.setTo = this.createUserControll(param.destPos, param.duration);\n    return this.axes.trigger("animationStart", param);\n  };\n  /**\n   * This event is fired when animation ends.\n   * @ko 에니메이션이 끝났을 때 발생한다.\n   * @name eg.Axes#animationEnd\n   * @event\n   * @type {object}\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("animationEnd", function(event) {\n   *   // event.isTrusted\n   * });\n   */\n\n\n  __proto.triggerAnimationEnd = function (isTrusted) {\n    if (isTrusted === void 0) {\n      isTrusted = false;\n    }\n\n    this.axes.trigger("animationEnd", {\n      isTrusted: isTrusted\n    });\n  };\n  /**\n   * This event is fired when all actions have been completed.\n   * @ko 에니메이션이 끝났을 때 발생한다.\n   * @name eg.Axes#finish\n   * @event\n   * @type {object}\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "zoom": {\n   *      range: [50, 30]\n   *   }\n   * }).on("finish", function(event) {\n   *   // event.isTrusted\n   * });\n   */\n\n\n  __proto.triggerFinish = function (isTrusted) {\n    if (isTrusted === void 0) {\n      isTrusted = false;\n    }\n\n    this.axes.trigger("finish", {\n      isTrusted: isTrusted\n    });\n  };\n\n  __proto.createUserControll = function (pos, duration) {\n    if (duration === void 0) {\n      duration = 0;\n    } // to controll\n\n\n    var userControl = {\n      destPos: __assign({}, pos),\n      duration: duration\n    };\n    return function (toPos, userDuration) {\n      toPos && (userControl.destPos = __assign({}, toPos));\n      userDuration !== undefined && (userControl.duration = userDuration);\n      return userControl;\n    };\n  };\n\n  __proto.setAnimationManager = function (am) {\n    this.am = am;\n  };\n\n  __proto.destroy = function () {\n    this.axes.off();\n  };\n\n  __proto.getRoundPos = function (pos, depaPos) {\n    // round value if round exist\n    var roundUnit = this.axes.options.round; // if (round == null) {\n    // \treturn {pos, depaPos}; // undefined, undefined\n    // }\n\n    return {\n      roundPos: roundNumbers(pos, roundUnit),\n      roundDepa: roundNumbers(depaPos, roundUnit)\n    };\n  };\n\n  return EventManager;\n}();\n\nvar InterruptManager =\n/*#__PURE__*/\nfunction () {\n  function InterruptManager(options) {\n    this.options = options;\n    this._prevented = false; //  check whether the animation event was prevented\n  }\n\n  var __proto = InterruptManager.prototype;\n\n  __proto.isInterrupting = function () {\n    // when interruptable is \'true\', return value is always \'true\'.\n    return this.options.interruptable || this._prevented;\n  };\n\n  __proto.isInterrupted = function () {\n    return !this.options.interruptable && this._prevented;\n  };\n\n  __proto.setInterrupt = function (prevented) {\n    !this.options.interruptable && (this._prevented = prevented);\n  };\n\n  return InterruptManager;\n}();\n\nvar AxisManager =\n/*#__PURE__*/\nfunction () {\n  function AxisManager(axis, options) {\n    var _this = this;\n\n    this.axis = axis;\n    this.options = options;\n\n    this._complementOptions();\n\n    this._pos = Object.keys(this.axis).reduce(function (acc, v) {\n      acc[v] = _this.axis[v].range[0];\n      return acc;\n    }, {});\n  }\n  /**\n     * set up \'css\' expression\n     * @private\n     */\n\n\n  var __proto = AxisManager.prototype;\n\n  __proto._complementOptions = function () {\n    var _this = this;\n\n    Object.keys(this.axis).forEach(function (axis) {\n      _this.axis[axis] = __assign({\n        range: [0, 100],\n        bounce: [0, 0],\n        circular: [false, false]\n      }, _this.axis[axis]);\n      ["bounce", "circular"].forEach(function (v) {\n        var axisOption = _this.axis;\n        var key = axisOption[axis][v];\n\n        if (/string|number|boolean/.test(typeof key)) {\n          axisOption[axis][v] = [key, key];\n        }\n      });\n    });\n  };\n\n  __proto.getDelta = function (depaPos, destPos) {\n    var fullDepaPos = this.get(depaPos);\n    return map(this.get(destPos), function (v, k) {\n      return v - fullDepaPos[k];\n    });\n  };\n\n  __proto.get = function (axes) {\n    var _this = this;\n\n    if (axes && Array.isArray(axes)) {\n      return axes.reduce(function (acc, v) {\n        if (v && v in _this._pos) {\n          acc[v] = _this._pos[v];\n        }\n\n        return acc;\n      }, {});\n    } else {\n      return __assign(__assign({}, this._pos), axes || {});\n    }\n  };\n\n  __proto.moveTo = function (pos, depaPos) {\n    if (depaPos === void 0) {\n      depaPos = this._pos;\n    }\n\n    var delta = map(this._pos, function (v, key) {\n      return key in pos && key in depaPos ? pos[key] - depaPos[key] : 0;\n    });\n    this.set(this.map(pos, function (v, opt) {\n      return opt ? getCirculatedPos(v, opt.range, opt.circular) : 0;\n    }));\n    return {\n      pos: __assign({}, this._pos),\n      delta: delta\n    };\n  };\n\n  __proto.set = function (pos) {\n    for (var k in pos) {\n      if (k && k in this._pos) {\n        this._pos[k] = pos[k];\n      }\n    }\n  };\n\n  __proto.every = function (pos, callback) {\n    var axisOptions = this.axis;\n    return every(pos, function (value, key) {\n      return callback(value, axisOptions[key], key);\n    });\n  };\n\n  __proto.filter = function (pos, callback) {\n    var axisOptions = this.axis;\n    return filter(pos, function (value, key) {\n      return callback(value, axisOptions[key], key);\n    });\n  };\n\n  __proto.map = function (pos, callback) {\n    var axisOptions = this.axis;\n    return map(pos, function (value, key) {\n      return callback(value, axisOptions[key], key);\n    });\n  };\n\n  __proto.isOutside = function (axes) {\n    return !this.every(axes ? this.get(axes) : this._pos, function (v, opt) {\n      return !isOutside(v, opt.range);\n    });\n  };\n\n  __proto.getAxisOptions = function (key) {\n    return this.axis[key];\n  };\n\n  return AxisManager;\n}();\n\nvar InputObserver =\n/*#__PURE__*/\nfunction () {\n  function InputObserver(_a) {\n    var options = _a.options,\n        itm = _a.itm,\n        em = _a.em,\n        axm = _a.axm,\n        am = _a.am;\n    this.isOutside = false;\n    this.moveDistance = null;\n    this.isStopped = false;\n    this.options = options;\n    this.itm = itm;\n    this.em = em;\n    this.axm = axm;\n    this.am = am;\n  } // when move pointer is held in outside\n\n\n  var __proto = InputObserver.prototype;\n\n  __proto.atOutside = function (pos) {\n    var _this = this;\n\n    if (this.isOutside) {\n      return this.axm.map(pos, function (v, opt) {\n        var tn = opt.range[0] - opt.bounce[0];\n        var tx = opt.range[1] + opt.bounce[1];\n        return v > tx ? tx : v < tn ? tn : v;\n      });\n    } else {\n      // when start pointer is held in inside\n      // get a initialization slope value to prevent smooth animation.\n      var initSlope_1 = this.am.easing(0.00001) / 0.00001;\n      return this.axm.map(pos, function (v, opt) {\n        var min = opt.range[0];\n        var max = opt.range[1];\n        var out = opt.bounce;\n        var circular = opt.circular;\n\n        if (circular && (circular[0] || circular[1])) {\n          return v;\n        } else if (v < min) {\n          // left\n          return min - _this.am.easing((min - v) / (out[0] * initSlope_1)) * out[0];\n        } else if (v > max) {\n          // right\n          return max + _this.am.easing((v - max) / (out[1] * initSlope_1)) * out[1];\n        }\n\n        return v;\n      });\n    }\n  };\n\n  __proto.get = function (input) {\n    return this.axm.get(input.axes);\n  };\n\n  __proto.hold = function (input, event) {\n    if (this.itm.isInterrupted() || !input.axes.length) {\n      return;\n    }\n\n    var changeOption = {\n      input: input,\n      event: event\n    };\n    this.isStopped = false;\n    this.itm.setInterrupt(true);\n    this.am.grab(input.axes, changeOption);\n    !this.moveDistance && this.em.triggerHold(this.axm.get(), changeOption);\n    this.isOutside = this.axm.isOutside(input.axes);\n    this.moveDistance = this.axm.get(input.axes);\n  };\n\n  __proto.change = function (input, event, offset) {\n    if (this.isStopped || !this.itm.isInterrupting() || this.axm.every(offset, function (v) {\n      return v === 0;\n    })) {\n      return;\n    }\n\n    var depaPos = this.moveDistance || this.axm.get(input.axes);\n    var destPos; // for outside logic\n\n    destPos = map(depaPos, function (v, k) {\n      return v + (offset[k] || 0);\n    });\n    this.moveDistance && (this.moveDistance = destPos); // from outside to inside\n\n    if (this.isOutside && this.axm.every(depaPos, function (v, opt) {\n      return !isOutside(v, opt.range);\n    })) {\n      this.isOutside = false;\n    }\n\n    depaPos = this.atOutside(depaPos);\n    destPos = this.atOutside(destPos);\n    var isCanceled = !this.em.triggerChange(destPos, false, depaPos, {\n      input: input,\n      event: event\n    }, true);\n\n    if (isCanceled) {\n      this.isStopped = true;\n      this.moveDistance = null;\n      this.am.finish(false);\n    }\n  };\n\n  __proto.release = function (input, event, offset, inputDuration) {\n    if (this.isStopped || !this.itm.isInterrupting() || !this.moveDistance) {\n      return;\n    }\n\n    var pos = this.axm.get(input.axes);\n    var depaPos = this.axm.get();\n    var destPos = this.axm.get(this.axm.map(offset, function (v, opt, k) {\n      if (opt.circular && (opt.circular[0] || opt.circular[1])) {\n        return pos[k] + v;\n      } else {\n        return getInsidePosition(pos[k] + v, opt.range, opt.circular, opt.bounce);\n      }\n    }));\n    var duration = this.am.getDuration(destPos, pos, inputDuration);\n\n    if (duration === 0) {\n      destPos = __assign({}, depaPos);\n    } // prepare params\n\n\n    var param = {\n      depaPos: depaPos,\n      destPos: destPos,\n      duration: duration,\n      delta: this.axm.getDelta(depaPos, destPos),\n      inputEvent: event,\n      input: input,\n      isTrusted: true\n    };\n    this.em.triggerRelease(param);\n    this.moveDistance = null; // to contol\n\n    var userWish = this.am.getUserControll(param);\n    var isEqual = equal(userWish.destPos, depaPos);\n    var changeOption = {\n      input: input,\n      event: event\n    };\n\n    if (isEqual || userWish.duration === 0) {\n      !isEqual && this.em.triggerChange(userWish.destPos, false, depaPos, changeOption, true);\n      this.itm.setInterrupt(false);\n\n      if (this.axm.isOutside()) {\n        this.am.restore(changeOption);\n      } else {\n        this.em.triggerFinish(true);\n      }\n    } else {\n      this.am.animateTo(userWish.destPos, userWish.duration, changeOption);\n    }\n  };\n\n  return InputObserver;\n}();\n\n// export const DIRECTION_NONE = 1;\nvar IOS_EDGE_THRESHOLD = 30;\nvar IS_IOS_SAFARI = "ontouchstart" in win && Object(_egjs_agent__WEBPACK_IMPORTED_MODULE_1__["default"])().browser.name === "safari";\nvar TRANSFORM = function () {\n  if (typeof document === "undefined") {\n    return "";\n  }\n\n  var bodyStyle = (document.head || document.getElementsByTagName("head")[0]).style;\n  var target = ["transform", "webkitTransform", "msTransform", "mozTransform"];\n\n  for (var i = 0, len = target.length; i < len; i++) {\n    if (target[i] in bodyStyle) {\n      return target[i];\n    }\n  }\n\n  return "";\n}();\n\n/**\n * @typedef {Object} AxisOption The Axis information. The key of the axis specifies the name to use as the logical virtual coordinate system.\n * @ko 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.\n * @property {Number[]} [range] The coordinate of range <ko>좌표 범위</ko>\n * @property {Number} [range.0=0] The coordinate of the minimum <ko>최소 좌표</ko>\n * @property {Number} [range.1=0] The coordinate of the maximum <ko>최대 좌표</ko>\n * @property {Number[]} [bounce] The size of bouncing area. The coordinates can exceed the coordinate area as much as the bouncing area based on user action. If the coordinates does not exceed the bouncing area when an element is dragged, the coordinates where bouncing effects are applied are retuned back into the coordinate area<ko>바운스 영역의 크기. 사용자의 동작에 따라 좌표가 좌표 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 사용자가 끌어다 놓는 동작을 했을 때 좌표가 바운스 영역에 있으면, 바운스 효과가 적용된 좌표가 다시 좌표 영역 안으로 들어온다</ko>\n * @property {Number} [bounce.0=0] The size of coordinate of the minimum area <ko>최소 좌표 바운스 영역의 크기</ko>\n * @property {Number} [bounce.1=0] The size of coordinate of the maximum area <ko>최대 좌표 바운스 영역의 크기</ko>\n * @property {Boolean[]} [circular] Indicates whether a circular element is available. If it is set to "true" and an element is dragged outside the coordinate area, the element will appear on the other side.<ko>순환 여부. \'true\'로 설정한 방향의 좌표 영역 밖으로 엘리먼트가 이동하면 반대 방향에서 엘리먼트가 나타난다</ko>\n * @property {Boolean} [circular.0=false] Indicates whether to circulate to the coordinate of the minimum <ko>최소 좌표 방향의 순환 여부</ko>\n * @property {Boolean} [circular.1=false] Indicates whether to circulate to the coordinate of the maximum <ko>최대 좌표 방향의 순환 여부</ko>\n**/\n\n/**\n * @typedef {Object} AxesOption The option object of the eg.Axes module\n * @ko eg.Axes 모듈의 옵션 객체\n * @property {Function} [easing=easing.easeOutCubic] The easing function to apply to an animation <ko>애니메이션에 적용할 easing 함수</ko>\n * @property {Number} [maximumDuration=Infinity] Maximum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최대 좌표 이동 시간</ko>\n * @property {Number} [minimumDuration=0] Minimum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최소 좌표 이동 시간</ko>\n * @property {Number} [deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time. <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>\n * @property {Boolean} [interruptable=true] Indicates whether an animation is interruptible.<br>- true: It can be paused or stopped by user action or the API.<br>- false: It cannot be paused or stopped by user action or the API while it is running.<ko>진행 중인 애니메이션 중지 가능 여부.<br>- true: 사용자의 동작이나 API로 애니메이션을 중지할 수 있다.<br>- false: 애니메이션이 진행 중일 때는 사용자의 동작이나 API가 적용되지 않는다</ko>\n * @property {Number} [round = null] Rounding unit. For example, 0.1 rounds to 0.1 decimal point(6.1234 => 6.1), 5 rounds to 5 (93 => 95) <br>[Details](https://github.com/naver/egjs-axes/wiki/round-option)<ko>반올림 단위. 예를 들어 0.1 은 소숫점 0.1 까지 반올림(6.1234 => 6.1), 5 는 5 단위로 반올림(93 => 95).<br>[상세내용](https://github.com/naver/egjs-axes/wiki/round-option)</ko>\n**/\n\n/**\n * @class eg.Axes\n * @classdesc A module used to change the information of user action entered by various input devices such as touch screen or mouse into the logical virtual coordinates. You can easily create a UI that responds to user actions.\n * @ko 터치 입력 장치나 마우스와 같은 다양한 입력 장치를 통해 전달 받은 사용자의 동작을 논리적인 가상 좌표로 변경하는 모듈이다. 사용자 동작에 반응하는 UI를 손쉽게 만들수 있다.\n * @extends eg.Component\n *\n * @param {Object.<string, AxisOption>} axis Axis information managed by eg.Axes. The key of the axis specifies the name to use as the logical virtual coordinate system.  <ko>eg.Axes가 관리하는 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.</ko>\n * @param {AxesOption} [options] The option object of the eg.Axes module<ko>eg.Axes 모듈의 옵션 객체</ko>\n * @param {Object.<string, number>} [startPos] The coordinates to be moved when creating an instance. not triggering change event.<ko>인스턴스 생성시 이동할 좌표, change 이벤트는 발생하지 않음.</ko>\n *\n * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}\n * @example\n *\n * // 1. Initialize eg.Axes\n * const axes = new eg.Axes({\n *\tsomething1: {\n *\t\trange: [0, 150],\n *\t\tbounce: 50\n *\t},\n *\tsomething2: {\n *\t\trange: [0, 200],\n *\t\tbounce: 100\n *\t},\n *\tsomethingN: {\n *\t\trange: [1, 10],\n *\t}\n * }, {\n *  deceleration : 0.0024\n * });\n *\n * // 2. attach event handler\n * axes.on({\n *\t"hold" : function(evt) {\n *\t},\n *\t"release" : function(evt) {\n *\t},\n *\t"animationStart" : function(evt) {\n *\t},\n *\t"animationEnd" : function(evt) {\n *\t},\n *\t"change" : function(evt) {\n *\t}\n * });\n *\n * // 3. Initialize inputTypes\n * const panInputArea = new eg.Axes.PanInput("#area", {\n *\tscale: [0.5, 1]\n * });\n * const panInputHmove = new eg.Axes.PanInput("#hmove");\n * const panInputVmove = new eg.Axes.PanInput("#vmove");\n * const pinchInputArea = new eg.Axes.PinchInput("#area", {\n *\tscale: 1.5\n * });\n *\n * // 4. Connect eg.Axes and InputTypes\n * // [PanInput] When the mouse or touchscreen is down and moved.\n * // Connect the \'something2\' axis to the mouse or touchscreen x position and\n * // connect the \'somethingN\' axis to the mouse or touchscreen y position.\n * axes.connect(["something2", "somethingN"], panInputArea); // or axes.connect("something2 somethingN", panInputArea);\n *\n * // Connect only one \'something1\' axis to the mouse or touchscreen x position.\n * axes.connect(["something1"], panInputHmove); // or axes.connect("something1", panInputHmove);\n *\n * // Connect only one \'something2\' axis to the mouse or touchscreen y position.\n * axes.connect(["", "something2"], panInputVmove); // or axes.connect(" something2", panInputVmove);\n *\n * // [PinchInput] Connect \'something2\' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * axes.connect("something2", pinchInputArea);\n */\n\nvar Axes =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Axes, _super);\n\n  function Axes(axis, options, startPos) {\n    if (axis === void 0) {\n      axis = {};\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.axis = axis;\n    _this._inputs = [];\n    _this.options = __assign({\n      easing: function easeOutCubic(x) {\n        return 1 - Math.pow(1 - x, 3);\n      },\n      interruptable: true,\n      maximumDuration: Infinity,\n      minimumDuration: 0,\n      deceleration: 0.0006,\n      round: null\n    }, options);\n    _this.itm = new InterruptManager(_this.options);\n    _this.axm = new AxisManager(_this.axis, _this.options);\n    _this.em = new EventManager(_this);\n    _this.am = new AnimationManager(_this);\n    _this.io = new InputObserver(_this);\n\n    _this.em.setAnimationManager(_this.am);\n\n    startPos && _this.em.triggerChange(startPos);\n    return _this;\n  }\n  /**\n   * Connect the axis of eg.Axes to the inputType.\n   * @ko eg.Axes의 축과 inputType을 연결한다\n   * @method eg.Axes#connect\n   * @param {(String[]|String)} axes The name of the axis to associate with inputType <ko>inputType과 연결할 축의 이름</ko>\n   * @param {Object} inputType The inputType instance to associate with the axis of eg.Axes <ko>eg.Axes의 축과 연결할 inputType 인스턴스<ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "xOther": {\n   *      range: [-100, 100]\n   *   }\n   * });\n   *\n   * axes.connect("x", new eg.Axes.PanInput("#area1"))\n   *    .connect("x xOther", new eg.Axes.PanInput("#area2"))\n   *    .connect(" xOther", new eg.Axes.PanInput("#area3"))\n   *    .connect(["x"], new eg.Axes.PanInput("#area4"))\n   *    .connect(["xOther", "x"], new eg.Axes.PanInput("#area5"))\n   *    .connect(["", "xOther"], new eg.Axes.PanInput("#area6"));\n   */\n\n\n  var __proto = Axes.prototype;\n\n  __proto.connect = function (axes, inputType) {\n    var mapped;\n\n    if (typeof axes === "string") {\n      mapped = axes.split(" ");\n    } else {\n      mapped = axes.concat();\n    } // check same instance\n\n\n    if (~this._inputs.indexOf(inputType)) {\n      this.disconnect(inputType);\n    } // check same element in hammer type for share\n\n\n    if ("hammer" in inputType) {\n      var targets = this._inputs.filter(function (v) {\n        return v.hammer && v.element === inputType.element;\n      });\n\n      if (targets.length) {\n        inputType.hammer = targets[0].hammer;\n      }\n    }\n\n    inputType.mapAxes(mapped);\n    inputType.connect(this.io);\n\n    this._inputs.push(inputType);\n\n    return this;\n  };\n  /**\n   * Disconnect the axis of eg.Axes from the inputType.\n   * @ko eg.Axes의 축과 inputType의 연결을 끊는다.\n   * @method eg.Axes#disconnect\n   * @param {Object} [inputType] An inputType instance associated with the axis of eg.Axes <ko>eg.Axes의 축과 연결한 inputType 인스턴스<ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "xOther": {\n   *      range: [-100, 100]\n   *   }\n   * });\n   *\n   * const input1 = new eg.Axes.PanInput("#area1");\n   * const input2 = new eg.Axes.PanInput("#area2");\n   * const input3 = new eg.Axes.PanInput("#area3");\n   *\n   * axes.connect("x", input1);\n   *    .connect("x xOther", input2)\n   *    .connect(["xOther", "x"], input3);\n   *\n   * axes.disconnect(input1); // disconnects input1\n   * axes.disconnect(); // disconnects all of them\n   */\n\n\n  __proto.disconnect = function (inputType) {\n    if (inputType) {\n      var index = this._inputs.indexOf(inputType);\n\n      if (index >= 0) {\n        this._inputs[index].disconnect();\n\n        this._inputs.splice(index, 1);\n      }\n    } else {\n      this._inputs.forEach(function (v) {\n        return v.disconnect();\n      });\n\n      this._inputs = [];\n    }\n\n    return this;\n  };\n  /**\n   * Returns the current position of the coordinates.\n   * @ko 좌표의 현재 위치를 반환한다\n   * @method eg.Axes#get\n   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>\n   * @return {Object.<string, number>} Axis coordinate information <ko>축 좌표 정보</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "xOther": {\n   *      range: [-100, 100]\n   *   },\n   * \t "zoom": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.get(); // {"x": 0, "xOther": -100, "zoom": 50}\n   * axes.get(["x", "zoom"]); // {"x": 0, "zoom": 50}\n   */\n\n\n  __proto.get = function (axes) {\n    return this.axm.get(axes);\n  };\n  /**\n   * Moves an axis to specific coordinates.\n   * @ko 좌표를 이동한다.\n   * @method eg.Axes#setTo\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "xOther": {\n   *      range: [-100, 100]\n   *   },\n   * \t "zoom": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.setTo({"x": 30, "zoom": 60});\n   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}\n   *\n   * axes.setTo({"x": 100, "xOther": 60}, 1000); // animatation\n   *\n   * // after 1000 ms\n   * axes.get(); // {"x": 100, "xOther": 60, "zoom": 60}\n   */\n\n\n  __proto.setTo = function (pos, duration) {\n    if (duration === void 0) {\n      duration = 0;\n    }\n\n    this.am.setTo(pos, duration);\n    return this;\n  };\n  /**\n   * Moves an axis from the current coordinates to specific coordinates.\n   * @ko 현재 좌표를 기준으로 좌표를 이동한다.\n   * @method eg.Axes#setBy\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "xOther": {\n   *      range: [-100, 100]\n   *   },\n   * \t "zoom": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.setBy({"x": 30, "zoom": 10});\n   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}\n   *\n   * axes.setBy({"x": 70, "xOther": 60}, 1000); // animatation\n   *\n   * // after 1000 ms\n   * axes.get(); // {"x": 100, "xOther": -40, "zoom": 60}\n   */\n\n\n  __proto.setBy = function (pos, duration) {\n    if (duration === void 0) {\n      duration = 0;\n    }\n\n    this.am.setBy(pos, duration);\n    return this;\n  };\n  /**\n   * Returns whether there is a coordinate in the bounce area of ​​the target axis.\n   * @ko 대상 축 중 bounce영역에 좌표가 존재하는지를 반환한다\n   * @method eg.Axes#isBounceArea\n   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>\n   * @return {Boolen} Whether the bounce area exists. <ko>bounce 영역 존재 여부</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   "x": {\n   *      range: [0, 100]\n   *   },\n   *   "xOther": {\n   *      range: [-100, 100]\n   *   },\n   * \t "zoom": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.isBounceArea(["x"]);\n   * axes.isBounceArea(["x", "zoom"]);\n   * axes.isBounceArea();\n   */\n\n\n  __proto.isBounceArea = function (axes) {\n    return this.axm.isOutside(axes);\n  };\n  /**\n  * Destroys properties, and events used in a module and disconnect all connections to inputTypes.\n  * @ko 모듈에 사용한 속성, 이벤트를 해제한다. 모든 inputType과의 연결을 끊는다.\n  * @method eg.Axes#destroy\n  */\n\n\n  __proto.destroy = function () {\n    this.disconnect();\n    this.em.destroy();\n  };\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @type {String}\n   * @example\n   * eg.Axes.VERSION;  // ex) 3.3.3\n   * @memberof eg.Axes\n   */\n\n\n  Axes.VERSION = "2.8.0";\n  /**\n   * @name eg.Axes.TRANSFORM\n   * @desc Returns the transform attribute with CSS vendor prefixes.\n   * @ko CSS vendor prefixes를 붙인 transform 속성을 반환한다.\n   *\n   * @constant\n   * @type {String}\n   * @example\n   * eg.Axes.TRANSFORM; // "transform" or "webkitTransform"\n   */\n\n  Axes.TRANSFORM = TRANSFORM;\n  /**\n   * @name eg.Axes.DIRECTION_NONE\n   * @constant\n   * @type {Number}\n   */\n\n  Axes.DIRECTION_NONE = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_NONE"];\n  /**\n   * @name eg.Axes.DIRECTION_LEFT\n   * @constant\n   * @type {Number}\n  */\n\n  Axes.DIRECTION_LEFT = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_LEFT"];\n  /**\n   * @name eg.Axes.DIRECTION_RIGHT\n   * @constant\n   * @type {Number}\n  */\n\n  Axes.DIRECTION_RIGHT = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_RIGHT"];\n  /**\n   * @name eg.Axes.DIRECTION_UP\n   * @constant\n   * @type {Number}\n  */\n\n  Axes.DIRECTION_UP = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_UP"];\n  /**\n   * @name eg.Axes.DIRECTION_DOWN\n   * @constant\n   * @type {Number}\n  */\n\n  Axes.DIRECTION_DOWN = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_DOWN"];\n  /**\n   * @name eg.Axes.DIRECTION_HORIZONTAL\n   * @constant\n   * @type {Number}\n  */\n\n  Axes.DIRECTION_HORIZONTAL = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_HORIZONTAL"];\n  /**\n   * @name eg.Axes.DIRECTION_VERTICAL\n   * @constant\n   * @type {Number}\n  */\n\n  Axes.DIRECTION_VERTICAL = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_VERTICAL"];\n  /**\n   * @name eg.Axes.DIRECTION_ALL\n   * @constant\n   * @type {Number}\n  */\n\n  Axes.DIRECTION_ALL = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_ALL"];\n  return Axes;\n}(_egjs_component__WEBPACK_IMPORTED_MODULE_2__["default"]);\n\nvar SUPPORT_POINTER_EVENTS = "PointerEvent" in win || "MSPointerEvent" in win;\nvar SUPPORT_TOUCH = ("ontouchstart" in win);\nvar UNIQUEKEY = "_EGJS_AXES_INPUTTYPE_";\nfunction toAxis(source, offset) {\n  return offset.reduce(function (acc, v, i) {\n    if (source[i]) {\n      acc[source[i]] = v;\n    }\n\n    return acc;\n  }, {});\n}\nfunction createHammer(element, options) {\n  try {\n    // create Hammer\n    return new _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["Manager"](element, __assign({}, options));\n  } catch (e) {\n    return null;\n  }\n}\nfunction convertInputType(inputType) {\n  if (inputType === void 0) {\n    inputType = [];\n  }\n\n  var hasTouch = false;\n  var hasMouse = false;\n  var hasPointer = false;\n  inputType.forEach(function (v) {\n    switch (v) {\n      case "mouse":\n        hasMouse = true;\n        break;\n\n      case "touch":\n        hasTouch = SUPPORT_TOUCH;\n        break;\n\n      case "pointer":\n        hasPointer = SUPPORT_POINTER_EVENTS;\n      // no default\n    }\n  });\n\n  if (hasPointer) {\n    return _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["PointerEventInput"];\n  } else if (hasTouch && hasMouse) {\n    return _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["TouchMouseInput"];\n  } else if (hasTouch) {\n    return _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["TouchInput"];\n  } else if (hasMouse) {\n    return _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["MouseInput"];\n  }\n\n  return null;\n}\n\nfunction getDirectionByAngle(angle, thresholdAngle) {\n  if (thresholdAngle < 0 || thresholdAngle > 90) {\n    return _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_NONE"];\n  }\n\n  var toAngle = Math.abs(angle);\n  return toAngle > thresholdAngle && toAngle < 180 - thresholdAngle ? _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_VERTICAL"] : _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_HORIZONTAL"];\n}\nfunction getNextOffset(speeds, deceleration) {\n  var normalSpeed = Math.sqrt(speeds[0] * speeds[0] + speeds[1] * speeds[1]);\n  var duration = Math.abs(normalSpeed / -deceleration);\n  return [speeds[0] / 2 * duration, speeds[1] / 2 * duration];\n}\nfunction useDirection(checkType, direction, userDirection) {\n  if (userDirection) {\n    return !!(direction === _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_ALL"] || direction & checkType && userDirection & checkType);\n  } else {\n    return !!(direction & checkType);\n  }\n}\n/**\n * @typedef {Object} PanInputOption The option object of the eg.Axes.PanInput module.\n * @ko eg.Axes.PanInput 모듈의 옵션 객체\n * @property {String[]} [inputType=["touch","mouse", "pointer"]] Types of input devices.<br>- touch: Touch screen<br>- mouse: Mouse <ko>입력 장치 종류.<br>- touch: 터치 입력 장치<br>- mouse: 마우스</ko>\n * @property {Number[]} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @property {Number} [scale.0=1] horizontal axis scale <ko>수평축 배율</ko>\n * @property {Number} [scale.1=1] vertical axis scale <ko>수직축 배율</ko>\n * @property {Number} [thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>\n * @property {Number} [threshold=0] Minimal pan distance required before recognizing <ko>사용자의 Pan 동작을 인식하기 위해산 최소한의 거리</ko>\n * @property {Number} [iOSEdgeSwipeThreshold=30] Area (px) that can go to the next page when swiping the right edge in iOS safari <ko>iOS Safari에서 오른쪽 엣지를 스와이프 하는 경우 다음 페이지로 넘어갈 수 있는 영역(px)</ko>\n * @property {Object} [hammerManagerOptions={cssProps: {userSelect: "none",touchSelect: "none",touchCallout: "none",userDrag: "none"}] Options of Hammer.Manager <ko>Hammer.Manager의 옵션</ko>\n**/\n\n/**\n * @class eg.Axes.PanInput\n * @classdesc A module that passes the amount of change to eg.Axes when the mouse or touchscreen is down and moved. use less than two axes.\n * @ko 마우스나 터치 스크린을 누르고 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 두개 이하의 축을 사용한다.\n *\n * @example\n * const pan = new eg.Axes.PanInput("#area", {\n * \t\tinputType: ["touch"],\n * \t\tscale: [1, 1.3],\n * });\n *\n * // Connect the \'something2\' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.\n * // Connect the \'somethingN\' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.\n * axes.connect(["something2", "somethingN"], pan); // or axes.connect("something2 somethingN", pan);\n *\n * // Connect only one \'something1\' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.\n * axes.connect(["something1"], pan); // or axes.connect("something1", pan);\n *\n * // Connect only one \'something2\' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.\n * axes.connect(["", "something2"], pan); // or axes.connect(" something2", pan);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.PanInput module <ko>eg.Axes.PanInput 모듈을 사용할 엘리먼트</ko>\n * @param {PanInputOption} [options] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>\n */\n\nvar PanInput =\n/*#__PURE__*/\nfunction () {\n  function PanInput(el, options) {\n    this.axes = [];\n    this.hammer = null;\n    this.element = null;\n    this.panRecognizer = null;\n    this.isRightEdge = false;\n    this.rightEdgeTimer = 0;\n    this.panFlag = false;\n    /**\n     * Hammer helps you add support for touch gestures to your page\n     *\n     * @external Hammer\n     * @see {@link http://hammerjs.github.io|Hammer.JS}\n     * @see {@link http://hammerjs.github.io/jsdoc/Hammer.html|Hammer.JS API documents}\n     * @see Hammer.JS applies specific CSS properties by {@link http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html|default} when creating an instance. The eg.Axes module removes all default CSS properties provided by Hammer.JS\n     */\n\n    if (typeof _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["Manager"] === "undefined") {\n      throw new Error("The Hammerjs must be loaded before eg.Axes.PanInput.\\nhttp://hammerjs.github.io/");\n    }\n\n    this.element = $(el);\n    this.options = __assign({\n      inputType: ["touch", "mouse", "pointer"],\n      scale: [1, 1],\n      thresholdAngle: 45,\n      threshold: 0,\n      iOSEdgeSwipeThreshold: IOS_EDGE_THRESHOLD,\n      releaseOnScroll: false,\n      hammerManagerOptions: {\n        // css properties were removed due to usablility issue\n        // http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html\n        cssProps: {\n          userSelect: "none",\n          touchSelect: "none",\n          touchCallout: "none",\n          userDrag: "none"\n        }\n      }\n    }, options);\n    this.onHammerInput = this.onHammerInput.bind(this);\n    this.onPanmove = this.onPanmove.bind(this);\n    this.onPanend = this.onPanend.bind(this);\n  }\n\n  var __proto = PanInput.prototype;\n\n  __proto.mapAxes = function (axes) {\n    var useHorizontal = !!axes[0];\n    var useVertical = !!axes[1];\n\n    if (useHorizontal && useVertical) {\n      this._direction = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_ALL"];\n    } else if (useHorizontal) {\n      this._direction = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_HORIZONTAL"];\n    } else if (useVertical) {\n      this._direction = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_VERTICAL"];\n    } else {\n      this._direction = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_NONE"];\n    }\n\n    this.axes = axes;\n  };\n\n  __proto.connect = function (observer) {\n    var hammerOption = {\n      direction: this._direction,\n      threshold: this.options.threshold\n    };\n\n    if (this.hammer) {\n      // for sharing hammer instance.\n      // hammer remove previous PanRecognizer.\n      this.removeRecognizer();\n      this.dettachEvent();\n    } else {\n      var keyValue = this.element[UNIQUEKEY];\n\n      if (!keyValue) {\n        keyValue = String(Math.round(Math.random() * new Date().getTime()));\n      }\n\n      var inputClass = convertInputType(this.options.inputType);\n\n      if (!inputClass) {\n        throw new Error("Wrong inputType parameter!");\n      }\n\n      this.hammer = createHammer(this.element, __assign({\n        inputClass: inputClass\n      }, this.options.hammerManagerOptions));\n      this.element[UNIQUEKEY] = keyValue;\n    }\n\n    this.panRecognizer = new _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["Pan"](hammerOption);\n    this.hammer.add(this.panRecognizer);\n    this.attachEvent(observer);\n    return this;\n  };\n\n  __proto.disconnect = function () {\n    this.removeRecognizer();\n\n    if (this.hammer) {\n      this.dettachEvent();\n    }\n\n    this._direction = _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_NONE"];\n    return this;\n  };\n  /**\n  * Destroys elements, properties, and events used in a module.\n  * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n  * @method eg.Axes.PanInput#destroy\n  */\n\n\n  __proto.destroy = function () {\n    this.disconnect();\n\n    if (this.hammer && this.hammer.recognizers.length === 0) {\n      this.hammer.destroy();\n    }\n\n    delete this.element[UNIQUEKEY];\n    this.element = null;\n    this.hammer = null;\n  };\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.PanInput#enable\n   * @return {eg.Axes.PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.enable = function () {\n    this.hammer && (this.hammer.get("pan").options.enable = true);\n    return this;\n  };\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.PanInput#disable\n   * @return {eg.Axes.PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.disable = function () {\n    this.hammer && (this.hammer.get("pan").options.enable = false);\n    return this;\n  };\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.PanInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n\n\n  __proto.isEnable = function () {\n    return !!(this.hammer && this.hammer.get("pan").options.enable);\n  };\n\n  __proto.removeRecognizer = function () {\n    if (this.hammer && this.panRecognizer) {\n      this.hammer.remove(this.panRecognizer);\n      this.panRecognizer = null;\n    }\n  };\n\n  __proto.onHammerInput = function (event) {\n    if (this.isEnable()) {\n      if (event.isFirst) {\n        this.panFlag = false;\n\n        if (event.srcEvent.cancelable !== false) {\n          var edgeThreshold = this.options.iOSEdgeSwipeThreshold;\n          this.observer.hold(this, event);\n          this.isRightEdge = IS_IOS_SAFARI && event.center.x > window.innerWidth - edgeThreshold;\n          this.panFlag = true;\n        }\n      } else if (event.isFinal) {\n        this.onPanend(event);\n      }\n    }\n  };\n\n  __proto.onPanmove = function (event) {\n    var _this = this;\n\n    if (!this.panFlag) {\n      return;\n    }\n\n    var _a = this.options,\n        iOSEdgeSwipeThreshold = _a.iOSEdgeSwipeThreshold,\n        releaseOnScroll = _a.releaseOnScroll;\n    var userDirection = getDirectionByAngle(event.angle, this.options.thresholdAngle); // not support offset properties in Hammerjs - start\n\n    var prevInput = this.hammer.session.prevInput;\n\n    if (releaseOnScroll && !event.srcEvent.cancelable) {\n      this.onPanend(__assign(__assign({}, event), {\n        velocityX: 0,\n        velocityY: 0,\n        offsetX: 0,\n        offsetY: 0\n      }));\n      return;\n    }\n\n    if (prevInput && IS_IOS_SAFARI) {\n      var swipeLeftToRight = event.center.x < 0;\n\n      if (swipeLeftToRight) {\n        // iOS swipe left => right\n        this.onPanend(__assign(__assign({}, prevInput), {\n          velocityX: 0,\n          velocityY: 0,\n          offsetX: 0,\n          offsetY: 0\n        }));\n        return;\n      } else if (this.isRightEdge) {\n        clearTimeout(this.rightEdgeTimer); // - is right to left\n\n        var swipeRightToLeft = event.deltaX < -iOSEdgeSwipeThreshold;\n\n        if (swipeRightToLeft) {\n          this.isRightEdge = false;\n        } else {\n          // iOS swipe right => left\n          this.rightEdgeTimer = window.setTimeout(function () {\n            _this.onPanend(__assign(__assign({}, prevInput), {\n              velocityX: 0,\n              velocityY: 0,\n              offsetX: 0,\n              offsetY: 0\n            }));\n          }, 100);\n        }\n      }\n    }\n    /* eslint-disable no-param-reassign */\n\n\n    if (prevInput) {\n      event.offsetX = event.deltaX - prevInput.deltaX;\n      event.offsetY = event.deltaY - prevInput.deltaY;\n    } else {\n      event.offsetX = 0;\n      event.offsetY = 0;\n    }\n\n    var offset = this.getOffset([event.offsetX, event.offsetY], [useDirection(_egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_HORIZONTAL"], this._direction, userDirection), useDirection(_egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_VERTICAL"], this._direction, userDirection)]);\n    var prevent = offset.some(function (v) {\n      return v !== 0;\n    });\n\n    if (prevent) {\n      var srcEvent = event.srcEvent;\n\n      if (srcEvent.cancelable !== false) {\n        srcEvent.preventDefault();\n      }\n\n      srcEvent.stopPropagation();\n    }\n\n    event.preventSystemEvent = prevent;\n    prevent && this.observer.change(this, event, toAxis(this.axes, offset));\n  };\n\n  __proto.onPanend = function (event) {\n    if (!this.panFlag) {\n      return;\n    }\n\n    clearTimeout(this.rightEdgeTimer);\n    this.panFlag = false;\n    var offset = this.getOffset([Math.abs(event.velocityX) * (event.deltaX < 0 ? -1 : 1), Math.abs(event.velocityY) * (event.deltaY < 0 ? -1 : 1)], [useDirection(_egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_HORIZONTAL"], this._direction), useDirection(_egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["DIRECTION_VERTICAL"], this._direction)]);\n    offset = getNextOffset(offset, this.observer.options.deceleration);\n    this.observer.release(this, event, toAxis(this.axes, offset));\n  };\n\n  __proto.attachEvent = function (observer) {\n    this.observer = observer;\n    this.hammer.on("hammer.input", this.onHammerInput).on("panstart panmove", this.onPanmove);\n  };\n\n  __proto.dettachEvent = function () {\n    this.hammer.off("hammer.input", this.onHammerInput).off("panstart panmove", this.onPanmove);\n    this.observer = null;\n  };\n\n  __proto.getOffset = function (properties, direction) {\n    var offset = [0, 0];\n    var scale = this.options.scale;\n\n    if (direction[0]) {\n      offset[0] = properties[0] * scale[0];\n    }\n\n    if (direction[1]) {\n      offset[1] = properties[1] * scale[1];\n    }\n\n    return offset;\n  };\n\n  return PanInput;\n}();\n\n/**\n * @class eg.Axes.RotatePanInput\n * @classdesc A module that passes the angle moved by touch to Axes and uses one axis of rotation.<br>[Details](https://github.com/naver/egjs-axes/wiki/RotatePanInput)\n * @ko 터치에 의해 움직인 각도를 Axes 에 전달하며 1개의 회전축만 사용한다.<br>[상세내용](https://github.com/naver/egjs-axes/wiki/RotatePanInput-%7C-%ED%95%9C%EA%B5%AD%EC%96%B4)\n *\n * @example\n * const input = new eg.Axes.RotatePanInput("#area");\n *\n * var axes = new eg.Axes({\n *\t// property name(\'angle\') could be anything you want (eg. x, y, z...)\n * \tangle: {\n * \t\trange: [-180, 180] // from -180deg to 180deg\n * \t}\n * });\n *\n * axes.connect("angle", input)\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.RotatePanInput module <ko>eg.Axes.RotatePanInput 모듈을 사용할 엘리먼트</ko>\n * @param {PanInputOption} [options] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>\n * @extends eg.Axes.PanInput\n */\n\nvar RotatePanInput =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RotatePanInput, _super);\n\n  function RotatePanInput(el, options) {\n    var _this = _super.call(this, el, options) || this;\n\n    _this.prevQuadrant = null;\n    _this.lastDiff = 0;\n    return _this;\n  }\n\n  var __proto = RotatePanInput.prototype;\n\n  __proto.mapAxes = function (axes) {\n    this._direction = Axes.DIRECTION_ALL;\n    this.axes = axes;\n  };\n\n  __proto.onHammerInput = function (event) {\n    if (this.isEnable()) {\n      if (event.isFirst) {\n        this.observer.hold(this, event);\n        this.onPanstart(event);\n      } else if (event.isFinal) {\n        this.onPanend(event);\n      }\n    }\n  };\n\n  __proto.onPanstart = function (event) {\n    var rect = this.element.getBoundingClientRect();\n    /**\n     * Responsive\n     */\n    // TODO: how to do if element is ellipse not circle.\n\n    this.coefficientForDistanceToAngle = 360 / (rect.width * Math.PI); // from 2*pi*r * x / 360\n    // TODO: provide a way to set origin like https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n\n    this.rotateOrigin = [rect.left + (rect.width - 1) / 2, rect.top + (rect.height - 1) / 2]; // init angle.\n\n    this.prevAngle = null;\n    this.triggerChange(event);\n  };\n\n  __proto.onPanmove = function (event) {\n    this.triggerChange(event);\n  };\n\n  __proto.onPanend = function (event) {\n    this.triggerChange(event);\n    this.triggerAnimation(event);\n  };\n\n  __proto.triggerChange = function (event) {\n    var angle = this.getAngle(event.center.x, event.center.y);\n    var quadrant = this.getQuadrant(event.center.x, event.center.y);\n    var diff = this.getDifference(this.prevAngle, angle, this.prevQuadrant, quadrant);\n    this.prevAngle = angle;\n    this.prevQuadrant = quadrant;\n\n    if (diff === 0) {\n      return;\n    }\n\n    this.lastDiff = diff;\n    this.observer.change(this, event, toAxis(this.axes, [-diff])); // minus for clockwise\n  };\n\n  __proto.triggerAnimation = function (event) {\n    var vx = event.velocityX;\n    var vy = event.velocityY;\n    var velocity = Math.sqrt(vx * vx + vy * vy) * (this.lastDiff > 0 ? -1 : 1); // clockwise\n\n    var duration = Math.abs(velocity / -this.observer.options.deceleration);\n    var distance = velocity / 2 * duration;\n    this.observer.release(this, event, toAxis(this.axes, [distance * this.coefficientForDistanceToAngle]));\n  };\n\n  __proto.getDifference = function (prevAngle, angle, prevQuadrant, quadrant) {\n    var diff;\n\n    if (prevAngle === null) {\n      diff = 0;\n    } else if (prevQuadrant === 1 && quadrant === 4) {\n      diff = -prevAngle - (360 - angle);\n    } else if (prevQuadrant === 4 && quadrant === 1) {\n      diff = 360 - prevAngle + angle;\n    } else {\n      diff = angle - prevAngle;\n    }\n\n    return diff;\n  };\n\n  __proto.getPosFromOrigin = function (posX, posY) {\n    return {\n      x: posX - this.rotateOrigin[0],\n      y: this.rotateOrigin[1] - posY\n    };\n  };\n\n  __proto.getAngle = function (posX, posY) {\n    var _a = this.getPosFromOrigin(posX, posY),\n        x = _a.x,\n        y = _a.y;\n\n    var angle = Math.atan2(y, x) * 180 / Math.PI; // console.log(angle, x, y);\n\n    return angle < 0 ? 360 + angle : angle;\n  };\n  /**\n   * Quadrant\n   *       y(+)\n   *       |\n   *   2   |    1\n   * ---------------\x3ex(+)\n   *   3   |    4\n   *       |\n   */\n\n\n  __proto.getQuadrant = function (posX, posY) {\n    var _a = this.getPosFromOrigin(posX, posY),\n        x = _a.x,\n        y = _a.y;\n\n    var q = 0;\n\n    if (x >= 0 && y >= 0) {\n      q = 1;\n    } else if (x < 0 && y >= 0) {\n      q = 2;\n    } else if (x < 0 && y < 0) {\n      q = 3;\n    } else if (x >= 0 && y < 0) {\n      q = 4;\n    }\n\n    return q;\n  };\n\n  return RotatePanInput;\n}(PanInput);\n\n/**\n * @typedef {Object} PinchInputOption The option object of the eg.Axes.PinchInput module\n * @ko eg.Axes.PinchInput 모듈의 옵션 객체\n * @property {Number} [scale=1] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @property {Number} [threshold=0] Minimal scale before recognizing <ko>사용자의 Pinch 동작을 인식하기 위해산 최소한의 배율</ko>\n * @property {Object} [hammerManagerOptions={cssProps: {userSelect: "none",touchSelect: "none",touchCallout: "none",userDrag: "none"}] Options of Hammer.Manager <ko>Hammer.Manager의 옵션</ko>\n**/\n\n/**\n * @class eg.Axes.PinchInput\n * @classdesc A module that passes the amount of change to eg.Axes when two pointers are moving toward (zoom-in) or away from each other (zoom-out). use one axis.\n * @ko 2개의 pointer를 이용하여 zoom-in하거나 zoom-out 하는 동작의 변화량을 eg.Axes에 전달하는 모듈. 한 개 의 축을 사용한다.\n * @example\n * const pinch = new eg.Axes.PinchInput("#area", {\n * \t\tscale: 1\n * });\n *\n * // Connect \'something\' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * axes.connect("something", pinch);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.PinchInput module <ko>eg.Axes.PinchInput 모듈을 사용할 엘리먼트</ko>\n * @param {PinchInputOption} [options] The option object of the eg.Axes.PinchInput module<ko>eg.Axes.PinchInput 모듈의 옵션 객체</ko>\n */\n\nvar PinchInput =\n/*#__PURE__*/\nfunction () {\n  function PinchInput(el, options) {\n    this.axes = [];\n    this.hammer = null;\n    this.element = null;\n    this._base = null;\n    this._prev = null;\n    this.pinchRecognizer = null;\n    /**\n     * Hammer helps you add support for touch gestures to your page\n     *\n     * @external Hammer\n     * @see {@link http://hammerjs.github.io|Hammer.JS}\n     * @see {@link http://hammerjs.github.io/jsdoc/Hammer.html|Hammer.JS API documents}\n     * @see Hammer.JS applies specific CSS properties by {@link http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html|default} when creating an instance. The eg.Axes module removes all default CSS properties provided by Hammer.JS\n     */\n\n    if (typeof _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["Manager"] === "undefined") {\n      throw new Error("The Hammerjs must be loaded before eg.Axes.PinchInput.\\nhttp://hammerjs.github.io/");\n    }\n\n    this.element = $(el);\n    this.options = __assign({\n      scale: 1,\n      threshold: 0,\n      inputType: ["touch", "pointer"],\n      hammerManagerOptions: {\n        // css properties were removed due to usablility issue\n        // http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html\n        cssProps: {\n          userSelect: "none",\n          touchSelect: "none",\n          touchCallout: "none",\n          userDrag: "none"\n        }\n      }\n    }, options);\n    this.onPinchStart = this.onPinchStart.bind(this);\n    this.onPinchMove = this.onPinchMove.bind(this);\n    this.onPinchEnd = this.onPinchEnd.bind(this);\n  }\n\n  var __proto = PinchInput.prototype;\n\n  __proto.mapAxes = function (axes) {\n    this.axes = axes;\n  };\n\n  __proto.connect = function (observer) {\n    var hammerOption = {\n      threshold: this.options.threshold\n    };\n\n    if (this.hammer) {\n      // for sharing hammer instance.\n      // hammer remove previous PinchRecognizer.\n      this.removeRecognizer();\n      this.dettachEvent();\n    } else {\n      var keyValue = this.element[UNIQUEKEY];\n\n      if (!keyValue) {\n        keyValue = String(Math.round(Math.random() * new Date().getTime()));\n      }\n\n      var inputClass = convertInputType(this.options.inputType);\n\n      if (!inputClass) {\n        throw new Error("Wrong inputType parameter!");\n      }\n\n      this.hammer = createHammer(this.element, __assign({\n        inputClass: inputClass\n      }, this.options.hammerManagerOptions));\n      this.element[UNIQUEKEY] = keyValue;\n    }\n\n    this.pinchRecognizer = new _egjs_hammerjs__WEBPACK_IMPORTED_MODULE_0__["Pinch"](hammerOption);\n    this.hammer.add(this.pinchRecognizer);\n    this.attachEvent(observer);\n    return this;\n  };\n\n  __proto.disconnect = function () {\n    this.removeRecognizer();\n\n    if (this.hammer) {\n      this.hammer.remove(this.pinchRecognizer);\n      this.pinchRecognizer = null;\n      this.dettachEvent();\n    }\n\n    return this;\n  };\n  /**\n  * Destroys elements, properties, and events used in a module.\n  * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n  * @method eg.Axes.PinchInput#destroy\n  */\n\n\n  __proto.destroy = function () {\n    this.disconnect();\n\n    if (this.hammer && this.hammer.recognizers.length === 0) {\n      this.hammer.destroy();\n    }\n\n    delete this.element[UNIQUEKEY];\n    this.element = null;\n    this.hammer = null;\n  };\n\n  __proto.removeRecognizer = function () {\n    if (this.hammer && this.pinchRecognizer) {\n      this.hammer.remove(this.pinchRecognizer);\n      this.pinchRecognizer = null;\n    }\n  };\n\n  __proto.onPinchStart = function (event) {\n    this._base = this.observer.get(this)[this.axes[0]];\n    var offset = this.getOffset(event.scale);\n    this.observer.hold(this, event);\n    this.observer.change(this, event, toAxis(this.axes, [offset]));\n    this._prev = event.scale;\n  };\n\n  __proto.onPinchMove = function (event) {\n    var offset = this.getOffset(event.scale, this._prev);\n    this.observer.change(this, event, toAxis(this.axes, [offset]));\n    this._prev = event.scale;\n  };\n\n  __proto.onPinchEnd = function (event) {\n    var offset = this.getOffset(event.scale, this._prev);\n    this.observer.change(this, event, toAxis(this.axes, [offset]));\n    this.observer.release(this, event, toAxis(this.axes, [0]), 0);\n    this._base = null;\n    this._prev = null;\n  };\n\n  __proto.getOffset = function (pinchScale, prev) {\n    if (prev === void 0) {\n      prev = 1;\n    }\n\n    return this._base * (pinchScale - prev) * this.options.scale;\n  };\n\n  __proto.attachEvent = function (observer) {\n    this.observer = observer;\n    this.hammer.on("pinchstart", this.onPinchStart).on("pinchmove", this.onPinchMove).on("pinchend", this.onPinchEnd);\n  };\n\n  __proto.dettachEvent = function () {\n    this.hammer.off("pinchstart", this.onPinchStart).off("pinchmove", this.onPinchMove).off("pinchend", this.onPinchEnd);\n    this.observer = null;\n    this._prev = null;\n  };\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.PinchInput#enable\n   * @return {eg.Axes.PinchInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.enable = function () {\n    this.hammer && (this.hammer.get("pinch").options.enable = true);\n    return this;\n  };\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.PinchInput#disable\n   * @return {eg.Axes.PinchInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.disable = function () {\n    this.hammer && (this.hammer.get("pinch").options.enable = false);\n    return this;\n  };\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.PinchInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n\n\n  __proto.isEnable = function () {\n    return !!(this.hammer && this.hammer.get("pinch").options.enable);\n  };\n\n  return PinchInput;\n}();\n\n/**\n * @typedef {Object} WheelInputOption The option object of the eg.Axes.WheelInput module\n * @ko eg.Axes.WheelInput 모듈의 옵션 객체\n * @property {Number} [scale=1] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n**/\n\n/**\n * @class eg.Axes.WheelInput\n * @classdesc A module that passes the amount of change to eg.Axes when the mouse wheel is moved. use one axis.\n * @ko 마우스 휠이 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 한 개 의 축을 사용한다.\n *\n * @example\n * const wheel = new eg.Axes.WheelInput("#area", {\n * \t\tscale: 1\n * });\n *\n * // Connect \'something\' axis when the mousewheel is moved.\n * axes.connect("something", wheel);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.WheelInput module <ko>eg.Axes.WheelInput 모듈을 사용할 엘리먼트</ko>\n * @param {WheelInputOption} [options] The option object of the eg.Axes.WheelInput module<ko>eg.Axes.WheelInput 모듈의 옵션 객체</ko>\n */\n\nvar WheelInput =\n/*#__PURE__*/\nfunction () {\n  function WheelInput(el, options) {\n    this.axes = [];\n    this.element = null;\n    this._isEnabled = false;\n    this._isHolded = false;\n    this._timer = null;\n    this.element = $(el);\n    this.options = __assign({\n      scale: 1,\n      useNormalized: true\n    }, options);\n    this.onWheel = this.onWheel.bind(this);\n  }\n\n  var __proto = WheelInput.prototype;\n\n  __proto.mapAxes = function (axes) {\n    this.axes = axes;\n  };\n\n  __proto.connect = function (observer) {\n    this.dettachEvent();\n    this.attachEvent(observer);\n    return this;\n  };\n\n  __proto.disconnect = function () {\n    this.dettachEvent();\n    return this;\n  };\n  /**\n  * Destroys elements, properties, and events used in a module.\n  * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n  * @method eg.Axes.WheelInput#destroy\n  */\n\n\n  __proto.destroy = function () {\n    this.disconnect();\n    this.element = null;\n  };\n\n  __proto.onWheel = function (event) {\n    var _this = this;\n\n    if (!this._isEnabled) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (event.deltaY === 0) {\n      return;\n    }\n\n    if (!this._isHolded) {\n      this.observer.hold(this, event);\n      this._isHolded = true;\n    }\n\n    var offset = (event.deltaY > 0 ? -1 : 1) * this.options.scale * (this.options.useNormalized ? 1 : Math.abs(event.deltaY));\n    this.observer.change(this, event, toAxis(this.axes, [offset]));\n    clearTimeout(this._timer);\n    this._timer = setTimeout(function () {\n      if (_this._isHolded) {\n        _this._isHolded = false;\n\n        _this.observer.release(_this, event, toAxis(_this.axes, [0]));\n      }\n    }, 50);\n  };\n\n  __proto.attachEvent = function (observer) {\n    this.observer = observer;\n    this.element.addEventListener("wheel", this.onWheel);\n    this._isEnabled = true;\n  };\n\n  __proto.dettachEvent = function () {\n    this.element.removeEventListener("wheel", this.onWheel);\n    this._isEnabled = false;\n    this.observer = null;\n\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  };\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.WheelInput#enable\n   * @return {eg.Axes.WheelInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.enable = function () {\n    this._isEnabled = true;\n    return this;\n  };\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.WheelInput#disable\n   * @return {eg.Axes.WheelInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.disable = function () {\n    this._isEnabled = false;\n    return this;\n  };\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.WheelInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n\n\n  __proto.isEnable = function () {\n    return this._isEnabled;\n  };\n\n  return WheelInput;\n}();\n\nvar KEY_LEFT_ARROW = 37;\nvar KEY_A = 65;\nvar KEY_UP_ARROW = 38;\nvar KEY_W = 87;\nvar KEY_RIGHT_ARROW = 39;\nvar KEY_D = 68;\nvar KEY_DOWN_ARROW = 40;\nvar KEY_S = 83;\nvar DIRECTION_REVERSE = -1;\nvar DIRECTION_FORWARD = 1;\nvar DIRECTION_HORIZONTAL$1 = -1;\nvar DIRECTION_VERTICAL$1 = 1;\nvar DELAY = 80;\n/**\n * @typedef {Object} MoveKeyInputOption The option object of the eg.Axes.MoveKeyInput module\n * @ko eg.Axes.MoveKeyInput 모듈의 옵션 객체\n * @property {Array<Number>} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @property {Number} [scale[0]=1] Coordinate scale for the first axis<ko>첫번째 축의 배율</ko>\n * @property {Number} [scale[1]=1] Coordinate scale for the decond axis<ko>두번째 축의 배율</ko>\n**/\n\n/**\n * @class eg.Axes.MoveKeyInput\n * @classdesc A module that passes the amount of change to eg.Axes when the move key stroke is occured. use two axis.\n * @ko 이동키 입력이 발생했을 때의 변화량을 eg.Axes에 전달하는 모듈. 두 개 의 축을 사용한다.\n *\n * @example\n * const moveKey = new eg.Axes.MoveKeyInput("#area", {\n * \t\tscale: [1, 1]\n * });\n *\n * // Connect \'x\', \'y\' axes when the moveKey is pressed.\n * axes.connect(["x", "y"], moveKey);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.MoveKeyInput module <ko>eg.Axes.MoveKeyInput 모듈을 사용할 엘리먼트</ko>\n * @param {MoveKeyInputOption} [options] The option object of the eg.Axes.MoveKeyInput module<ko>eg.Axes.MoveKeyInput 모듈의 옵션 객체</ko>\n */\n\nvar MoveKeyInput =\n/*#__PURE__*/\nfunction () {\n  function MoveKeyInput(el, options) {\n    this.axes = [];\n    this.element = null;\n    this._isEnabled = false;\n    this._isHolded = false;\n    this._timer = null;\n    this.element = $(el);\n    this.options = __assign({\n      scale: [1, 1]\n    }, options);\n    this.onKeydown = this.onKeydown.bind(this);\n    this.onKeyup = this.onKeyup.bind(this);\n  }\n\n  var __proto = MoveKeyInput.prototype;\n\n  __proto.mapAxes = function (axes) {\n    this.axes = axes;\n  };\n\n  __proto.connect = function (observer) {\n    this.dettachEvent(); // add tabindex="0" to the container for making it focusable\n\n    if (this.element.getAttribute("tabindex") !== "0") {\n      this.element.setAttribute("tabindex", "0");\n    }\n\n    this.attachEvent(observer);\n    return this;\n  };\n\n  __proto.disconnect = function () {\n    this.dettachEvent();\n    return this;\n  };\n  /**\n  * Destroys elements, properties, and events used in a module.\n  * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n  * @method eg.Axes.MoveKeyInput#destroy\n  */\n\n\n  __proto.destroy = function () {\n    this.disconnect();\n    this.element = null;\n  };\n\n  __proto.onKeydown = function (e) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    var isMoveKey = true;\n    var direction = DIRECTION_FORWARD;\n    var move = DIRECTION_HORIZONTAL$1;\n\n    switch (e.keyCode) {\n      case KEY_LEFT_ARROW:\n      case KEY_A:\n        direction = DIRECTION_REVERSE;\n        break;\n\n      case KEY_RIGHT_ARROW:\n      case KEY_D:\n        break;\n\n      case KEY_DOWN_ARROW:\n      case KEY_S:\n        direction = DIRECTION_REVERSE;\n        move = DIRECTION_VERTICAL$1;\n        break;\n\n      case KEY_UP_ARROW:\n      case KEY_W:\n        move = DIRECTION_VERTICAL$1;\n        break;\n\n      default:\n        isMoveKey = false;\n    }\n\n    if (move === DIRECTION_HORIZONTAL$1 && !this.axes[0] || move === DIRECTION_VERTICAL$1 && !this.axes[1]) {\n      isMoveKey = false;\n    }\n\n    if (!isMoveKey) {\n      return;\n    }\n\n    var offsets = move === DIRECTION_HORIZONTAL$1 ? [+this.options.scale[0] * direction, 0] : [0, +this.options.scale[1] * direction];\n\n    if (!this._isHolded) {\n      this.observer.hold(this, event);\n      this._isHolded = true;\n    }\n\n    clearTimeout(this._timer);\n    this.observer.change(this, event, toAxis(this.axes, offsets));\n  };\n\n  __proto.onKeyup = function (e) {\n    var _this = this;\n\n    if (!this._isHolded) {\n      return;\n    }\n\n    clearTimeout(this._timer);\n    this._timer = setTimeout(function () {\n      _this.observer.release(_this, e, toAxis(_this.axes, [0, 0]));\n\n      _this._isHolded = false;\n    }, DELAY);\n  };\n\n  __proto.attachEvent = function (observer) {\n    this.observer = observer;\n    this.element.addEventListener("keydown", this.onKeydown, false);\n    this.element.addEventListener("keypress", this.onKeydown, false);\n    this.element.addEventListener("keyup", this.onKeyup, false);\n    this._isEnabled = true;\n  };\n\n  __proto.dettachEvent = function () {\n    this.element.removeEventListener("keydown", this.onKeydown, false);\n    this.element.removeEventListener("keypress", this.onKeydown, false);\n    this.element.removeEventListener("keyup", this.onKeyup, false);\n    this._isEnabled = false;\n    this.observer = null;\n  };\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.MoveKeyInput#enable\n   * @return {eg.Axes.MoveKeyInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.enable = function () {\n    this._isEnabled = true;\n    return this;\n  };\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.MoveKeyInput#disable\n   * @return {eg.Axes.MoveKeyInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.disable = function () {\n    this._isEnabled = false;\n    return this;\n  };\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.MoveKeyInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n\n\n  __proto.isEnable = function () {\n    return this._isEnabled;\n  };\n\n  return MoveKeyInput;\n}();\n\n/* harmony default export */ __webpack_exports__["default"] = (Axes);\n\n//# sourceMappingURL=axes.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvYXhlcy9kaXN0L2F4ZXMuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL2F4ZXMvZGlzdC9heGVzLmVzbS5qcz9jOGNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2F4ZXNcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtYXhlc1xudmVyc2lvbjogMi44LjBcbiovXG5pbXBvcnQgeyBESVJFQ1RJT05fTk9ORSwgRElSRUNUSU9OX0xFRlQsIERJUkVDVElPTl9SSUdIVCwgRElSRUNUSU9OX1VQLCBESVJFQ1RJT05fRE9XTiwgRElSRUNUSU9OX0hPUklaT05UQUwsIERJUkVDVElPTl9WRVJUSUNBTCwgRElSRUNUSU9OX0FMTCwgTWFuYWdlciwgUG9pbnRlckV2ZW50SW5wdXQsIFRvdWNoTW91c2VJbnB1dCwgVG91Y2hJbnB1dCwgTW91c2VJbnB1dCwgUGFuLCBQaW5jaCB9IGZyb20gJ0BlZ2pzL2hhbW1lcmpzJztcbmltcG9ydCBnZXRBZ2VudCBmcm9tICdAZWdqcy9hZ2VudCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BlZ2pzL2NvbXBvbmVudCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmZ1bmN0aW9uIGdldEluc2lkZVBvc2l0aW9uKGRlc3RQb3MsIHJhbmdlLCBjaXJjdWxhciwgYm91bmNlKSB7XG4gIHZhciB0b0Rlc3RQb3MgPSBkZXN0UG9zO1xuICB2YXIgdGFyZ2V0UmFuZ2UgPSBbY2lyY3VsYXJbMF0gPyByYW5nZVswXSA6IGJvdW5jZSA/IHJhbmdlWzBdIC0gYm91bmNlWzBdIDogcmFuZ2VbMF0sIGNpcmN1bGFyWzFdID8gcmFuZ2VbMV0gOiBib3VuY2UgPyByYW5nZVsxXSArIGJvdW5jZVsxXSA6IHJhbmdlWzFdXTtcbiAgdG9EZXN0UG9zID0gTWF0aC5tYXgodGFyZ2V0UmFuZ2VbMF0sIHRvRGVzdFBvcyk7XG4gIHRvRGVzdFBvcyA9IE1hdGgubWluKHRhcmdldFJhbmdlWzFdLCB0b0Rlc3RQb3MpO1xuICByZXR1cm4gdG9EZXN0UG9zO1xufSAvLyBkZXRlcm1pbmUgb3V0c2lkZVxuXG5mdW5jdGlvbiBpc091dHNpZGUocG9zLCByYW5nZSkge1xuICByZXR1cm4gcG9zIDwgcmFuZ2VbMF0gfHwgcG9zID4gcmFuZ2VbMV07XG59XG5mdW5jdGlvbiBnZXREdXJhdGlvbihkaXN0YW5jZSwgZGVjZWxlcmF0aW9uKSB7XG4gIHZhciBkdXJhdGlvbiA9IE1hdGguc3FydChkaXN0YW5jZSAvIGRlY2VsZXJhdGlvbiAqIDIpOyAvLyB3aGVuIGR1cmF0aW9uIGlzIHVuZGVyIDEwMCwgdGhlbiB2YWx1ZSBpcyB6ZXJvXG5cbiAgcmV0dXJuIGR1cmF0aW9uIDwgMTAwID8gMCA6IGR1cmF0aW9uO1xufVxuZnVuY3Rpb24gaXNDaXJjdWxhcmFibGUoZGVzdFBvcywgcmFuZ2UsIGNpcmN1bGFyKSB7XG4gIHJldHVybiBjaXJjdWxhclsxXSAmJiBkZXN0UG9zID4gcmFuZ2VbMV0gfHwgY2lyY3VsYXJbMF0gJiYgZGVzdFBvcyA8IHJhbmdlWzBdO1xufVxuZnVuY3Rpb24gZ2V0Q2lyY3VsYXRlZFBvcyhwb3MsIHJhbmdlLCBjaXJjdWxhcikge1xuICB2YXIgdG9Qb3MgPSBwb3M7XG4gIHZhciBtaW4gPSByYW5nZVswXTtcbiAgdmFyIG1heCA9IHJhbmdlWzFdO1xuICB2YXIgbGVuZ3RoID0gbWF4IC0gbWluO1xuXG4gIGlmIChjaXJjdWxhclsxXSAmJiBwb3MgPiBtYXgpIHtcbiAgICAvLyByaWdodFxuICAgIHRvUG9zID0gKHRvUG9zIC0gbWF4KSAlIGxlbmd0aCArIG1pbjtcbiAgfVxuXG4gIGlmIChjaXJjdWxhclswXSAmJiBwb3MgPCBtaW4pIHtcbiAgICAvLyBsZWZ0XG4gICAgdG9Qb3MgPSAodG9Qb3MgLSBtaW4pICUgbGVuZ3RoICsgbWF4O1xuICB9XG5cbiAgcmV0dXJuIHRvUG9zO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tbmVzdGVkLXRlcm5hcnkgKi9cbnZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIC8vIHdpbmRvdyBpcyB1bmRlZmluZWQgaW4gbm9kZS5qc1xuICB3aW4gPSB7XG4gICAgbmF2aWdhdG9yOiB7XG4gICAgICB1c2VyQWdlbnQ6IFwiXCJcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICB3aW4gPSB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkobm9kZXMpIHtcbiAgLy8gY29uc3QgZWwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2Rlcyk7XG4gIC8vIGZvciBJRThcbiAgdmFyIGVsID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZWwucHVzaChub2Rlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiAkKHBhcmFtLCBtdWx0aSkge1xuICBpZiAobXVsdGkgPT09IHZvaWQgMCkge1xuICAgIG11bHRpID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZWw7XG5cbiAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIFN0cmluZyAoSFRNTCwgU2VsZWN0b3IpXG4gICAgLy8gY2hlY2sgaWYgc3RyaW5nIGlzIEhUTUwgdGFnIGZvcm1hdFxuICAgIHZhciBtYXRjaCA9IHBhcmFtLm1hdGNoKC9ePChbYS16XSspXFxzKihbXj5dKik+Lyk7IC8vIGNyZWF0aW5nIGVsZW1lbnRcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgLy8gSFRNTFxuICAgICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGR1bW15LmlubmVySFRNTCA9IHBhcmFtO1xuICAgICAgZWwgPSB0b0FycmF5KGR1bW15LmNoaWxkTm9kZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWxlY3RvclxuICAgICAgZWwgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGFyYW0pKTtcbiAgICB9XG5cbiAgICBpZiAoIW11bHRpKSB7XG4gICAgICBlbCA9IGVsLmxlbmd0aCA+PSAxID8gZWxbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmFtID09PSB3aW4pIHtcbiAgICAvLyB3aW5kb3dcbiAgICBlbCA9IHBhcmFtO1xuICB9IGVsc2UgaWYgKHBhcmFtLm5vZGVOYW1lICYmIChwYXJhbS5ub2RlVHlwZSA9PT0gMSB8fCBwYXJhbS5ub2RlVHlwZSA9PT0gOSkpIHtcbiAgICAvLyBIVE1MRWxlbWVudCwgRG9jdW1lbnRcbiAgICBlbCA9IHBhcmFtO1xuICB9IGVsc2UgaWYgKFwialF1ZXJ5XCIgaW4gd2luICYmIHBhcmFtIGluc3RhbmNlb2YgalF1ZXJ5IHx8IHBhcmFtLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5qcXVlcnkpIHtcbiAgICAvLyBqUXVlcnlcbiAgICBlbCA9IG11bHRpID8gcGFyYW0udG9BcnJheSgpIDogcGFyYW0uZ2V0KDApO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgZWwgPSBwYXJhbS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAkKHYpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFtdWx0aSkge1xuICAgICAgZWwgPSBlbC5sZW5ndGggPj0gMSA/IGVsWzBdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cbnZhciByYWYgPSB3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbi53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgY2FmID0gd2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbi53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZTtcblxuaWYgKHJhZiAmJiAhY2FmKSB7XG4gIHZhciBrZXlJbmZvXzEgPSB7fTtcbiAgdmFyIG9sZHJhZl8xID0gcmFmO1xuXG4gIHJhZiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIHdyYXBDYWxsYmFjayh0aW1lc3RhbXApIHtcbiAgICAgIGlmIChrZXlJbmZvXzFba2V5XSkge1xuICAgICAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXkgPSBvbGRyYWZfMSh3cmFwQ2FsbGJhY2spO1xuICAgIGtleUluZm9fMVtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm4ga2V5O1xuICB9O1xuXG4gIGNhZiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUga2V5SW5mb18xW2tleV07XG4gIH07XG59IGVsc2UgaWYgKCEocmFmICYmIGNhZikpIHtcbiAgcmFmID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHdpbi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKHdpbi5wZXJmb3JtYW5jZSAmJiB3aW4ucGVyZm9ybWFuY2Uubm93ICYmIHdpbi5wZXJmb3JtYW5jZS5ub3coKSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgfSwgMTYpO1xuICB9O1xuXG4gIGNhZiA9IHdpbi5jbGVhclRpbWVvdXQ7XG59XG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIHRoZSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kLlxuICogQHNlZSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnApIHtcbiAgcmV0dXJuIHJhZihmcCk7XG59XG4vKipcbiogQSBwb2x5ZmlsbCBmb3IgdGhlIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSgpIG1ldGhvZC4gSXQgY2FuY2VscyBhbiBhbmltYXRpb24gZXhlY3V0ZWQgdGhyb3VnaCBhIGNhbGwgdG8gdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIG1ldGhvZC5cbiogQHBhcmFtIHtOdW1iZXJ9IGtleSDiiJJcdFRoZSBJRCB2YWx1ZSByZXR1cm5lZCB0aHJvdWdoIGEgY2FsbCB0byB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kLiA8a28+cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkg66mU7ISc65Oc6rCAIOuwmO2ZmO2VnCDslYTsnbTrlJQg6rCSPC9rbz5cbiogQHNlZSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZVxuKiBAcHJpdmF0ZVxuKi9cblxuZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoa2V5KSB7XG4gIGNhZihrZXkpO1xufVxuZnVuY3Rpb24gbWFwKG9iaiwgY2FsbGJhY2spIHtcbiAgdmFyIHRyYW5mb3JtZWQgPSB7fTtcblxuICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgIGsgJiYgKHRyYW5mb3JtZWRba10gPSBjYWxsYmFjayhvYmpba10sIGspKTtcbiAgfVxuXG4gIHJldHVybiB0cmFuZm9ybWVkO1xufVxuZnVuY3Rpb24gZmlsdGVyKG9iaiwgY2FsbGJhY2spIHtcbiAgdmFyIGZpbHRlcmVkID0ge307XG5cbiAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICBrICYmIGNhbGxiYWNrKG9ialtrXSwgaykgJiYgKGZpbHRlcmVkW2tdID0gb2JqW2tdKTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIGV2ZXJ5KG9iaiwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICBpZiAoayAmJiAhY2FsbGJhY2sob2JqW2tdLCBrKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXF1YWwodGFyZ2V0LCBiYXNlKSB7XG4gIHJldHVybiBldmVyeSh0YXJnZXQsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgcmV0dXJuIHYgPT09IGJhc2Vba107XG4gIH0pO1xufVxudmFyIHJvdW5kTnVtRnVuYyA9IHt9O1xuZnVuY3Rpb24gcm91bmROdW1iZXIobnVtLCByb3VuZFVuaXQpIHtcbiAgLy8gQ2FjaGUgZm9yIHBlcmZvcm1hbmNlXG4gIGlmICghcm91bmROdW1GdW5jW3JvdW5kVW5pdF0pIHtcbiAgICByb3VuZE51bUZ1bmNbcm91bmRVbml0XSA9IGdldFJvdW5kRnVuYyhyb3VuZFVuaXQpO1xuICB9XG5cbiAgcmV0dXJuIHJvdW5kTnVtRnVuY1tyb3VuZFVuaXRdKG51bSk7XG59XG5mdW5jdGlvbiByb3VuZE51bWJlcnMobnVtLCByb3VuZFVuaXQpIHtcbiAgaWYgKCFudW0gfHwgIXJvdW5kVW5pdCkge1xuICAgIHJldHVybiBudW07XG4gIH1cblxuICB2YXIgaXNOdW1iZXIgPSB0eXBlb2Ygcm91bmRVbml0ID09PSBcIm51bWJlclwiO1xuICByZXR1cm4gbWFwKG51bSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gcm91bmROdW1iZXIodmFsdWUsIGlzTnVtYmVyID8gcm91bmRVbml0IDogcm91bmRVbml0W2tleV0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldERlY2ltYWxQbGFjZSh2YWwpIHtcbiAgaWYgKCFpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgdiA9IHZhbCArIFwiXCI7XG5cbiAgaWYgKHYuaW5kZXhPZihcImVcIikgPj0gMCkge1xuICAgIC8vIEV4cG9uZW50aWFsIEZvcm1hdFxuICAgIC8vIDFlLTEwLCAxZS0xMlxuICAgIHZhciBwID0gMDtcbiAgICB2YXIgZSA9IDE7XG5cbiAgICB3aGlsZSAoTWF0aC5yb3VuZCh2YWwgKiBlKSAvIGUgIT09IHZhbCkge1xuICAgICAgZSAqPSAxMDtcbiAgICAgIHArKztcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSAvLyBJbiBnZW5lcmFsLCBmb2xsb3dpbmcgaGFzIHBlcmZvcm1hbmNlIGJlbmVmaXQuXG4gIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9wcmVjaXNpb24tY2FsY3VsYXRpb25cblxuXG4gIHJldHVybiB2LmluZGV4T2YoXCIuXCIpID49IDAgPyB2Lmxlbmd0aCAtIHYuaW5kZXhPZihcIi5cIikgLSAxIDogMDtcbn1cbmZ1bmN0aW9uIGludmVyc2VQb3cobikge1xuICAvLyByZXBsYWNlIE1hdGgucG93KDEwLCAtbikgdG8gc29sdmUgZmxvYXRpbmcgcG9pbnQgaXNzdWUuXG4gIC8vIGVnLiBNYXRoLnBvdygxMCwgLTQpID0+IDAuMDAwMDk5OTk5OTk5OTk5OTk5OTlcbiAgcmV0dXJuIDEgLyBNYXRoLnBvdygxMCwgbik7XG59XG5mdW5jdGlvbiBnZXRSb3VuZEZ1bmModikge1xuICB2YXIgcCA9IHYgPCAxID8gTWF0aC5wb3coMTAsIGdldERlY2ltYWxQbGFjZSh2KSkgOiAxO1xuICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAodiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yb3VuZChuIC8gdikgKiB2ICogcCkgLyBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtaW5NYXgodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbn1cblxudmFyIEFuaW1hdGlvbk1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb25NYW5hZ2VyKF9hKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zLFxuICAgICAgICBpdG0gPSBfYS5pdG0sXG4gICAgICAgIGVtID0gX2EuZW0sXG4gICAgICAgIGF4bSA9IF9hLmF4bTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaXRtID0gaXRtO1xuICAgIHRoaXMuZW0gPSBlbTtcbiAgICB0aGlzLmF4bSA9IGF4bTtcbiAgICB0aGlzLmFuaW1hdGlvbkVuZCA9IHRoaXMuYW5pbWF0aW9uRW5kLmJpbmQodGhpcyk7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEFuaW1hdGlvbk1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoZGVwYVBvcywgZGVzdFBvcywgd2lzaER1cmF0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkdXJhdGlvbjtcblxuICAgIGlmICh0eXBlb2Ygd2lzaER1cmF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkdXJhdGlvbiA9IHdpc2hEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGR1cmF0aW9uc18xID0gbWFwKGRlc3RQb3MsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHJldHVybiBnZXREdXJhdGlvbihNYXRoLmFicyh2IC0gZGVwYVBvc1trXSksIF90aGlzLm9wdGlvbnMuZGVjZWxlcmF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgZHVyYXRpb24gPSBPYmplY3Qua2V5cyhkdXJhdGlvbnNfMSkucmVkdWNlKGZ1bmN0aW9uIChtYXgsIHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1heCwgZHVyYXRpb25zXzFbdl0pO1xuICAgICAgfSwgLUluZmluaXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluTWF4KGR1cmF0aW9uLCB0aGlzLm9wdGlvbnMubWluaW11bUR1cmF0aW9uLCB0aGlzLm9wdGlvbnMubWF4aW11bUR1cmF0aW9uKTtcbiAgfTtcblxuICBfX3Byb3RvLmNyZWF0ZUFuaW1hdGlvblBhcmFtID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24sIG9wdGlvbikge1xuICAgIHZhciBkZXBhUG9zID0gdGhpcy5heG0uZ2V0KCk7XG4gICAgdmFyIGRlc3RQb3MgPSBwb3M7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBvcHRpb24gJiYgb3B0aW9uLmV2ZW50IHx8IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcGFQb3M6IGRlcGFQb3MsXG4gICAgICBkZXN0UG9zOiBkZXN0UG9zLFxuICAgICAgZHVyYXRpb246IG1pbk1heChkdXJhdGlvbiwgdGhpcy5vcHRpb25zLm1pbmltdW1EdXJhdGlvbiwgdGhpcy5vcHRpb25zLm1heGltdW1EdXJhdGlvbiksXG4gICAgICBkZWx0YTogdGhpcy5heG0uZ2V0RGVsdGEoZGVwYVBvcywgZGVzdFBvcyksXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxuICAgICAgaW5wdXQ6IG9wdGlvbiAmJiBvcHRpb24uaW5wdXQgfHwgbnVsbCxcbiAgICAgIGlzVHJ1c3RlZDogISFpbnB1dEV2ZW50LFxuICAgICAgZG9uZTogdGhpcy5hbmltYXRpb25FbmRcbiAgICB9O1xuICB9O1xuXG4gIF9fcHJvdG8uZ3JhYiA9IGZ1bmN0aW9uIChheGVzLCBvcHRpb24pIHtcbiAgICBpZiAodGhpcy5fYW5pbWF0ZVBhcmFtICYmIGF4ZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgb3JnUG9zXzEgPSB0aGlzLmF4bS5nZXQoYXhlcyk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5heG0ubWFwKG9yZ1Bvc18xLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICAgIHJldHVybiBnZXRDaXJjdWxhdGVkUG9zKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWV2ZXJ5KHBvcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgcmV0dXJuIG9yZ1Bvc18xW2tdID09PSB2O1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhpcy5lbS50cmlnZ2VyQ2hhbmdlKHBvcywgZmFsc2UsIG9yZ1Bvc18xLCBvcHRpb24sICEhb3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYW5pbWF0ZVBhcmFtID0gbnVsbDtcbiAgICAgIHRoaXMuX3JhZiAmJiBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yYWYpO1xuICAgICAgdGhpcy5fcmFmID0gbnVsbDtcbiAgICAgIHRoaXMuZW0udHJpZ2dlckFuaW1hdGlvbkVuZCghIShvcHRpb24gJiYgb3B0aW9uLmV2ZW50KSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RXZlbnRJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9hbmltYXRlUGFyYW0gJiYgdGhpcy5fYW5pbWF0ZVBhcmFtLmlucHV0ICYmIHRoaXMuX2FuaW1hdGVQYXJhbS5pbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dDogdGhpcy5fYW5pbWF0ZVBhcmFtLmlucHV0LFxuICAgICAgICBldmVudDogdGhpcy5fYW5pbWF0ZVBhcmFtLmlucHV0RXZlbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLnJlc3RvcmUgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMuYXhtLmdldCgpO1xuICAgIHZhciBkZXN0UG9zID0gdGhpcy5heG0ubWFwKHBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKG9wdC5yYW5nZVsxXSwgTWF0aC5tYXgob3B0LnJhbmdlWzBdLCB2KSk7XG4gICAgfSk7XG4gICAgdGhpcy5hbmltYXRlVG8oZGVzdFBvcywgdGhpcy5nZXREdXJhdGlvbihwb3MsIGRlc3RQb3MpLCBvcHRpb24pO1xuICB9O1xuXG4gIF9fcHJvdG8uYW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiZWZvcmVQYXJhbSA9IHRoaXMuZ2V0RXZlbnRJbmZvKCk7XG4gICAgdGhpcy5fYW5pbWF0ZVBhcmFtID0gbnVsbDsgLy8gZm9yIENpcmN1bGFyXG5cbiAgICB2YXIgY2lyY3VsYXJUYXJnZXRzID0gdGhpcy5heG0uZmlsdGVyKHRoaXMuYXhtLmdldCgpLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICByZXR1cm4gaXNDaXJjdWxhcmFibGUodiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIpO1xuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKGNpcmN1bGFyVGFyZ2V0cykubGVuZ3RoID4gMCAmJiB0aGlzLnNldFRvKHRoaXMuYXhtLm1hcChjaXJjdWxhclRhcmdldHMsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHJldHVybiBnZXRDaXJjdWxhdGVkUG9zKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKTtcbiAgICB9KSk7XG4gICAgdGhpcy5pdG0uc2V0SW50ZXJydXB0KGZhbHNlKTtcbiAgICB0aGlzLmVtLnRyaWdnZXJBbmltYXRpb25FbmQoISFiZWZvcmVQYXJhbSk7XG5cbiAgICBpZiAodGhpcy5heG0uaXNPdXRzaWRlKCkpIHtcbiAgICAgIHRoaXMucmVzdG9yZShiZWZvcmVQYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoKCEhYmVmb3JlUGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLmZpbmlzaCA9IGZ1bmN0aW9uIChpc1RydXN0ZWQpIHtcbiAgICB0aGlzLl9hbmltYXRlUGFyYW0gPSBudWxsO1xuICAgIHRoaXMuaXRtLnNldEludGVycnVwdChmYWxzZSk7XG4gICAgdGhpcy5lbS50cmlnZ2VyRmluaXNoKGlzVHJ1c3RlZCk7XG4gIH07XG5cbiAgX19wcm90by5hbmltYXRlTG9vcCA9IGZ1bmN0aW9uIChwYXJhbSwgY29tcGxldGUpIHtcbiAgICBpZiAocGFyYW0uZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuX2FuaW1hdGVQYXJhbSA9IF9fYXNzaWduKHt9LCBwYXJhbSk7XG4gICAgICB2YXIgaW5mb18xID0gdGhpcy5fYW5pbWF0ZVBhcmFtO1xuICAgICAgdmFyIHNlbGZfMSA9IHRoaXM7XG4gICAgICB2YXIgZGVzdFBvc18xID0gaW5mb18xLmRlc3RQb3M7XG4gICAgICB2YXIgcHJldlBvc18xID0gaW5mb18xLmRlcGFQb3M7XG4gICAgICB2YXIgcHJldkVhc2luZ1Blcl8xID0gMDtcbiAgICAgIHZhciBkaXJlY3Rpb25zXzEgPSBtYXAocHJldlBvc18xLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gZGVzdFBvc18xW2tleV0gPyAxIDogLTE7XG4gICAgICB9KTtcbiAgICAgIHZhciBvcmlnaW5hbEludGVuZGVkUG9zXzEgPSBtYXAoZGVzdFBvc18xLCBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0pO1xuICAgICAgdmFyIHByZXZUaW1lXzEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGluZm9fMS5zdGFydFRpbWUgPSBwcmV2VGltZV8xO1xuXG4gICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgc2VsZl8xLl9yYWYgPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIHJhdGlvID0gKGN1cnJlbnRUaW1lIC0gaW5mb18xLnN0YXJ0VGltZSkgLyBwYXJhbS5kdXJhdGlvbjtcbiAgICAgICAgdmFyIGVhc2luZ1BlciA9IHNlbGZfMS5lYXNpbmcocmF0aW8pO1xuICAgICAgICB2YXIgdG9Qb3MgPSBzZWxmXzEuYXhtLm1hcChwcmV2UG9zXzEsIGZ1bmN0aW9uIChwb3MsIG9wdGlvbnMsIGtleSkge1xuICAgICAgICAgIHZhciBuZXh0UG9zID0gcmF0aW8gPj0gMSA/IGRlc3RQb3NfMVtrZXldIDogcG9zICsgaW5mb18xLmRlbHRhW2tleV0gKiAoZWFzaW5nUGVyIC0gcHJldkVhc2luZ1Blcl8xKTsgLy8gU3VidHJhY3QgZGlzdGFuY2UgZnJvbSBkaXN0YW5jZSBhbHJlYWR5IG1vdmVkLlxuICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSByZW1haW5pbmcgZGlzdGFuY2UuXG4gICAgICAgICAgLy8gRml4IHRoZSBib3VuY2luZyBwaGVub21lbm9uIGJ5IGNoYW5naW5nIHRoZSByYW5nZS5cblxuICAgICAgICAgIHZhciBjaXJjdWxhdGVkUG9zID0gZ2V0Q2lyY3VsYXRlZFBvcyhuZXh0UG9zLCBvcHRpb25zLnJhbmdlLCBvcHRpb25zLmNpcmN1bGFyKTtcblxuICAgICAgICAgIGlmIChuZXh0UG9zICE9PSBjaXJjdWxhdGVkUG9zKSB7XG4gICAgICAgICAgICAvLyBjaXJjdWxhclxuICAgICAgICAgICAgdmFyIHJhbmdlT2Zmc2V0ID0gZGlyZWN0aW9uc18xW2tleV0gKiAob3B0aW9ucy5yYW5nZVsxXSAtIG9wdGlvbnMucmFuZ2VbMF0pO1xuICAgICAgICAgICAgZGVzdFBvc18xW2tleV0gLT0gcmFuZ2VPZmZzZXQ7XG4gICAgICAgICAgICBwcmV2UG9zXzFba2V5XSAtPSByYW5nZU9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2lyY3VsYXRlZFBvcztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc0NhbmNlbGVkID0gIXNlbGZfMS5lbS50cmlnZ2VyQ2hhbmdlKHRvUG9zLCBmYWxzZSwgcHJldlBvc18xKTtcbiAgICAgICAgcHJldlBvc18xID0gdG9Qb3M7XG4gICAgICAgIHByZXZUaW1lXzEgPSBjdXJyZW50VGltZTtcbiAgICAgICAgcHJldkVhc2luZ1Blcl8xID0gZWFzaW5nUGVyO1xuXG4gICAgICAgIGlmIChlYXNpbmdQZXIgPj0gMSkge1xuICAgICAgICAgIGRlc3RQb3NfMSA9IHNlbGZfMS5nZXRGaW5hbFBvcyhkZXN0UG9zXzEsIG9yaWdpbmFsSW50ZW5kZWRQb3NfMSk7XG5cbiAgICAgICAgICBpZiAoIWVxdWFsKGRlc3RQb3NfMSwgc2VsZl8xLmF4bS5nZXQoT2JqZWN0LmtleXMoZGVzdFBvc18xKSkpKSB7XG4gICAgICAgICAgICBzZWxmXzEuZW0udHJpZ2dlckNoYW5nZShkZXN0UG9zXzEsIHRydWUsIHByZXZQb3NfMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDYW5jZWxlZCkge1xuICAgICAgICAgIHNlbGZfMS5maW5pc2goZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFuaW1hdGlvbkVuZFxuICAgICAgICAgIHNlbGZfMS5fcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtLnRyaWdnZXJDaGFuZ2UocGFyYW0uZGVzdFBvcywgdHJ1ZSk7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEdldCBlc3RpbWF0ZWQgZmluYWwgdmFsdWUuXG4gICAqXG4gICAqIElmIGRlc3RQb3MgaXMgd2l0aGluIHRoZSAnZXJyb3IgcmFuZ2UnIG9mIHRoZSBvcmlnaW5hbCBpbnRlbmRlZCBwb3NpdGlvbiwgdGhlIGluaXRpYWwgaW50ZW5kZWQgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAqICAgLSBlZy4gb3JpZ2luYWwgaW50ZW5kZWQgcG9zOiAxMDAsIGRlc3RQb3M6IDEwMC4wMDAwMDAwMDA0ID09PiByZXR1cm4gMTAwO1xuICAgKiBJZiBkZXN0IFBvcyBpcyBvdXRzaWRlIHRoZSAncmFuZ2Ugb2YgZXJyb3InIGNvbXBhcmVkIHRvIHRoZSBvcmlnaW5hbGx5IGludGVuZGVkIHBvcywgaXQgaXMgcmV0dXJuZWQgcm91bmRlZCBiYXNlZCBvbiB0aGUgb3JpZ2luYWxseSBpbnRlbmRlZCBwb3MuXG4gICAqICAgLSBlZy4gb3JpZ2luYWwgaW50ZW5kZWQgcG9zOiAxMDAuMTIzIGRlc3RQb3M6IDUwLjEyMzQ1ID0+IHJldHVybiA1MC4xMjNcbiAgICpcbiAgICogQHBhcmFtIG9yaWdpbmFsSW50ZW5kZWRQb3NcbiAgICogQHBhcmFtIGRlc3RQb3NcbiAgICovXG5cblxuICBfX3Byb3RvLmdldEZpbmFsUG9zID0gZnVuY3Rpb24gKGRlc3RQb3MsIG9yaWdpbmFsSW50ZW5kZWRQb3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBjb21wYXJlIGRlc3RQb3MgYW5kIG9yaWdpbmFsSW50ZW5kZWRQb3NcblxuXG4gICAgdmFyIEVSUk9SX0xJTUlUID0gMC4wMDAwMDE7XG4gICAgdmFyIGZpbmFsUG9zID0gbWFwKGRlc3RQb3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgPj0gb3JpZ2luYWxJbnRlbmRlZFBvc1trZXldIC0gRVJST1JfTElNSVQgJiYgdmFsdWUgPD0gb3JpZ2luYWxJbnRlbmRlZFBvc1trZXldICsgRVJST1JfTElNSVQpIHtcbiAgICAgICAgLy8gSW4gZXJyb3IgcmFuZ2UsIHJldHVybiBvcmlnaW5hbCBpbnRlbmRlZFxuICAgICAgICByZXR1cm4gb3JpZ2luYWxJbnRlbmRlZFBvc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3V0IG9mIGVycm9yIHJhbmdlLCByZXR1cm4gcm91bmRlZCBwb3MuXG4gICAgICAgIHZhciByb3VuZFVuaXQgPSBfdGhpcy5nZXRSb3VuZFVuaXQodmFsdWUsIGtleSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHJvdW5kTnVtYmVyKHZhbHVlLCByb3VuZFVuaXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaW5hbFBvcztcbiAgfTtcblxuICBfX3Byb3RvLmdldFJvdW5kVW5pdCA9IGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgIHZhciByb3VuZFVuaXQgPSB0aGlzLm9wdGlvbnMucm91bmQ7IC8vIG1hbnVhbCBtb2RlXG5cbiAgICB2YXIgbWluUm91bmRVbml0ID0gbnVsbDsgLy8gYXV0byBtb2RlXG4gICAgLy8gYXV0byBtb2RlXG5cbiAgICBpZiAoIXJvdW5kVW5pdCkge1xuICAgICAgLy8gR2V0IG1pbmltdW0gcm91bmQgdW5pdFxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmF4bS5nZXRBeGlzT3B0aW9ucyhrZXkpO1xuICAgICAgbWluUm91bmRVbml0ID0gaW52ZXJzZVBvdyhNYXRoLm1heChnZXREZWNpbWFsUGxhY2Uob3B0aW9ucy5yYW5nZVswXSksIGdldERlY2ltYWxQbGFjZShvcHRpb25zLnJhbmdlWzFdKSwgZ2V0RGVjaW1hbFBsYWNlKHZhbCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluUm91bmRVbml0IHx8IHJvdW5kVW5pdDtcbiAgfTtcblxuICBfX3Byb3RvLmdldFVzZXJDb250cm9sbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciB1c2VyV2lzaCA9IHBhcmFtLnNldFRvKCk7XG4gICAgdXNlcldpc2guZGVzdFBvcyA9IHRoaXMuYXhtLmdldCh1c2VyV2lzaC5kZXN0UG9zKTtcbiAgICB1c2VyV2lzaC5kdXJhdGlvbiA9IG1pbk1heCh1c2VyV2lzaC5kdXJhdGlvbiwgdGhpcy5vcHRpb25zLm1pbmltdW1EdXJhdGlvbiwgdGhpcy5vcHRpb25zLm1heGltdW1EdXJhdGlvbik7XG4gICAgcmV0dXJuIHVzZXJXaXNoO1xuICB9O1xuXG4gIF9fcHJvdG8uYW5pbWF0ZVRvID0gZnVuY3Rpb24gKGRlc3RQb3MsIGR1cmF0aW9uLCBvcHRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHBhcmFtID0gdGhpcy5jcmVhdGVBbmltYXRpb25QYXJhbShkZXN0UG9zLCBkdXJhdGlvbiwgb3B0aW9uKTtcblxuICAgIHZhciBkZXBhUG9zID0gX19hc3NpZ24oe30sIHBhcmFtLmRlcGFQb3MpO1xuXG4gICAgdmFyIHJldFRyaWdnZXIgPSB0aGlzLmVtLnRyaWdnZXJBbmltYXRpb25TdGFydChwYXJhbSk7IC8vIHRvIGNvbnRyb2xcblxuICAgIHZhciB1c2VyV2lzaCA9IHRoaXMuZ2V0VXNlckNvbnRyb2xsKHBhcmFtKTsgLy8gWW91IGNhbid0IHN0b3AgdGhlICdhbmltYXRpb25TdGFydCcgZXZlbnQgd2hlbiAnY2lyY3VsYXInIGlzIHRydWUuXG5cbiAgICBpZiAoIXJldFRyaWdnZXIgJiYgdGhpcy5heG0uZXZlcnkodXNlcldpc2guZGVzdFBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuIGlzQ2lyY3VsYXJhYmxlKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKTtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiWW91IGNhbid0IHN0b3AgdGhlICdhbmltYXRpb24nIGV2ZW50IHdoZW4gJ2NpcmN1bGFyJyBpcyB0cnVlLlwiKTtcbiAgICB9XG5cbiAgICBpZiAocmV0VHJpZ2dlciAmJiAhZXF1YWwodXNlcldpc2guZGVzdFBvcywgZGVwYVBvcykpIHtcbiAgICAgIHZhciBpbnB1dEV2ZW50ID0gb3B0aW9uICYmIG9wdGlvbi5ldmVudCB8fCBudWxsO1xuICAgICAgdGhpcy5hbmltYXRlTG9vcCh7XG4gICAgICAgIGRlcGFQb3M6IGRlcGFQb3MsXG4gICAgICAgIGRlc3RQb3M6IHVzZXJXaXNoLmRlc3RQb3MsXG4gICAgICAgIGR1cmF0aW9uOiB1c2VyV2lzaC5kdXJhdGlvbixcbiAgICAgICAgZGVsdGE6IHRoaXMuYXhtLmdldERlbHRhKGRlcGFQb3MsIHVzZXJXaXNoLmRlc3RQb3MpLFxuICAgICAgICBpc1RydXN0ZWQ6ICEhaW5wdXRFdmVudCxcbiAgICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgICAgaW5wdXQ6IG9wdGlvbiAmJiBvcHRpb24uaW5wdXQgfHwgbnVsbFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuYW5pbWF0aW9uRW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5lYXNpbmcgPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwID4gMSA/IDEgOiB0aGlzLm9wdGlvbnMuZWFzaW5nKHApO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0VG8gPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGF4ZXMgPSBPYmplY3Qua2V5cyhwb3MpO1xuICAgIHRoaXMuZ3JhYihheGVzKTtcbiAgICB2YXIgb3JnUG9zID0gdGhpcy5heG0uZ2V0KGF4ZXMpO1xuXG4gICAgaWYgKGVxdWFsKHBvcywgb3JnUG9zKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5pdG0uc2V0SW50ZXJydXB0KHRydWUpO1xuICAgIHZhciBtb3ZlZFBvcyA9IGZpbHRlcihwb3MsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICByZXR1cm4gb3JnUG9zW2tdICE9PSB2O1xuICAgIH0pO1xuXG4gICAgaWYgKCFPYmplY3Qua2V5cyhtb3ZlZFBvcykubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtb3ZlZFBvcyA9IHRoaXMuYXhtLm1hcChtb3ZlZFBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgdmFyIHJhbmdlID0gb3B0LnJhbmdlLFxuICAgICAgICAgIGNpcmN1bGFyID0gb3B0LmNpcmN1bGFyO1xuXG4gICAgICBpZiAoY2lyY3VsYXIgJiYgKGNpcmN1bGFyWzBdIHx8IGNpcmN1bGFyWzFdKSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRJbnNpZGVQb3NpdGlvbih2LCByYW5nZSwgY2lyY3VsYXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVxdWFsKG1vdmVkUG9zLCBvcmdQb3MpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGVUbyhtb3ZlZFBvcywgZHVyYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtLnRyaWdnZXJDaGFuZ2UobW92ZWRQb3MpO1xuICAgICAgdGhpcy5maW5pc2goZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0QnkgPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0VG8obWFwKHRoaXMuYXhtLmdldChPYmplY3Qua2V5cyhwb3MpKSwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJldHVybiB2ICsgcG9zW2tdO1xuICAgIH0pLCBkdXJhdGlvbik7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGlvbk1hbmFnZXI7XG59KCk7XG5cbnZhciBFdmVudE1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudE1hbmFnZXIoYXhlcykge1xuICAgIHRoaXMuYXhlcyA9IGF4ZXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHVzZXIgaG9sZHMgYW4gZWxlbWVudCBvbiB0aGUgc2NyZWVuIG9mIHRoZSBkZXZpY2UuXG4gICAqIEBrbyDsgqzsmqnsnpDqsIAg6riw6riw7J2YIO2ZlOuptOyXkCDshpDsnYQg64yA6rOgIOyeiOydhCDrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuICAgKiBAbmFtZSBlZy5BeGVzI2hvbGRcbiAgICogQGV2ZW50XG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBjb29yZGluYXRlIDxrbz7sooztkZwg7KCV67O0PC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0IFRoZSBpbnN0YW5jZSBvZiBpbnB1dFR5cGUgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkPGtvPuydtOuypO2KuOqwgCDrsJzsg53tlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dEV2ZW50IFRoZSBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSBpbnB1dFR5cGUgPGtvPmlucHV0VHlwZeycvOuhnCDrtoDthLAg67Cb7J2AIOydtOuypO2KuCDqsJ3ssrQ8L2tvPlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzVHJ1c3RlZCBSZXR1cm5zIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGwgPGtvPuyCrOyaqeyekOydmCDslaHshZjsl5Ag7J2Y7ZW0IOydtOuypO2KuOqwgCDrsJzsg53tlZjsmIDsnLzrqbQgdHJ1ZSwg7Iqk7YGs66a97Yq464KYIEFQSe2YuOy2nOyXkCDsnZjtlbQg67Cc7IOd7ZWY7JiA7J2EIOqyveyasOyXkOuKlCBmYWxzZeulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiaG9sZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LnBvc1xuICAgKiAgIC8vIGV2ZW50LmlucHV0XG4gICAqICAgLy8gZXZlbnQuaW5wdXRFdmVudFxuICAgKiAgIC8vIGlzVHJ1c3RlZFxuICAgKiB9KTtcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEV2ZW50TWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by50cmlnZ2VySG9sZCA9IGZ1bmN0aW9uIChwb3MsIG9wdGlvbikge1xuICAgIHZhciByb3VuZFBvcyA9IHRoaXMuZ2V0Um91bmRQb3MocG9zKS5yb3VuZFBvcztcbiAgICB0aGlzLmF4ZXMudHJpZ2dlcihcImhvbGRcIiwge1xuICAgICAgcG9zOiByb3VuZFBvcyxcbiAgICAgIGlucHV0OiBvcHRpb24uaW5wdXQgfHwgbnVsbCxcbiAgICAgIGlucHV0RXZlbnQ6IG9wdGlvbi5ldmVudCB8fCBudWxsLFxuICAgICAgaXNUcnVzdGVkOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlICdjaGFuZ2UnIGV2ZW50LiBJdCB3b3JrcyB3aGVuIHRoZSBob2xkaW5nIHZhbHVlIG9mIHRoZSBjaGFuZ2UgZXZlbnQgaXMgdHJ1ZS5cbiAgICogQGtvICdjaGFuZ2UnIOydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyijO2RnOulvCDsp4DsoJXtlZzri6QuIGNoYW5nZeydtOuypO2KuOydmCBob2xkaW5nIOqwkuydtCB0cnVl7J28IOqyveyasOyXkCDrj5nsnpHtlZzri6RcbiAgICogQG5hbWUgc2V0XG4gICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgZXZlbnQuaG9sZGluZyAmJiBldmVudC5zZXQoe3g6IDEwfSk7XG4gICAqIH0pO1xuICAgKi9cblxuICAvKiogU3BlY2lmaWVzIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgJ3JlbGVhc2UnIG9yICdhbmltYXRpb25TdGFydCcgZXZlbnRzLlxuICAgKiBAa28gJ3JlbGVhc2UnIOuYkOuKlCAnYW5pbWF0aW9uU3RhcnQnIOydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyijO2RnOulvCDsp4DsoJXtlZzri6QuXG4gICAqIEBuYW1lIHNldFRvXG4gICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpIDxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCjri6jsnIQ6IG1zKTwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgZXZlbnQuc2V0VG8oe3g6IDEwfSwgMjAwMCk7XG4gICAqIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgdXNlciByZWxlYXNlIGFuIGVsZW1lbnQgb24gdGhlIHNjcmVlbiBvZiB0aGUgZGV2aWNlLlxuICAgKiBAa28g7IKs7Jqp7J6Q6rCAIOq4sOq4sOydmCDtmZTrqbTsl5DshJwg7IaQ7J2EIOuXkOydhCDrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuICAgKiBAbmFtZSBlZy5BeGVzI3JlbGVhc2VcbiAgICogQGV2ZW50XG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlcGFQb3MgVGhlIGNvb3JkaW5hdGVzIHdoZW4gcmVsZWFzaW5nIGFuIGVsZW1lbnQ8a28+7IaQ7J2EIOuXkOydhCDrlYzsnZgg7KKM7ZGcIDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlc3RQb3MgVGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgdG8gYWZ0ZXIgcmVsZWFzaW5nIGFuIGVsZW1lbnQ8a28+7IaQ7J2EIOuXgCDrkqTsl5Ag7J2064+Z7ZWgIOyijO2RnDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbHRhICBUaGUgbW92ZW1lbnQgdmFyaWF0aW9uIG9mIGNvb3JkaW5hdGUgPGtvPuyijO2RnOydmCDrs4DtmZTrn4k8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXRFdmVudCBUaGUgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gaW5wdXRUeXBlIDxrbz5pbnB1dFR5cGXsnLzroZwg67aA7YSwIOuwm+ydgCDsnbTrsqTtirgg6rCd7LK0PC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0IFRoZSBpbnN0YW5jZSBvZiBpbnB1dFR5cGUgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkPGtvPuydtOuypO2KuOqwgCDrsJzsg53tlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7c2V0VG99IHNldFRvIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlIGV2ZW50IDxrbz7snbTrsqTtirgg7J207ZuEIOydtOuPme2VoCDslaDri4jrqZTsnbTshZgg7KKM7ZGc66W8IOyngOygle2VnOuLpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJyZWxlYXNlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgLy8gZXZlbnQuZGVwYVBvc1xuICAgKiAgIC8vIGV2ZW50LmRlc3RQb3NcbiAgICogICAvLyBldmVudC5kZWx0YVxuICAgKiAgIC8vIGV2ZW50LmlucHV0XG4gICAqICAgLy8gZXZlbnQuaW5wdXRFdmVudFxuICAgKiAgIC8vIGV2ZW50LnNldFRvXG4gICAqICAgLy8gZXZlbnQuaXNUcnVzdGVkXG4gICAqXG4gICAqICAgLy8gaWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgJ3JlbGVhc2UnIGV2ZW50LlxuICAgKiAgIGV2ZW50LnNldFRvKHt4OiAxMH0sIDIwMDApO1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIF9hID0gdGhpcy5nZXRSb3VuZFBvcyhwYXJhbS5kZXN0UG9zLCBwYXJhbS5kZXBhUG9zKSxcbiAgICAgICAgcm91bmRQb3MgPSBfYS5yb3VuZFBvcyxcbiAgICAgICAgcm91bmREZXBhID0gX2Eucm91bmREZXBhO1xuXG4gICAgcGFyYW0uZGVzdFBvcyA9IHJvdW5kUG9zO1xuICAgIHBhcmFtLmRlcGFQb3MgPSByb3VuZERlcGE7XG4gICAgcGFyYW0uc2V0VG8gPSB0aGlzLmNyZWF0ZVVzZXJDb250cm9sbChwYXJhbS5kZXN0UG9zLCBwYXJhbS5kdXJhdGlvbik7XG4gICAgdGhpcy5heGVzLnRyaWdnZXIoXCJyZWxlYXNlXCIsIHBhcmFtKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBjb29yZGluYXRlIGNoYW5nZXMuXG4gICAqIEBrbyDsooztkZzqsIAg67OA6rK965CQ7J2EIOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG4gICAqIEBuYW1lIGVnLkF4ZXMjY2hhbmdlXG4gICAqIEBldmVudFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBwb3MgIFRoZSBjb29yZGluYXRlIDxrbz7sooztkZw8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZWx0YSAgVGhlIG1vdmVtZW50IHZhcmlhdGlvbiBvZiBjb29yZGluYXRlIDxrbz7sooztkZzsnZgg67OA7ZmU65+JPC9rbz5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBob2xkaW5nIEluZGljYXRlcyB3aGV0aGVyIGEgdXNlciBob2xkcyBhbiBlbGVtZW50IG9uIHRoZSBzY3JlZW4gb2YgdGhlIGRldmljZS48a28+7IKs7Jqp7J6Q6rCAIOq4sOq4sOydmCDtmZTrqbTsnYQg64iE66W06rOgIOyeiOuKlOyngCDsl6zrtoA8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXQgVGhlIGluc3RhbmNlIG9mIGlucHV0VHlwZSB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQuIElmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIGJ5IGFuaW1hdGlvbiwgaXQgcmV0dXJucyAnbnVsbCcuPGtvPuydtOuypO2KuOqwgCDrsJzsg53tlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpC4g7JWg64uI66mU7J207IWY7JeQIOydmO2VtCDqsJLsnbQg67OA6rK965CgIOqyveyasOyXkOuKlCAnbnVsbCfsnYQg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dEV2ZW50IFRoZSBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSBpbnB1dFR5cGUuIElmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIGJ5IGFuaW1hdGlvbiwgaXQgcmV0dXJucyAnbnVsbCcuPGtvPmlucHV0VHlwZeycvOuhnCDrtoDthLAg67Cb7J2AIOydtOuypO2KuCDqsJ3ssrQuIOyVoOuLiOuplOydtOyFmOyXkCDsnZjtlbQg6rCS7J20IOuzgOqyveuQoCDqsr3smrDsl5DripQgJ251bGwn7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKiBAcHJvcGVydHkge3NldH0gc2V0IFNwZWNpZmllcyB0aGUgY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgZXZlbnQuIEl0IHdvcmtzIHdoZW4gdGhlIGhvbGRpbmcgdmFsdWUgaXMgdHJ1ZSA8a28+7J2067Kk7Yq4IOydtO2bhCDsnbTrj5ntlaAg7KKM7ZGc66W8IOyngOygle2VnOuLpC4gaG9sZGluZyDqsJLsnbQgdHJ1ZeydvCDqsr3smrDsl5Ag64+Z7J6R7ZWc64ukLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5wb3NcbiAgICogICAvLyBldmVudC5kZWx0YVxuICAgKiAgIC8vIGV2ZW50LmlucHV0XG4gICAqICAgLy8gZXZlbnQuaW5wdXRFdmVudFxuICAgKiAgIC8vIGV2ZW50LmhvbGRpbmdcbiAgICogICAvLyBldmVudC5zZXRcbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICpcbiAgICogICAvLyBpZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlICdjaGFuZ2UnIGV2ZW50LlxuICAgKiAgIC8vIGl0IHdvcmtzIHdoZW4gdGhlIGhvbGRpbmcgdmFsdWUgb2YgdGhlIGNoYW5nZSBldmVudCBpcyB0cnVlLlxuICAgKiAgIGV2ZW50LmhvbGRpbmcgJiYgZXZlbnQuc2V0KHt4OiAxMH0pO1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJDaGFuZ2UgPSBmdW5jdGlvbiAocG9zLCBpc0FjY3VyYXRlLCBkZXBhUG9zLCBvcHRpb24sIGhvbGRpbmcpIHtcbiAgICBpZiAoaG9sZGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBob2xkaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFtID0gdGhpcy5hbTtcbiAgICB2YXIgYXhtID0gYW0uYXhtO1xuICAgIHZhciBldmVudEluZm8gPSBhbS5nZXRFdmVudEluZm8oKTtcblxuICAgIHZhciBfYSA9IHRoaXMuZ2V0Um91bmRQb3MocG9zLCBkZXBhUG9zKSxcbiAgICAgICAgcm91bmRQb3MgPSBfYS5yb3VuZFBvcyxcbiAgICAgICAgcm91bmREZXBhID0gX2Eucm91bmREZXBhO1xuXG4gICAgdmFyIG1vdmVUbyA9IGF4bS5tb3ZlVG8ocm91bmRQb3MsIHJvdW5kRGVwYSk7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBvcHRpb24gJiYgb3B0aW9uLmV2ZW50IHx8IGV2ZW50SW5mbyAmJiBldmVudEluZm8uZXZlbnQgfHwgbnVsbDtcbiAgICB2YXIgcGFyYW0gPSB7XG4gICAgICBwb3M6IG1vdmVUby5wb3MsXG4gICAgICBkZWx0YTogbW92ZVRvLmRlbHRhLFxuICAgICAgaG9sZGluZzogaG9sZGluZyxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICBpc1RydXN0ZWQ6ICEhaW5wdXRFdmVudCxcbiAgICAgIGlucHV0OiBvcHRpb24gJiYgb3B0aW9uLmlucHV0IHx8IGV2ZW50SW5mbyAmJiBldmVudEluZm8uaW5wdXQgfHwgbnVsbCxcbiAgICAgIHNldDogaW5wdXRFdmVudCA/IHRoaXMuY3JlYXRlVXNlckNvbnRyb2xsKG1vdmVUby5wb3MpIDogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmF4ZXMudHJpZ2dlcihcImNoYW5nZVwiLCBwYXJhbSk7XG4gICAgaW5wdXRFdmVudCAmJiBheG0uc2V0KHBhcmFtLnNldCgpW1wiZGVzdFBvc1wiXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbmltYXRpb24gc3RhcnRzLlxuICAgKiBAa28g7JeQ64uI66mU7J207IWY7J20IOyLnOyeke2VoCDrlYwg67Cc7IOd7ZWc64ukLlxuICAgKiBAbmFtZSBlZy5BeGVzI2FuaW1hdGlvblN0YXJ0XG4gICAqIEBldmVudFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZXBhUG9zIFRoZSBjb29yZGluYXRlcyB3aGVuIGFuaW1hdGlvbiBzdGFydHM8a28+7JWg64uI66mU7J207IWY7J20IOyLnOyekSDrkJjsl4jsnYQg65WM7J2YIOyijO2RnCA8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZXN0UG9zIFRoZSBjb29yZGluYXRlcyB0byBtb3ZlIHRvLiBJZiB5b3UgY2hhbmdlIHRoaXMgdmFsdWUsIHlvdSBjYW4gcnVuIHRoZSBhbmltYXRpb248a28+7J2064+Z7ZWgIOyijO2RnC4g7J206rCS7J2EIOuzgOqyve2VmOyXrCDslaDri4jrqZTsnbTshZjsnYQg64+Z7J6R7Iuc7YKs7IiYIOyeiOuLpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbHRhICBUaGUgbW92ZW1lbnQgdmFyaWF0aW9uIG9mIGNvb3JkaW5hdGUgPGtvPuyijO2RnOydmCDrs4DtmZTrn4k8L2tvPlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpLiBJZiB5b3UgY2hhbmdlIHRoaXMgdmFsdWUsIHlvdSBjYW4gY29udHJvbCB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIHRpbWUuPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEKOuLqOychDogbXMpLiDsnbTqsJLsnYQg67OA6rK97ZWY7JesIOyVoOuLiOuplOydtOyFmOydmCDsnbTrj5nsi5zqsITsnYQg7KGw7KCI7ZWgIOyImCDsnojri6QuPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0IFRoZSBpbnN0YW5jZSBvZiBpbnB1dFR5cGUgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkLiBJZiB0aGUgdmFsdWUgaXMgY2hhbmdlZCBieSBhbmltYXRpb24sIGl0IHJldHVybnMgJ251bGwnLjxrbz7snbTrsqTtirjqsIAg67Cc7IOd7ZWcIGlucHV0VHlwZSDsnbjsiqTthLTsiqQuIOyVoOuLiOuplOydtOyFmOyXkCDsnZjtlbQg6rCS7J20IOuzgOqyveuQoCDqsr3smrDsl5DripQgJ251bGwn7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXRFdmVudCBUaGUgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gaW5wdXRUeXBlIDxrbz5pbnB1dFR5cGXsnLzroZwg67aA7YSwIOuwm+ydgCDsnbTrsqTtirgg6rCd7LK0PC9rbz5cbiAgICogQHByb3BlcnR5IHtzZXRUb30gc2V0VG8gU3BlY2lmaWVzIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgZXZlbnQgPGtvPuydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyVoOuLiOuplOydtOyFmCDsooztkZzrpbwg7KeA7KCV7ZWc64ukPC9rbz5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcInJlbGVhc2VcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5kZXBhUG9zXG4gICAqICAgLy8gZXZlbnQuZGVzdFBvc1xuICAgKiAgIC8vIGV2ZW50LmRlbHRhXG4gICAqICAgLy8gZXZlbnQuaW5wdXRcbiAgICogICAvLyBldmVudC5pbnB1dEV2ZW50XG4gICAqICAgLy8gZXZlbnQuc2V0VG9cbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICpcbiAgICogICAvLyBpZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGFuaW1hdGlvbiBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSAnYW5pbWF0aW9uU3RhcnQnIGV2ZW50LlxuICAgKiAgIGV2ZW50LnNldFRvKHt4OiAxMH0sIDIwMDApO1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJBbmltYXRpb25TdGFydCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBfYSA9IHRoaXMuZ2V0Um91bmRQb3MocGFyYW0uZGVzdFBvcywgcGFyYW0uZGVwYVBvcyksXG4gICAgICAgIHJvdW5kUG9zID0gX2Eucm91bmRQb3MsXG4gICAgICAgIHJvdW5kRGVwYSA9IF9hLnJvdW5kRGVwYTtcblxuICAgIHBhcmFtLmRlc3RQb3MgPSByb3VuZFBvcztcbiAgICBwYXJhbS5kZXBhUG9zID0gcm91bmREZXBhO1xuICAgIHBhcmFtLnNldFRvID0gdGhpcy5jcmVhdGVVc2VyQ29udHJvbGwocGFyYW0uZGVzdFBvcywgcGFyYW0uZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLmF4ZXMudHJpZ2dlcihcImFuaW1hdGlvblN0YXJ0XCIsIHBhcmFtKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbmltYXRpb24gZW5kcy5cbiAgICogQGtvIOyXkOuLiOuplOydtOyFmOydtCDrgZ3rgqzsnYQg65WMIOuwnOyDne2VnOuLpC5cbiAgICogQG5hbWUgZWcuQXhlcyNhbmltYXRpb25FbmRcbiAgICogQGV2ZW50XG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJhbmltYXRpb25FbmRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by50cmlnZ2VyQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKGlzVHJ1c3RlZCkge1xuICAgIGlmIChpc1RydXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgaXNUcnVzdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5heGVzLnRyaWdnZXIoXCJhbmltYXRpb25FbmRcIiwge1xuICAgICAgaXNUcnVzdGVkOiBpc1RydXN0ZWRcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbGwgYWN0aW9ucyBoYXZlIGJlZW4gY29tcGxldGVkLlxuICAgKiBAa28g7JeQ64uI66mU7J207IWY7J20IOuBneuCrOydhCDrlYwg67Cc7IOd7ZWc64ukLlxuICAgKiBAbmFtZSBlZy5BeGVzI2ZpbmlzaFxuICAgKiBAZXZlbnRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImZpbmlzaFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LmlzVHJ1c3RlZFxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJGaW5pc2ggPSBmdW5jdGlvbiAoaXNUcnVzdGVkKSB7XG4gICAgaWYgKGlzVHJ1c3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpc1RydXN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmF4ZXMudHJpZ2dlcihcImZpbmlzaFwiLCB7XG4gICAgICBpc1RydXN0ZWQ6IGlzVHJ1c3RlZFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uY3JlYXRlVXNlckNvbnRyb2xsID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH0gLy8gdG8gY29udHJvbGxcblxuXG4gICAgdmFyIHVzZXJDb250cm9sID0ge1xuICAgICAgZGVzdFBvczogX19hc3NpZ24oe30sIHBvcyksXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAodG9Qb3MsIHVzZXJEdXJhdGlvbikge1xuICAgICAgdG9Qb3MgJiYgKHVzZXJDb250cm9sLmRlc3RQb3MgPSBfX2Fzc2lnbih7fSwgdG9Qb3MpKTtcbiAgICAgIHVzZXJEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29udHJvbC5kdXJhdGlvbiA9IHVzZXJEdXJhdGlvbik7XG4gICAgICByZXR1cm4gdXNlckNvbnRyb2w7XG4gICAgfTtcbiAgfTtcblxuICBfX3Byb3RvLnNldEFuaW1hdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoYW0pIHtcbiAgICB0aGlzLmFtID0gYW07XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXhlcy5vZmYoKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldFJvdW5kUG9zID0gZnVuY3Rpb24gKHBvcywgZGVwYVBvcykge1xuICAgIC8vIHJvdW5kIHZhbHVlIGlmIHJvdW5kIGV4aXN0XG4gICAgdmFyIHJvdW5kVW5pdCA9IHRoaXMuYXhlcy5vcHRpb25zLnJvdW5kOyAvLyBpZiAocm91bmQgPT0gbnVsbCkge1xuICAgIC8vIFx0cmV0dXJuIHtwb3MsIGRlcGFQb3N9OyAvLyB1bmRlZmluZWQsIHVuZGVmaW5lZFxuICAgIC8vIH1cblxuICAgIHJldHVybiB7XG4gICAgICByb3VuZFBvczogcm91bmROdW1iZXJzKHBvcywgcm91bmRVbml0KSxcbiAgICAgIHJvdW5kRGVwYTogcm91bmROdW1iZXJzKGRlcGFQb3MsIHJvdW5kVW5pdClcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCk7XG5cbnZhciBJbnRlcnJ1cHRNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW50ZXJydXB0TWFuYWdlcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9wcmV2ZW50ZWQgPSBmYWxzZTsgLy8gIGNoZWNrIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBldmVudCB3YXMgcHJldmVudGVkXG4gIH1cblxuICB2YXIgX19wcm90byA9IEludGVycnVwdE1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uaXNJbnRlcnJ1cHRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gd2hlbiBpbnRlcnJ1cHRhYmxlIGlzICd0cnVlJywgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyAndHJ1ZScuXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbnRlcnJ1cHRhYmxlIHx8IHRoaXMuX3ByZXZlbnRlZDtcbiAgfTtcblxuICBfX3Byb3RvLmlzSW50ZXJydXB0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLm9wdGlvbnMuaW50ZXJydXB0YWJsZSAmJiB0aGlzLl9wcmV2ZW50ZWQ7XG4gIH07XG5cbiAgX19wcm90by5zZXRJbnRlcnJ1cHQgPSBmdW5jdGlvbiAocHJldmVudGVkKSB7XG4gICAgIXRoaXMub3B0aW9ucy5pbnRlcnJ1cHRhYmxlICYmICh0aGlzLl9wcmV2ZW50ZWQgPSBwcmV2ZW50ZWQpO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcnJ1cHRNYW5hZ2VyO1xufSgpO1xuXG52YXIgQXhpc01hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGlzTWFuYWdlcihheGlzLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuYXhpcyA9IGF4aXM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuX2NvbXBsZW1lbnRPcHRpb25zKCk7XG5cbiAgICB0aGlzLl9wb3MgPSBPYmplY3Qua2V5cyh0aGlzLmF4aXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2KSB7XG4gICAgICBhY2Nbdl0gPSBfdGhpcy5heGlzW3ZdLnJhbmdlWzBdO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgLyoqXG4gICAgICogc2V0IHVwICdjc3MnIGV4cHJlc3Npb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBBeGlzTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5fY29tcGxlbWVudE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuYXhpcykuZm9yRWFjaChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgX3RoaXMuYXhpc1theGlzXSA9IF9fYXNzaWduKHtcbiAgICAgICAgcmFuZ2U6IFswLCAxMDBdLFxuICAgICAgICBib3VuY2U6IFswLCAwXSxcbiAgICAgICAgY2lyY3VsYXI6IFtmYWxzZSwgZmFsc2VdXG4gICAgICB9LCBfdGhpcy5heGlzW2F4aXNdKTtcbiAgICAgIFtcImJvdW5jZVwiLCBcImNpcmN1bGFyXCJdLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGF4aXNPcHRpb24gPSBfdGhpcy5heGlzO1xuICAgICAgICB2YXIga2V5ID0gYXhpc09wdGlvbltheGlzXVt2XTtcblxuICAgICAgICBpZiAoL3N0cmluZ3xudW1iZXJ8Ym9vbGVhbi8udGVzdCh0eXBlb2Yga2V5KSkge1xuICAgICAgICAgIGF4aXNPcHRpb25bYXhpc11bdl0gPSBba2V5LCBrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmdldERlbHRhID0gZnVuY3Rpb24gKGRlcGFQb3MsIGRlc3RQb3MpIHtcbiAgICB2YXIgZnVsbERlcGFQb3MgPSB0aGlzLmdldChkZXBhUG9zKTtcbiAgICByZXR1cm4gbWFwKHRoaXMuZ2V0KGRlc3RQb3MpLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmV0dXJuIHYgLSBmdWxsRGVwYVBvc1trXTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChheGVzICYmIEFycmF5LmlzQXJyYXkoYXhlcykpIHtcbiAgICAgIHJldHVybiBheGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2KSB7XG4gICAgICAgIGlmICh2ICYmIHYgaW4gX3RoaXMuX3Bvcykge1xuICAgICAgICAgIGFjY1t2XSA9IF90aGlzLl9wb3Nbdl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX3BvcyksIGF4ZXMgfHwge30pO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLm1vdmVUbyA9IGZ1bmN0aW9uIChwb3MsIGRlcGFQb3MpIHtcbiAgICBpZiAoZGVwYVBvcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXBhUG9zID0gdGhpcy5fcG9zO1xuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IG1hcCh0aGlzLl9wb3MsIGZ1bmN0aW9uICh2LCBrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgaW4gcG9zICYmIGtleSBpbiBkZXBhUG9zID8gcG9zW2tleV0gLSBkZXBhUG9zW2tleV0gOiAwO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0KHRoaXMubWFwKHBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuIG9wdCA/IGdldENpcmN1bGF0ZWRQb3Modiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIpIDogMDtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogX19hc3NpZ24oe30sIHRoaXMuX3BvcyksXG4gICAgICBkZWx0YTogZGVsdGFcbiAgICB9O1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0ID0gZnVuY3Rpb24gKHBvcykge1xuICAgIGZvciAodmFyIGsgaW4gcG9zKSB7XG4gICAgICBpZiAoayAmJiBrIGluIHRoaXMuX3Bvcykge1xuICAgICAgICB0aGlzLl9wb3Nba10gPSBwb3Nba107XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uZXZlcnkgPSBmdW5jdGlvbiAocG9zLCBjYWxsYmFjaykge1xuICAgIHZhciBheGlzT3B0aW9ucyA9IHRoaXMuYXhpcztcbiAgICByZXR1cm4gZXZlcnkocG9zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBheGlzT3B0aW9uc1trZXldLCBrZXkpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gKHBvcywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXhpc09wdGlvbnMgPSB0aGlzLmF4aXM7XG4gICAgcmV0dXJuIGZpbHRlcihwb3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGF4aXNPcHRpb25zW2tleV0sIGtleSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5tYXAgPSBmdW5jdGlvbiAocG9zLCBjYWxsYmFjaykge1xuICAgIHZhciBheGlzT3B0aW9ucyA9IHRoaXMuYXhpcztcbiAgICByZXR1cm4gbWFwKHBvcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSwgYXhpc09wdGlvbnNba2V5XSwga2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmlzT3V0c2lkZSA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgcmV0dXJuICF0aGlzLmV2ZXJ5KGF4ZXMgPyB0aGlzLmdldChheGVzKSA6IHRoaXMuX3BvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuICFpc091dHNpZGUodiwgb3B0LnJhbmdlKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmdldEF4aXNPcHRpb25zID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmF4aXNba2V5XTtcbiAgfTtcblxuICByZXR1cm4gQXhpc01hbmFnZXI7XG59KCk7XG5cbnZhciBJbnB1dE9ic2VydmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXRPYnNlcnZlcihfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucyxcbiAgICAgICAgaXRtID0gX2EuaXRtLFxuICAgICAgICBlbSA9IF9hLmVtLFxuICAgICAgICBheG0gPSBfYS5heG0sXG4gICAgICAgIGFtID0gX2EuYW07XG4gICAgdGhpcy5pc091dHNpZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1vdmVEaXN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaXRtID0gaXRtO1xuICAgIHRoaXMuZW0gPSBlbTtcbiAgICB0aGlzLmF4bSA9IGF4bTtcbiAgICB0aGlzLmFtID0gYW07XG4gIH0gLy8gd2hlbiBtb3ZlIHBvaW50ZXIgaXMgaGVsZCBpbiBvdXRzaWRlXG5cblxuICB2YXIgX19wcm90byA9IElucHV0T2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uYXRPdXRzaWRlID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc091dHNpZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF4bS5tYXAocG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICAgIHZhciB0biA9IG9wdC5yYW5nZVswXSAtIG9wdC5ib3VuY2VbMF07XG4gICAgICAgIHZhciB0eCA9IG9wdC5yYW5nZVsxXSArIG9wdC5ib3VuY2VbMV07XG4gICAgICAgIHJldHVybiB2ID4gdHggPyB0eCA6IHYgPCB0biA/IHRuIDogdjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aGVuIHN0YXJ0IHBvaW50ZXIgaXMgaGVsZCBpbiBpbnNpZGVcbiAgICAgIC8vIGdldCBhIGluaXRpYWxpemF0aW9uIHNsb3BlIHZhbHVlIHRvIHByZXZlbnQgc21vb3RoIGFuaW1hdGlvbi5cbiAgICAgIHZhciBpbml0U2xvcGVfMSA9IHRoaXMuYW0uZWFzaW5nKDAuMDAwMDEpIC8gMC4wMDAwMTtcbiAgICAgIHJldHVybiB0aGlzLmF4bS5tYXAocG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICAgIHZhciBtaW4gPSBvcHQucmFuZ2VbMF07XG4gICAgICAgIHZhciBtYXggPSBvcHQucmFuZ2VbMV07XG4gICAgICAgIHZhciBvdXQgPSBvcHQuYm91bmNlO1xuICAgICAgICB2YXIgY2lyY3VsYXIgPSBvcHQuY2lyY3VsYXI7XG5cbiAgICAgICAgaWYgKGNpcmN1bGFyICYmIChjaXJjdWxhclswXSB8fCBjaXJjdWxhclsxXSkpIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2IDwgbWluKSB7XG4gICAgICAgICAgLy8gbGVmdFxuICAgICAgICAgIHJldHVybiBtaW4gLSBfdGhpcy5hbS5lYXNpbmcoKG1pbiAtIHYpIC8gKG91dFswXSAqIGluaXRTbG9wZV8xKSkgKiBvdXRbMF07XG4gICAgICAgIH0gZWxzZSBpZiAodiA+IG1heCkge1xuICAgICAgICAgIC8vIHJpZ2h0XG4gICAgICAgICAgcmV0dXJuIG1heCArIF90aGlzLmFtLmVhc2luZygodiAtIG1heCkgLyAob3V0WzFdICogaW5pdFNsb3BlXzEpKSAqIG91dFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXhtLmdldChpbnB1dC5heGVzKTtcbiAgfTtcblxuICBfX3Byb3RvLmhvbGQgPSBmdW5jdGlvbiAoaW5wdXQsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXRtLmlzSW50ZXJydXB0ZWQoKSB8fCAhaW5wdXQuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlT3B0aW9uID0ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcbiAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXRtLnNldEludGVycnVwdCh0cnVlKTtcbiAgICB0aGlzLmFtLmdyYWIoaW5wdXQuYXhlcywgY2hhbmdlT3B0aW9uKTtcbiAgICAhdGhpcy5tb3ZlRGlzdGFuY2UgJiYgdGhpcy5lbS50cmlnZ2VySG9sZCh0aGlzLmF4bS5nZXQoKSwgY2hhbmdlT3B0aW9uKTtcbiAgICB0aGlzLmlzT3V0c2lkZSA9IHRoaXMuYXhtLmlzT3V0c2lkZShpbnB1dC5heGVzKTtcbiAgICB0aGlzLm1vdmVEaXN0YW5jZSA9IHRoaXMuYXhtLmdldChpbnB1dC5heGVzKTtcbiAgfTtcblxuICBfX3Byb3RvLmNoYW5nZSA9IGZ1bmN0aW9uIChpbnB1dCwgZXZlbnQsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmlzU3RvcHBlZCB8fCAhdGhpcy5pdG0uaXNJbnRlcnJ1cHRpbmcoKSB8fCB0aGlzLmF4bS5ldmVyeShvZmZzZXQsIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gMDtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZXBhUG9zID0gdGhpcy5tb3ZlRGlzdGFuY2UgfHwgdGhpcy5heG0uZ2V0KGlucHV0LmF4ZXMpO1xuICAgIHZhciBkZXN0UG9zOyAvLyBmb3Igb3V0c2lkZSBsb2dpY1xuXG4gICAgZGVzdFBvcyA9IG1hcChkZXBhUG9zLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmV0dXJuIHYgKyAob2Zmc2V0W2tdIHx8IDApO1xuICAgIH0pO1xuICAgIHRoaXMubW92ZURpc3RhbmNlICYmICh0aGlzLm1vdmVEaXN0YW5jZSA9IGRlc3RQb3MpOyAvLyBmcm9tIG91dHNpZGUgdG8gaW5zaWRlXG5cbiAgICBpZiAodGhpcy5pc091dHNpZGUgJiYgdGhpcy5heG0uZXZlcnkoZGVwYVBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuICFpc091dHNpZGUodiwgb3B0LnJhbmdlKTtcbiAgICB9KSkge1xuICAgICAgdGhpcy5pc091dHNpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkZXBhUG9zID0gdGhpcy5hdE91dHNpZGUoZGVwYVBvcyk7XG4gICAgZGVzdFBvcyA9IHRoaXMuYXRPdXRzaWRlKGRlc3RQb3MpO1xuICAgIHZhciBpc0NhbmNlbGVkID0gIXRoaXMuZW0udHJpZ2dlckNoYW5nZShkZXN0UG9zLCBmYWxzZSwgZGVwYVBvcywge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBpZiAoaXNDYW5jZWxlZCkge1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5tb3ZlRGlzdGFuY2UgPSBudWxsO1xuICAgICAgdGhpcy5hbS5maW5pc2goZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLnJlbGVhc2UgPSBmdW5jdGlvbiAoaW5wdXQsIGV2ZW50LCBvZmZzZXQsIGlucHV0RHVyYXRpb24pIHtcbiAgICBpZiAodGhpcy5pc1N0b3BwZWQgfHwgIXRoaXMuaXRtLmlzSW50ZXJydXB0aW5nKCkgfHwgIXRoaXMubW92ZURpc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IHRoaXMuYXhtLmdldChpbnB1dC5heGVzKTtcbiAgICB2YXIgZGVwYVBvcyA9IHRoaXMuYXhtLmdldCgpO1xuICAgIHZhciBkZXN0UG9zID0gdGhpcy5heG0uZ2V0KHRoaXMuYXhtLm1hcChvZmZzZXQsIGZ1bmN0aW9uICh2LCBvcHQsIGspIHtcbiAgICAgIGlmIChvcHQuY2lyY3VsYXIgJiYgKG9wdC5jaXJjdWxhclswXSB8fCBvcHQuY2lyY3VsYXJbMV0pKSB7XG4gICAgICAgIHJldHVybiBwb3Nba10gKyB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEluc2lkZVBvc2l0aW9uKHBvc1trXSArIHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyLCBvcHQuYm91bmNlKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5hbS5nZXREdXJhdGlvbihkZXN0UG9zLCBwb3MsIGlucHV0RHVyYXRpb24pO1xuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICBkZXN0UG9zID0gX19hc3NpZ24oe30sIGRlcGFQb3MpO1xuICAgIH0gLy8gcHJlcGFyZSBwYXJhbXNcblxuXG4gICAgdmFyIHBhcmFtID0ge1xuICAgICAgZGVwYVBvczogZGVwYVBvcyxcbiAgICAgIGRlc3RQb3M6IGRlc3RQb3MsXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBkZWx0YTogdGhpcy5heG0uZ2V0RGVsdGEoZGVwYVBvcywgZGVzdFBvcyksXG4gICAgICBpbnB1dEV2ZW50OiBldmVudCxcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgIGlzVHJ1c3RlZDogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5lbS50cmlnZ2VyUmVsZWFzZShwYXJhbSk7XG4gICAgdGhpcy5tb3ZlRGlzdGFuY2UgPSBudWxsOyAvLyB0byBjb250b2xcblxuICAgIHZhciB1c2VyV2lzaCA9IHRoaXMuYW0uZ2V0VXNlckNvbnRyb2xsKHBhcmFtKTtcbiAgICB2YXIgaXNFcXVhbCA9IGVxdWFsKHVzZXJXaXNoLmRlc3RQb3MsIGRlcGFQb3MpO1xuICAgIHZhciBjaGFuZ2VPcHRpb24gPSB7XG4gICAgICBpbnB1dDogaW5wdXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuXG4gICAgaWYgKGlzRXF1YWwgfHwgdXNlcldpc2guZHVyYXRpb24gPT09IDApIHtcbiAgICAgICFpc0VxdWFsICYmIHRoaXMuZW0udHJpZ2dlckNoYW5nZSh1c2VyV2lzaC5kZXN0UG9zLCBmYWxzZSwgZGVwYVBvcywgY2hhbmdlT3B0aW9uLCB0cnVlKTtcbiAgICAgIHRoaXMuaXRtLnNldEludGVycnVwdChmYWxzZSk7XG5cbiAgICAgIGlmICh0aGlzLmF4bS5pc091dHNpZGUoKSkge1xuICAgICAgICB0aGlzLmFtLnJlc3RvcmUoY2hhbmdlT3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW0udHJpZ2dlckZpbmlzaCh0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbS5hbmltYXRlVG8odXNlcldpc2guZGVzdFBvcywgdXNlcldpc2guZHVyYXRpb24sIGNoYW5nZU9wdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbnB1dE9ic2VydmVyO1xufSgpO1xuXG4vLyBleHBvcnQgY29uc3QgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIElPU19FREdFX1RIUkVTSE9MRCA9IDMwO1xudmFyIElTX0lPU19TQUZBUkkgPSBcIm9udG91Y2hzdGFydFwiIGluIHdpbiAmJiBnZXRBZ2VudCgpLmJyb3dzZXIubmFtZSA9PT0gXCJzYWZhcmlcIjtcbnZhciBUUkFOU0ZPUk0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIHZhciBib2R5U3R5bGUgPSAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0pLnN0eWxlO1xuICB2YXIgdGFyZ2V0ID0gW1widHJhbnNmb3JtXCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIFwibXNUcmFuc2Zvcm1cIiwgXCJtb3pUcmFuc2Zvcm1cIl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0YXJnZXRbaV0gaW4gYm9keVN0eWxlKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBcIlwiO1xufSgpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF4aXNPcHRpb24gVGhlIEF4aXMgaW5mb3JtYXRpb24uIFRoZSBrZXkgb2YgdGhlIGF4aXMgc3BlY2lmaWVzIHRoZSBuYW1lIHRvIHVzZSBhcyB0aGUgbG9naWNhbCB2aXJ0dWFsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogQGtvIOy2lSDsoJXrs7QuIOy2leydmCDtgqTripQg64W866as7KCB7J24IOqwgOyDgSDsooztkZzqs4TroZwg7IKs7Jqp7ZWgIOydtOumhOydhCDsp4DsoJXtlZzri6QuXG4gKiBAcHJvcGVydHkge051bWJlcltdfSBbcmFuZ2VdIFRoZSBjb29yZGluYXRlIG9mIHJhbmdlIDxrbz7sooztkZwg67KU7JyEPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFuZ2UuMD0wXSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgbWluaW11bSA8a28+7LWc7IaMIOyijO2RnDwva28+XG4gKiBAcHJvcGVydHkge051bWJlcn0gW3JhbmdlLjE9MF0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG1heGltdW0gPGtvPuy1nOuMgCDsooztkZw8L2tvPlxuICogQHByb3BlcnR5IHtOdW1iZXJbXX0gW2JvdW5jZV0gVGhlIHNpemUgb2YgYm91bmNpbmcgYXJlYS4gVGhlIGNvb3JkaW5hdGVzIGNhbiBleGNlZWQgdGhlIGNvb3JkaW5hdGUgYXJlYSBhcyBtdWNoIGFzIHRoZSBib3VuY2luZyBhcmVhIGJhc2VkIG9uIHVzZXIgYWN0aW9uLiBJZiB0aGUgY29vcmRpbmF0ZXMgZG9lcyBub3QgZXhjZWVkIHRoZSBib3VuY2luZyBhcmVhIHdoZW4gYW4gZWxlbWVudCBpcyBkcmFnZ2VkLCB0aGUgY29vcmRpbmF0ZXMgd2hlcmUgYm91bmNpbmcgZWZmZWN0cyBhcmUgYXBwbGllZCBhcmUgcmV0dW5lZCBiYWNrIGludG8gdGhlIGNvb3JkaW5hdGUgYXJlYTxrbz7rsJTsmrTsiqQg7JiB7Jet7J2YIO2BrOq4sC4g7IKs7Jqp7J6Q7J2YIOuPmeyekeyXkCDrlLDrnbwg7KKM7ZGc6rCAIOyijO2RnCDsmIHsl63snYQg64SY7Ja0IOuwlOyatOyKpCDsmIHsl63snZgg7YGs6riw66eM7YG8IOuNlCDsnbTrj5ntlaAg7IiYIOyeiOuLpC4g7IKs7Jqp7J6Q6rCAIOuBjOyWtOuLpCDrhpPripQg64+Z7J6R7J2EIO2WiOydhCDrlYwg7KKM7ZGc6rCAIOuwlOyatOyKpCDsmIHsl63sl5Ag7J6I7Jy866m0LCDrsJTsmrTsiqQg7Zqo6rO86rCAIOyggeyaqeuQnCDsooztkZzqsIAg64uk7IucIOyijO2RnCDsmIHsl60g7JWI7Jy866GcIOuTpOyWtOyYqOuLpDwva28+XG4gKiBAcHJvcGVydHkge051bWJlcn0gW2JvdW5jZS4wPTBdIFRoZSBzaXplIG9mIGNvb3JkaW5hdGUgb2YgdGhlIG1pbmltdW0gYXJlYSA8a28+7LWc7IaMIOyijO2RnCDrsJTsmrTsiqQg7JiB7Jet7J2YIO2BrOq4sDwva28+XG4gKiBAcHJvcGVydHkge051bWJlcn0gW2JvdW5jZS4xPTBdIFRoZSBzaXplIG9mIGNvb3JkaW5hdGUgb2YgdGhlIG1heGltdW0gYXJlYSA8a28+7LWc64yAIOyijO2RnCDrsJTsmrTsiqQg7JiB7Jet7J2YIO2BrOq4sDwva28+XG4gKiBAcHJvcGVydHkge0Jvb2xlYW5bXX0gW2NpcmN1bGFyXSBJbmRpY2F0ZXMgd2hldGhlciBhIGNpcmN1bGFyIGVsZW1lbnQgaXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzZXQgdG8gXCJ0cnVlXCIgYW5kIGFuIGVsZW1lbnQgaXMgZHJhZ2dlZCBvdXRzaWRlIHRoZSBjb29yZGluYXRlIGFyZWEsIHRoZSBlbGVtZW50IHdpbGwgYXBwZWFyIG9uIHRoZSBvdGhlciBzaWRlLjxrbz7siJztmZgg7Jes67aALiAndHJ1ZSfroZwg7ISk7KCV7ZWcIOuwqe2WpeydmCDsooztkZwg7JiB7JetIOuwluycvOuhnCDsl5jrpqzrqLztirjqsIAg7J2064+Z7ZWY66m0IOuwmOuMgCDrsKntlqXsl5DshJwg7JeY66as66i87Yq46rCAIOuCmO2DgOuCnOuLpDwva28+XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjaXJjdWxhci4wPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0byBjaXJjdWxhdGUgdG8gdGhlIGNvb3JkaW5hdGUgb2YgdGhlIG1pbmltdW0gPGtvPuy1nOyGjCDsooztkZwg67Cp7Zal7J2YIOyInO2ZmCDsl6zrtoA8L2tvPlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbY2lyY3VsYXIuMT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gY2lyY3VsYXRlIHRvIHRoZSBjb29yZGluYXRlIG9mIHRoZSBtYXhpbXVtIDxrbz7stZzrjIAg7KKM7ZGcIOuwqe2WpeydmCDsiJztmZgg7Jes67aAPC9rbz5cbioqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF4ZXNPcHRpb24gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMgbW9kdWxlXG4gKiBAa28gZWcuQXhlcyDrqqjrk4jsnZgg7Ji17IWYIOqwneyytFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2Vhc2luZz1lYXNpbmcuZWFzZU91dEN1YmljXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGFuIGFuaW1hdGlvbiA8a28+7JWg64uI66mU7J207IWY7JeQIOyggeyaqe2VoCBlYXNpbmcg7ZWo7IiYPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWF4aW11bUR1cmF0aW9uPUluZmluaXR5XSBNYXhpbXVtIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gPGtvPuqwgOyGjeuPhOyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOuPmeyeke2VoCDrlYzsnZgg7LWc64yAIOyijO2RnCDsnbTrj5kg7Iuc6rCEPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWluaW11bUR1cmF0aW9uPTBdIE1pbmltdW0gZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiA8a28+6rCA7IaN64+E7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg64+Z7J6R7ZWgIOuVjOydmCDstZzshowg7KKM7ZGcIOydtOuPmSDsi5zqsIQ8L2tvPlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkZWNlbGVyYXRpb249MC4wMDA2XSBEZWNlbGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiB3aGVyZSBhY2NlbGVyYXRpb24gaXMgbWFudWFsbHkgZW5hYmxlZCBieSB1c2VyLiBBIGhpZ2hlciB2YWx1ZSBpbmRpY2F0ZXMgc2hvcnRlciBydW5uaW5nIHRpbWUuIDxrbz7sgqzsmqnsnpDsnZgg64+Z7J6R7Jy866GcIOqwgOyGjeuPhOqwgCDsoIHsmqnrkJwg7JWg64uI66mU7J207IWY7J2YIOqwkOyGjeuPhC4g6rCS7J20IOuGkuydhOyImOuhnSDslaDri4jrqZTsnbTshZgg7Iuk7ZaJIOyLnOqwhOydtCDsp6fslYTsp4Tri6Q8L2tvPlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJydXB0YWJsZT10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciBhbiBhbmltYXRpb24gaXMgaW50ZXJydXB0aWJsZS48YnI+LSB0cnVlOiBJdCBjYW4gYmUgcGF1c2VkIG9yIHN0b3BwZWQgYnkgdXNlciBhY3Rpb24gb3IgdGhlIEFQSS48YnI+LSBmYWxzZTogSXQgY2Fubm90IGJlIHBhdXNlZCBvciBzdG9wcGVkIGJ5IHVzZXIgYWN0aW9uIG9yIHRoZSBBUEkgd2hpbGUgaXQgaXMgcnVubmluZy48a28+7KeE7ZaJIOykkeyduCDslaDri4jrqZTsnbTshZgg7KSR7KeAIOqwgOuKpSDsl6zrtoAuPGJyPi0gdHJ1ZTog7IKs7Jqp7J6Q7J2YIOuPmeyekeydtOuCmCBBUEnroZwg7JWg64uI66mU7J207IWY7J2EIOykkeyngO2VoCDsiJgg7J6I64ukLjxicj4tIGZhbHNlOiDslaDri4jrqZTsnbTshZjsnbQg7KeE7ZaJIOykkeydvCDrlYzripQg7IKs7Jqp7J6Q7J2YIOuPmeyekeydtOuCmCBBUEnqsIAg7KCB7Jqp65CY7KeAIOyViuuKlOuLpDwva28+XG4gKiBAcHJvcGVydHkge051bWJlcn0gW3JvdW5kID0gbnVsbF0gUm91bmRpbmcgdW5pdC4gRm9yIGV4YW1wbGUsIDAuMSByb3VuZHMgdG8gMC4xIGRlY2ltYWwgcG9pbnQoNi4xMjM0ID0+IDYuMSksIDUgcm91bmRzIHRvIDUgKDkzID0+IDk1KSA8YnI+W0RldGFpbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXMvd2lraS9yb3VuZC1vcHRpb24pPGtvPuuwmOyYrOumvCDri6jsnIQuIOyYiOulvCDrk6TslrQgMC4xIOydgCDshozsiKvsoJAgMC4xIOq5jOyngCDrsJjsmKzrprwoNi4xMjM0ID0+IDYuMSksIDUg64qUIDUg64uo7JyE66GcIOuwmOyYrOumvCg5MyA9PiA5NSkuPGJyPlvsg4HshLjrgrTsmqldKGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXMvd2lraS9yb3VuZC1vcHRpb24pPC9rbz5cbioqL1xuXG4vKipcbiAqIEBjbGFzcyBlZy5BeGVzXG4gKiBAY2xhc3NkZXNjIEEgbW9kdWxlIHVzZWQgdG8gY2hhbmdlIHRoZSBpbmZvcm1hdGlvbiBvZiB1c2VyIGFjdGlvbiBlbnRlcmVkIGJ5IHZhcmlvdXMgaW5wdXQgZGV2aWNlcyBzdWNoIGFzIHRvdWNoIHNjcmVlbiBvciBtb3VzZSBpbnRvIHRoZSBsb2dpY2FsIHZpcnR1YWwgY29vcmRpbmF0ZXMuIFlvdSBjYW4gZWFzaWx5IGNyZWF0ZSBhIFVJIHRoYXQgcmVzcG9uZHMgdG8gdXNlciBhY3Rpb25zLlxuICogQGtvIO2EsOy5mCDsnoXroKUg7J6l7LmY64KYIOuniOyasOyKpOyZgCDqsJnsnYAg64uk7JaR7ZWcIOyeheugpSDsnqXsuZjrpbwg7Ya17ZW0IOyghOuLrCDrsJvsnYAg7IKs7Jqp7J6Q7J2YIOuPmeyekeydhCDrhbzrpqzsoIHsnbgg6rCA7IOBIOyijO2RnOuhnCDrs4Dqsr3tlZjripQg66qo65OI7J2064ukLiDsgqzsmqnsnpAg64+Z7J6R7JeQIOuwmOydke2VmOuKlCBVSeulvCDshpDsib3qsowg66eM65Ok7IiYIOyeiOuLpC5cbiAqIEBleHRlbmRzIGVnLkNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEF4aXNPcHRpb24+fSBheGlzIEF4aXMgaW5mb3JtYXRpb24gbWFuYWdlZCBieSBlZy5BeGVzLiBUaGUga2V5IG9mIHRoZSBheGlzIHNwZWNpZmllcyB0aGUgbmFtZSB0byB1c2UgYXMgdGhlIGxvZ2ljYWwgdmlydHVhbCBjb29yZGluYXRlIHN5c3RlbS4gIDxrbz5lZy5BeGVz6rCAIOq0gOumrO2VmOuKlCDstpUg7KCV67O0LiDstpXsnZgg7YKk64qUIOuFvOumrOyggeyduCDqsIDsg4Eg7KKM7ZGc6rOE66GcIOyCrOyaqe2VoCDsnbTrpoTsnYQg7KeA7KCV7ZWc64ukLjwva28+XG4gKiBAcGFyYW0ge0F4ZXNPcHRpb259IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcyBtb2R1bGU8a28+ZWcuQXhlcyDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBbc3RhcnRQb3NdIFRoZSBjb29yZGluYXRlcyB0byBiZSBtb3ZlZCB3aGVuIGNyZWF0aW5nIGFuIGluc3RhbmNlLiBub3QgdHJpZ2dlcmluZyBjaGFuZ2UgZXZlbnQuPGtvPuyduOyKpO2EtOyKpCDsg53shLHsi5wg7J2064+Z7ZWgIOyijO2RnCwgY2hhbmdlIOydtOuypO2KuOuKlCDrsJzsg53tlZjsp4Ag7JWK7J2MLjwva28+XG4gKlxuICogQHN1cHBvcnQge1wiaWVcIjogXCIxMCtcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjMrIChleGNlcHQgMy54KVwifVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyAxLiBJbml0aWFsaXplIGVnLkF4ZXNcbiAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gKlx0c29tZXRoaW5nMToge1xuICpcdFx0cmFuZ2U6IFswLCAxNTBdLFxuICpcdFx0Ym91bmNlOiA1MFxuICpcdH0sXG4gKlx0c29tZXRoaW5nMjoge1xuICpcdFx0cmFuZ2U6IFswLCAyMDBdLFxuICpcdFx0Ym91bmNlOiAxMDBcbiAqXHR9LFxuICpcdHNvbWV0aGluZ046IHtcbiAqXHRcdHJhbmdlOiBbMSwgMTBdLFxuICpcdH1cbiAqIH0sIHtcbiAqICBkZWNlbGVyYXRpb24gOiAwLjAwMjRcbiAqIH0pO1xuICpcbiAqIC8vIDIuIGF0dGFjaCBldmVudCBoYW5kbGVyXG4gKiBheGVzLm9uKHtcbiAqXHRcImhvbGRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICpcdH0sXG4gKlx0XCJyZWxlYXNlXCIgOiBmdW5jdGlvbihldnQpIHtcbiAqXHR9LFxuICpcdFwiYW5pbWF0aW9uU3RhcnRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICpcdH0sXG4gKlx0XCJhbmltYXRpb25FbmRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICpcdH0sXG4gKlx0XCJjaGFuZ2VcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICpcdH1cbiAqIH0pO1xuICpcbiAqIC8vIDMuIEluaXRpYWxpemUgaW5wdXRUeXBlc1xuICogY29uc3QgcGFuSW5wdXRBcmVhID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYVwiLCB7XG4gKlx0c2NhbGU6IFswLjUsIDFdXG4gKiB9KTtcbiAqIGNvbnN0IHBhbklucHV0SG1vdmUgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNobW92ZVwiKTtcbiAqIGNvbnN0IHBhbklucHV0Vm1vdmUgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiN2bW92ZVwiKTtcbiAqIGNvbnN0IHBpbmNoSW5wdXRBcmVhID0gbmV3IGVnLkF4ZXMuUGluY2hJbnB1dChcIiNhcmVhXCIsIHtcbiAqXHRzY2FsZTogMS41XG4gKiB9KTtcbiAqXG4gKiAvLyA0LiBDb25uZWN0IGVnLkF4ZXMgYW5kIElucHV0VHlwZXNcbiAqIC8vIFtQYW5JbnB1dF0gV2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiAvLyBDb25uZWN0IHRoZSAnc29tZXRoaW5nMicgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geCBwb3NpdGlvbiBhbmRcbiAqIC8vIGNvbm5lY3QgdGhlICdzb21ldGhpbmdOJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB5IHBvc2l0aW9uLlxuICogYXhlcy5jb25uZWN0KFtcInNvbWV0aGluZzJcIiwgXCJzb21ldGhpbmdOXCJdLCBwYW5JbnB1dEFyZWEpOyAvLyBvciBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmcyIHNvbWV0aGluZ05cIiwgcGFuSW5wdXRBcmVhKTtcbiAqXG4gKiAvLyBDb25uZWN0IG9ubHkgb25lICdzb21ldGhpbmcxJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB4IHBvc2l0aW9uLlxuICogYXhlcy5jb25uZWN0KFtcInNvbWV0aGluZzFcIl0sIHBhbklucHV0SG1vdmUpOyAvLyBvciBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmcxXCIsIHBhbklucHV0SG1vdmUpO1xuICpcbiAqIC8vIENvbm5lY3Qgb25seSBvbmUgJ3NvbWV0aGluZzInIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHkgcG9zaXRpb24uXG4gKiBheGVzLmNvbm5lY3QoW1wiXCIsIFwic29tZXRoaW5nMlwiXSwgcGFuSW5wdXRWbW92ZSk7IC8vIG9yIGF4ZXMuY29ubmVjdChcIiBzb21ldGhpbmcyXCIsIHBhbklucHV0Vm1vdmUpO1xuICpcbiAqIC8vIFtQaW5jaElucHV0XSBDb25uZWN0ICdzb21ldGhpbmcyJyBheGlzIHdoZW4gdHdvIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogYXhlcy5jb25uZWN0KFwic29tZXRoaW5nMlwiLCBwaW5jaElucHV0QXJlYSk7XG4gKi9cblxudmFyIEF4ZXMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQXhlcywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBeGVzKGF4aXMsIG9wdGlvbnMsIHN0YXJ0UG9zKSB7XG4gICAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuICAgICAgYXhpcyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgX3RoaXMuX2lucHV0cyA9IFtdO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBlYXNpbmc6IGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh4KSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHgsIDMpO1xuICAgICAgfSxcbiAgICAgIGludGVycnVwdGFibGU6IHRydWUsXG4gICAgICBtYXhpbXVtRHVyYXRpb246IEluZmluaXR5LFxuICAgICAgbWluaW11bUR1cmF0aW9uOiAwLFxuICAgICAgZGVjZWxlcmF0aW9uOiAwLjAwMDYsXG4gICAgICByb3VuZDogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIF90aGlzLml0bSA9IG5ldyBJbnRlcnJ1cHRNYW5hZ2VyKF90aGlzLm9wdGlvbnMpO1xuICAgIF90aGlzLmF4bSA9IG5ldyBBeGlzTWFuYWdlcihfdGhpcy5heGlzLCBfdGhpcy5vcHRpb25zKTtcbiAgICBfdGhpcy5lbSA9IG5ldyBFdmVudE1hbmFnZXIoX3RoaXMpO1xuICAgIF90aGlzLmFtID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIoX3RoaXMpO1xuICAgIF90aGlzLmlvID0gbmV3IElucHV0T2JzZXJ2ZXIoX3RoaXMpO1xuXG4gICAgX3RoaXMuZW0uc2V0QW5pbWF0aW9uTWFuYWdlcihfdGhpcy5hbSk7XG5cbiAgICBzdGFydFBvcyAmJiBfdGhpcy5lbS50cmlnZ2VyQ2hhbmdlKHN0YXJ0UG9zKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdGhlIGF4aXMgb2YgZWcuQXhlcyB0byB0aGUgaW5wdXRUeXBlLlxuICAgKiBAa28gZWcuQXhlc+ydmCDstpXqs7wgaW5wdXRUeXBl7J2EIOyXsOqysO2VnOuLpFxuICAgKiBAbWV0aG9kIGVnLkF4ZXMjY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmdbXXxTdHJpbmcpfSBheGVzIFRoZSBuYW1lIG9mIHRoZSBheGlzIHRvIGFzc29jaWF0ZSB3aXRoIGlucHV0VHlwZSA8a28+aW5wdXRUeXBl6rO8IOyXsOqysO2VoCDstpXsnZgg7J2066aEPC9rbz5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0VHlwZSBUaGUgaW5wdXRUeXBlIGluc3RhbmNlIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBheGlzIG9mIGVnLkF4ZXMgPGtvPmVnLkF4ZXPsnZgg7LaV6rO8IOyXsOqysO2VoCBpbnB1dFR5cGUg7J247Iqk7YS07IqkPGtvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuY29ubmVjdChcInhcIiwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTFcIikpXG4gICAqICAgIC5jb25uZWN0KFwieCB4T3RoZXJcIiwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTJcIikpXG4gICAqICAgIC5jb25uZWN0KFwiIHhPdGhlclwiLCBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhM1wiKSlcbiAgICogICAgLmNvbm5lY3QoW1wieFwiXSwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTRcIikpXG4gICAqICAgIC5jb25uZWN0KFtcInhPdGhlclwiLCBcInhcIl0sIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWE1XCIpKVxuICAgKiAgICAuY29ubmVjdChbXCJcIiwgXCJ4T3RoZXJcIl0sIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWE2XCIpKTtcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEF4ZXMucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChheGVzLCBpbnB1dFR5cGUpIHtcbiAgICB2YXIgbWFwcGVkO1xuXG4gICAgaWYgKHR5cGVvZiBheGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtYXBwZWQgPSBheGVzLnNwbGl0KFwiIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwcGVkID0gYXhlcy5jb25jYXQoKTtcbiAgICB9IC8vIGNoZWNrIHNhbWUgaW5zdGFuY2VcblxuXG4gICAgaWYgKH50aGlzLl9pbnB1dHMuaW5kZXhPZihpbnB1dFR5cGUpKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoaW5wdXRUeXBlKTtcbiAgICB9IC8vIGNoZWNrIHNhbWUgZWxlbWVudCBpbiBoYW1tZXIgdHlwZSBmb3Igc2hhcmVcblxuXG4gICAgaWYgKFwiaGFtbWVyXCIgaW4gaW5wdXRUeXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0cyA9IHRoaXMuX2lucHV0cy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYuaGFtbWVyICYmIHYuZWxlbWVudCA9PT0gaW5wdXRUeXBlLmVsZW1lbnQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRhcmdldHMubGVuZ3RoKSB7XG4gICAgICAgIGlucHV0VHlwZS5oYW1tZXIgPSB0YXJnZXRzWzBdLmhhbW1lcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dFR5cGUubWFwQXhlcyhtYXBwZWQpO1xuICAgIGlucHV0VHlwZS5jb25uZWN0KHRoaXMuaW8pO1xuXG4gICAgdGhpcy5faW5wdXRzLnB1c2goaW5wdXRUeXBlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGlzY29ubmVjdCB0aGUgYXhpcyBvZiBlZy5BeGVzIGZyb20gdGhlIGlucHV0VHlwZS5cbiAgICogQGtvIGVnLkF4ZXPsnZgg7LaV6rO8IGlucHV0VHlwZeydmCDsl7DqsrDsnYQg64GK64qU64ukLlxuICAgKiBAbWV0aG9kIGVnLkF4ZXMjZGlzY29ubmVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2lucHV0VHlwZV0gQW4gaW5wdXRUeXBlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXhpcyBvZiBlZy5BeGVzIDxrbz5lZy5BeGVz7J2YIOy2leqzvCDsl7DqsrDtlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpDxrbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBpbnB1dDEgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhMVwiKTtcbiAgICogY29uc3QgaW5wdXQyID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTJcIik7XG4gICAqIGNvbnN0IGlucHV0MyA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWEzXCIpO1xuICAgKlxuICAgKiBheGVzLmNvbm5lY3QoXCJ4XCIsIGlucHV0MSk7XG4gICAqICAgIC5jb25uZWN0KFwieCB4T3RoZXJcIiwgaW5wdXQyKVxuICAgKiAgICAuY29ubmVjdChbXCJ4T3RoZXJcIiwgXCJ4XCJdLCBpbnB1dDMpO1xuICAgKlxuICAgKiBheGVzLmRpc2Nvbm5lY3QoaW5wdXQxKTsgLy8gZGlzY29ubmVjdHMgaW5wdXQxXG4gICAqIGF4ZXMuZGlzY29ubmVjdCgpOyAvLyBkaXNjb25uZWN0cyBhbGwgb2YgdGhlbVxuICAgKi9cblxuXG4gIF9fcHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChpbnB1dFR5cGUpIHtcbiAgICBpZiAoaW5wdXRUeXBlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbnB1dHMuaW5kZXhPZihpbnB1dFR5cGUpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLl9pbnB1dHNbaW5kZXhdLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICB0aGlzLl9pbnB1dHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYuZGlzY29ubmVjdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2lucHV0cyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY29vcmRpbmF0ZXMuXG4gICAqIEBrbyDsooztkZzsnZgg7ZiE7J6sIOychOy5mOulvCDrsJjtmZjtlZzri6RcbiAgICogQG1ldGhvZCBlZy5BeGVzI2dldFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F4ZXNdIFRoZSBuYW1lcyBvZiB0aGUgYXhpcyA8a28+7LaVIOydtOumhOuTpDwva28+XG4gICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBBeGlzIGNvb3JkaW5hdGUgaW5mb3JtYXRpb24gPGtvPuy2lSDsooztkZwg7KCV67O0PC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqIFx0IFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAwLCBcInhPdGhlclwiOiAtMTAwLCBcInpvb21cIjogNTB9XG4gICAqIGF4ZXMuZ2V0KFtcInhcIiwgXCJ6b29tXCJdKTsgLy8ge1wieFwiOiAwLCBcInpvb21cIjogNTB9XG4gICAqL1xuXG5cbiAgX19wcm90by5nZXQgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgIHJldHVybiB0aGlzLmF4bS5nZXQoYXhlcyk7XG4gIH07XG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBheGlzIHRvIHNwZWNpZmljIGNvb3JkaW5hdGVzLlxuICAgKiBAa28g7KKM7ZGc66W8IOydtOuPme2VnOuLpC5cbiAgICogQG1ldGhvZCBlZy5BeGVzI3NldFRvXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj0wXSBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcykgPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEKOuLqOychDogbXMpPC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9LFxuICAgKiBcdCBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiAzMCwgXCJ6b29tXCI6IDYwfSk7XG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMzAsIFwieE90aGVyXCI6IC0xMDAsIFwiem9vbVwiOiA2MH1cbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDEwMCwgXCJ4T3RoZXJcIjogNjB9LCAxMDAwKTsgLy8gYW5pbWF0YXRpb25cbiAgICpcbiAgICogLy8gYWZ0ZXIgMTAwMCBtc1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDEwMCwgXCJ4T3RoZXJcIjogNjAsIFwiem9vbVwiOiA2MH1cbiAgICovXG5cblxuICBfX3Byb3RvLnNldFRvID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIHRoaXMuYW0uc2V0VG8ocG9zLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBheGlzIGZyb20gdGhlIGN1cnJlbnQgY29vcmRpbmF0ZXMgdG8gc3BlY2lmaWMgY29vcmRpbmF0ZXMuXG4gICAqIEBrbyDtmITsnqwg7KKM7ZGc66W8IOq4sOykgOycvOuhnCDsooztkZzrpbwg7J2064+Z7ZWc64ukLlxuICAgKiBAbWV0aG9kIGVnLkF4ZXMjc2V0QnlcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zIFRoZSBjb29yZGluYXRlIHRvIG1vdmUgdG8gPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPTBdIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKSA8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQo64uo7JyEOiBtcyk8L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqIFx0IFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRCeSh7XCJ4XCI6IDMwLCBcInpvb21cIjogMTB9KTtcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAzMCwgXCJ4T3RoZXJcIjogLTEwMCwgXCJ6b29tXCI6IDYwfVxuICAgKlxuICAgKiBheGVzLnNldEJ5KHtcInhcIjogNzAsIFwieE90aGVyXCI6IDYwfSwgMTAwMCk7IC8vIGFuaW1hdGF0aW9uXG4gICAqXG4gICAqIC8vIGFmdGVyIDEwMDAgbXNcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAxMDAsIFwieE90aGVyXCI6IC00MCwgXCJ6b29tXCI6IDYwfVxuICAgKi9cblxuXG4gIF9fcHJvdG8uc2V0QnkgPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5hbS5zZXRCeShwb3MsIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGVyZSBpcyBhIGNvb3JkaW5hdGUgaW4gdGhlIGJvdW5jZSBhcmVhIG9mIOKAi+KAi3RoZSB0YXJnZXQgYXhpcy5cbiAgICogQGtvIOuMgOyDgSDstpUg7KSRIGJvdW5jZeyYgeyXreyXkCDsooztkZzqsIAg7KG07J6s7ZWY64qU7KeA66W8IOuwmO2ZmO2VnOuLpFxuICAgKiBAbWV0aG9kIGVnLkF4ZXMjaXNCb3VuY2VBcmVhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXhlc10gVGhlIG5hbWVzIG9mIHRoZSBheGlzIDxrbz7stpUg7J2066aE65OkPC9rbz5cbiAgICogQHJldHVybiB7Qm9vbGVufSBXaGV0aGVyIHRoZSBib3VuY2UgYXJlYSBleGlzdHMuIDxrbz5ib3VuY2Ug7JiB7JetIOyhtOyerCDsl6zrtoA8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInhPdGhlclwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFstMTAwLCAxMDBdXG4gICAqICAgfSxcbiAgICogXHQgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLmlzQm91bmNlQXJlYShbXCJ4XCJdKTtcbiAgICogYXhlcy5pc0JvdW5jZUFyZWEoW1wieFwiLCBcInpvb21cIl0pO1xuICAgKiBheGVzLmlzQm91bmNlQXJlYSgpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNCb3VuY2VBcmVhID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5heG0uaXNPdXRzaWRlKGF4ZXMpO1xuICB9O1xuICAvKipcbiAgKiBEZXN0cm95cyBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzIHVzZWQgaW4gYSBtb2R1bGUgYW5kIGRpc2Nvbm5lY3QgYWxsIGNvbm5lY3Rpb25zIHRvIGlucHV0VHlwZXMuXG4gICogQGtvIOuqqOuTiOyXkCDsgqzsmqntlZwg7IaN7ISxLCDsnbTrsqTtirjrpbwg7ZW07KCc7ZWc64ukLiDrqqjrk6AgaW5wdXRUeXBl6rO87J2YIOyXsOqysOydhCDrgYrripTri6QuXG4gICogQG1ldGhvZCBlZy5BeGVzI2Rlc3Ryb3lcbiAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmVtLmRlc3Ryb3koKTtcbiAgfTtcbiAgLyoqXG4gICAqIFZlcnNpb24gaW5mbyBzdHJpbmdcbiAgICogQGtvIOuyhOyghOygleuztCDrrLjsnpDsl7RcbiAgICogQG5hbWUgVkVSU0lPTlxuICAgKiBAc3RhdGljXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIGVnLkF4ZXMuVkVSU0lPTjsgIC8vIGV4KSAzLjMuM1xuICAgKiBAbWVtYmVyb2YgZWcuQXhlc1xuICAgKi9cblxuXG4gIEF4ZXMuVkVSU0lPTiA9IFwiMi44LjBcIjtcbiAgLyoqXG4gICAqIEBuYW1lIGVnLkF4ZXMuVFJBTlNGT1JNXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgd2l0aCBDU1MgdmVuZG9yIHByZWZpeGVzLlxuICAgKiBAa28gQ1NTIHZlbmRvciBwcmVmaXhlc+ulvCDrtpnsnbggdHJhbnNmb3JtIOyGjeyEseydhCDrsJjtmZjtlZzri6QuXG4gICAqXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiBlZy5BeGVzLlRSQU5TRk9STTsgLy8gXCJ0cmFuc2Zvcm1cIiBvciBcIndlYmtpdFRyYW5zZm9ybVwiXG4gICAqL1xuXG4gIEF4ZXMuVFJBTlNGT1JNID0gVFJBTlNGT1JNO1xuICAvKipcbiAgICogQG5hbWUgZWcuQXhlcy5ESVJFQ1RJT05fTk9ORVxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG5cbiAgQXhlcy5ESVJFQ1RJT05fTk9ORSA9IERJUkVDVElPTl9OT05FO1xuICAvKipcbiAgICogQG5hbWUgZWcuQXhlcy5ESVJFQ1RJT05fTEVGVFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgKi9cblxuICBBeGVzLkRJUkVDVElPTl9MRUZUID0gRElSRUNUSU9OX0xFRlQ7XG4gIC8qKlxuICAgKiBAbmFtZSBlZy5BeGVzLkRJUkVDVElPTl9SSUdIVFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgKi9cblxuICBBeGVzLkRJUkVDVElPTl9SSUdIVCA9IERJUkVDVElPTl9SSUdIVDtcbiAgLyoqXG4gICAqIEBuYW1lIGVnLkF4ZXMuRElSRUNUSU9OX1VQXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAqL1xuXG4gIEF4ZXMuRElSRUNUSU9OX1VQID0gRElSRUNUSU9OX1VQO1xuICAvKipcbiAgICogQG5hbWUgZWcuQXhlcy5ESVJFQ1RJT05fRE9XTlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgKi9cblxuICBBeGVzLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gIC8qKlxuICAgKiBAbmFtZSBlZy5BeGVzLkRJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAqL1xuXG4gIEF4ZXMuRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbiAgLyoqXG4gICAqIEBuYW1lIGVnLkF4ZXMuRElSRUNUSU9OX1ZFUlRJQ0FMXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAqL1xuXG4gIEF4ZXMuRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1ZFUlRJQ0FMO1xuICAvKipcbiAgICogQG5hbWUgZWcuQXhlcy5ESVJFQ1RJT05fQUxMXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAqL1xuXG4gIEF4ZXMuRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9BTEw7XG4gIHJldHVybiBBeGVzO1xufShDb21wb25lbnQpO1xuXG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IFwiUG9pbnRlckV2ZW50XCIgaW4gd2luIHx8IFwiTVNQb2ludGVyRXZlbnRcIiBpbiB3aW47XG52YXIgU1VQUE9SVF9UT1VDSCA9IChcIm9udG91Y2hzdGFydFwiIGluIHdpbik7XG52YXIgVU5JUVVFS0VZID0gXCJfRUdKU19BWEVTX0lOUFVUVFlQRV9cIjtcbmZ1bmN0aW9uIHRvQXhpcyhzb3VyY2UsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0LnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2LCBpKSB7XG4gICAgaWYgKHNvdXJjZVtpXSkge1xuICAgICAgYWNjW3NvdXJjZVtpXV0gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgLy8gY3JlYXRlIEhhbW1lclxuICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBfX2Fzc2lnbih7fSwgb3B0aW9ucykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRJbnB1dFR5cGUoaW5wdXRUeXBlKSB7XG4gIGlmIChpbnB1dFR5cGUgPT09IHZvaWQgMCkge1xuICAgIGlucHV0VHlwZSA9IFtdO1xuICB9XG5cbiAgdmFyIGhhc1RvdWNoID0gZmFsc2U7XG4gIHZhciBoYXNNb3VzZSA9IGZhbHNlO1xuICB2YXIgaGFzUG9pbnRlciA9IGZhbHNlO1xuICBpbnB1dFR5cGUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIHN3aXRjaCAodikge1xuICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgIGhhc01vdXNlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICBoYXNUb3VjaCA9IFNVUFBPUlRfVE9VQ0g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicG9pbnRlclwiOlxuICAgICAgICBoYXNQb2ludGVyID0gU1VQUE9SVF9QT0lOVEVSX0VWRU5UUztcbiAgICAgIC8vIG5vIGRlZmF1bHRcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChoYXNQb2ludGVyKSB7XG4gICAgcmV0dXJuIFBvaW50ZXJFdmVudElucHV0O1xuICB9IGVsc2UgaWYgKGhhc1RvdWNoICYmIGhhc01vdXNlKSB7XG4gICAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbiAgfSBlbHNlIGlmIChoYXNUb3VjaCkge1xuICAgIHJldHVybiBUb3VjaElucHV0O1xuICB9IGVsc2UgaWYgKGhhc01vdXNlKSB7XG4gICAgcmV0dXJuIE1vdXNlSW5wdXQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uQnlBbmdsZShhbmdsZSwgdGhyZXNob2xkQW5nbGUpIHtcbiAgaWYgKHRocmVzaG9sZEFuZ2xlIDwgMCB8fCB0aHJlc2hvbGRBbmdsZSA+IDkwKSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICB9XG5cbiAgdmFyIHRvQW5nbGUgPSBNYXRoLmFicyhhbmdsZSk7XG4gIHJldHVybiB0b0FuZ2xlID4gdGhyZXNob2xkQW5nbGUgJiYgdG9BbmdsZSA8IDE4MCAtIHRocmVzaG9sZEFuZ2xlID8gRElSRUNUSU9OX1ZFUlRJQ0FMIDogRElSRUNUSU9OX0hPUklaT05UQUw7XG59XG5mdW5jdGlvbiBnZXROZXh0T2Zmc2V0KHNwZWVkcywgZGVjZWxlcmF0aW9uKSB7XG4gIHZhciBub3JtYWxTcGVlZCA9IE1hdGguc3FydChzcGVlZHNbMF0gKiBzcGVlZHNbMF0gKyBzcGVlZHNbMV0gKiBzcGVlZHNbMV0pO1xuICB2YXIgZHVyYXRpb24gPSBNYXRoLmFicyhub3JtYWxTcGVlZCAvIC1kZWNlbGVyYXRpb24pO1xuICByZXR1cm4gW3NwZWVkc1swXSAvIDIgKiBkdXJhdGlvbiwgc3BlZWRzWzFdIC8gMiAqIGR1cmF0aW9uXTtcbn1cbmZ1bmN0aW9uIHVzZURpcmVjdGlvbihjaGVja1R5cGUsIGRpcmVjdGlvbiwgdXNlckRpcmVjdGlvbikge1xuICBpZiAodXNlckRpcmVjdGlvbikge1xuICAgIHJldHVybiAhIShkaXJlY3Rpb24gPT09IERJUkVDVElPTl9BTEwgfHwgZGlyZWN0aW9uICYgY2hlY2tUeXBlICYmIHVzZXJEaXJlY3Rpb24gJiBjaGVja1R5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhIShkaXJlY3Rpb24gJiBjaGVja1R5cGUpO1xuICB9XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhbklucHV0T3B0aW9uIFRoZSBvcHRpb24gb2JqZWN0IG9mIHRoZSBlZy5BeGVzLlBhbklucHV0IG1vZHVsZS5cbiAqIEBrbyBlZy5BeGVzLlBhbklucHV0IOuqqOuTiOydmCDsmLXshZgg6rCd7LK0XG4gKiBAcHJvcGVydHkge1N0cmluZ1tdfSBbaW5wdXRUeXBlPVtcInRvdWNoXCIsXCJtb3VzZVwiLCBcInBvaW50ZXJcIl1dIFR5cGVzIG9mIGlucHV0IGRldmljZXMuPGJyPi0gdG91Y2g6IFRvdWNoIHNjcmVlbjxicj4tIG1vdXNlOiBNb3VzZSA8a28+7J6F66ClIOyepey5mCDsooXrpZguPGJyPi0gdG91Y2g6IO2EsOy5mCDsnoXroKUg7J6l7LmYPGJyPi0gbW91c2U6IOuniOyasOyKpDwva28+XG4gKiBAcHJvcGVydHkge051bWJlcltdfSBbc2NhbGVdIENvb3JkaW5hdGUgc2NhbGUgdGhhdCBhIHVzZXIgY2FuIG1vdmU8a28+7IKs7Jqp7J6Q7J2YIOuPmeyekeycvOuhnCDsnbTrj5ntlZjripQg7KKM7ZGc7J2YIOuwsOycqDwva28+XG4gKiBAcHJvcGVydHkge051bWJlcn0gW3NjYWxlLjA9MV0gaG9yaXpvbnRhbCBheGlzIHNjYWxlIDxrbz7siJjtj4nstpUg67Cw7JyoPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2NhbGUuMT0xXSB2ZXJ0aWNhbCBheGlzIHNjYWxlIDxrbz7siJjsp4HstpUg67Cw7JyoPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGhyZXNob2xkQW5nbGU9NDVdIFRoZSB0aHJlc2hvbGQgdmFsdWUgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdXNlciBhY3Rpb24gaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCAoMH45MCkgPGtvPuyCrOyaqeyekOydmCDrj5nsnpHsnbQg6rCA66GcIOuwqe2WpeyduOyngCDshLjroZwg67Cp7Zal7J247KeAIO2MkOuLqO2VmOuKlCDquLDspIAg6rCB64+EKDB+OTApPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGhyZXNob2xkPTBdIE1pbmltYWwgcGFuIGRpc3RhbmNlIHJlcXVpcmVkIGJlZm9yZSByZWNvZ25pemluZyA8a28+7IKs7Jqp7J6Q7J2YIFBhbiDrj5nsnpHsnYQg7J247Iud7ZWY6riwIOychO2VtOyCsCDstZzshoztlZzsnZgg6rGw66asPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbaU9TRWRnZVN3aXBlVGhyZXNob2xkPTMwXSBBcmVhIChweCkgdGhhdCBjYW4gZ28gdG8gdGhlIG5leHQgcGFnZSB3aGVuIHN3aXBpbmcgdGhlIHJpZ2h0IGVkZ2UgaW4gaU9TIHNhZmFyaSA8a28+aU9TIFNhZmFyaeyXkOyEnCDsmKTrpbjsqr0g7Jej7KeA66W8IOyKpOyZgOydtO2UhCDtlZjripQg6rK97JqwIOuLpOydjCDtjpjsnbTsp4DroZwg64SY7Ja06rCIIOyImCDsnojripQg7JiB7JetKHB4KTwva28+XG4gKiBAcHJvcGVydHkge09iamVjdH0gW2hhbW1lck1hbmFnZXJPcHRpb25zPXtjc3NQcm9wczoge3VzZXJTZWxlY3Q6IFwibm9uZVwiLHRvdWNoU2VsZWN0OiBcIm5vbmVcIix0b3VjaENhbGxvdXQ6IFwibm9uZVwiLHVzZXJEcmFnOiBcIm5vbmVcIn1dIE9wdGlvbnMgb2YgSGFtbWVyLk1hbmFnZXIgPGtvPkhhbW1lci5NYW5hZ2Vy7J2YIOyYteyFmDwva28+XG4qKi9cblxuLyoqXG4gKiBAY2xhc3MgZWcuQXhlcy5QYW5JbnB1dFxuICogQGNsYXNzZGVzYyBBIG1vZHVsZSB0aGF0IHBhc3NlcyB0aGUgYW1vdW50IG9mIGNoYW5nZSB0byBlZy5BeGVzIHdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLiB1c2UgbGVzcyB0aGFuIHR3byBheGVzLlxuICogQGtvIOuniOyasOyKpOuCmCDthLDsuZgg7Iqk7YGs66aw7J2EIOuIhOultOqzoCDsm4Dsp4HsnbzrlYzsnZgg67OA7ZmU65+J7J2EIGVnLkF4ZXPsl5Ag7KCE64us7ZWY64qUIOuqqOuTiC4g65GQ6rCcIOydtO2VmOydmCDstpXsnYQg7IKs7Jqp7ZWc64ukLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYW4gPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhXCIsIHtcbiAqIFx0XHRpbnB1dFR5cGU6IFtcInRvdWNoXCJdLFxuICogXHRcdHNjYWxlOiBbMSwgMS4zXSxcbiAqIH0pO1xuICpcbiAqIC8vIENvbm5lY3QgdGhlICdzb21ldGhpbmcyJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB4IHBvc2l0aW9uIHdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLlxuICogLy8gQ29ubmVjdCB0aGUgJ3NvbWV0aGluZ04nIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHkgcG9zaXRpb24gd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiBheGVzLmNvbm5lY3QoW1wic29tZXRoaW5nMlwiLCBcInNvbWV0aGluZ05cIl0sIHBhbik7IC8vIG9yIGF4ZXMuY29ubmVjdChcInNvbWV0aGluZzIgc29tZXRoaW5nTlwiLCBwYW4pO1xuICpcbiAqIC8vIENvbm5lY3Qgb25seSBvbmUgJ3NvbWV0aGluZzEnIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHggcG9zaXRpb24gd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiBheGVzLmNvbm5lY3QoW1wic29tZXRoaW5nMVwiXSwgcGFuKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwic29tZXRoaW5nMVwiLCBwYW4pO1xuICpcbiAqIC8vIENvbm5lY3Qgb25seSBvbmUgJ3NvbWV0aGluZzInIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHkgcG9zaXRpb24gd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiBheGVzLmNvbm5lY3QoW1wiXCIsIFwic29tZXRoaW5nMlwiXSwgcGFuKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwiIHNvbWV0aGluZzJcIiwgcGFuKTtcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ3xqUXVlcnl9IGVsZW1lbnQgQW4gZWxlbWVudCB0byB1c2UgdGhlIGVnLkF4ZXMuUGFuSW5wdXQgbW9kdWxlIDxrbz5lZy5BeGVzLlBhbklucHV0IOuqqOuTiOydhCDsgqzsmqntlaAg7JeY66as66i87Yq4PC9rbz5cbiAqIEBwYXJhbSB7UGFuSW5wdXRPcHRpb259IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcy5QYW5JbnB1dCBtb2R1bGU8a28+ZWcuQXhlcy5QYW5JbnB1dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKi9cblxudmFyIFBhbklucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFuSW5wdXQoZWwsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmF4ZXMgPSBbXTtcbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLnBhblJlY29nbml6ZXIgPSBudWxsO1xuICAgIHRoaXMuaXNSaWdodEVkZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnJpZ2h0RWRnZVRpbWVyID0gMDtcbiAgICB0aGlzLnBhbkZsYWcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBIYW1tZXIgaGVscHMgeW91IGFkZCBzdXBwb3J0IGZvciB0b3VjaCBnZXN0dXJlcyB0byB5b3VyIHBhZ2VcbiAgICAgKlxuICAgICAqIEBleHRlcm5hbCBIYW1tZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvfEhhbW1lci5KU31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2pzZG9jL0hhbW1lci5odG1sfEhhbW1lci5KUyBBUEkgZG9jdW1lbnRzfVxuICAgICAqIEBzZWUgSGFtbWVyLkpTIGFwcGxpZXMgc3BlY2lmaWMgQ1NTIHByb3BlcnRpZXMgYnkge0BsaW5rIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vanNkb2MvSGFtbWVyLmRlZmF1bHRzLmNzc1Byb3BzLmh0bWx8ZGVmYXVsdH0gd2hlbiBjcmVhdGluZyBhbiBpbnN0YW5jZS4gVGhlIGVnLkF4ZXMgbW9kdWxlIHJlbW92ZXMgYWxsIGRlZmF1bHQgQ1NTIHByb3BlcnRpZXMgcHJvdmlkZWQgYnkgSGFtbWVyLkpTXG4gICAgICovXG5cbiAgICBpZiAodHlwZW9mIE1hbmFnZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBIYW1tZXJqcyBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgZWcuQXhlcy5QYW5JbnB1dC5cXG5odHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1wiKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBpbnB1dFR5cGU6IFtcInRvdWNoXCIsIFwibW91c2VcIiwgXCJwb2ludGVyXCJdLFxuICAgICAgc2NhbGU6IFsxLCAxXSxcbiAgICAgIHRocmVzaG9sZEFuZ2xlOiA0NSxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIGlPU0VkZ2VTd2lwZVRocmVzaG9sZDogSU9TX0VER0VfVEhSRVNIT0xELFxuICAgICAgcmVsZWFzZU9uU2Nyb2xsOiBmYWxzZSxcbiAgICAgIGhhbW1lck1hbmFnZXJPcHRpb25zOiB7XG4gICAgICAgIC8vIGNzcyBwcm9wZXJ0aWVzIHdlcmUgcmVtb3ZlZCBkdWUgdG8gdXNhYmxpbGl0eSBpc3N1ZVxuICAgICAgICAvLyBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2pzZG9jL0hhbW1lci5kZWZhdWx0cy5jc3NQcm9wcy5odG1sXG4gICAgICAgIGNzc1Byb3BzOiB7XG4gICAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgICAgICAgdG91Y2hTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgICAgIHRvdWNoQ2FsbG91dDogXCJub25lXCIsXG4gICAgICAgICAgdXNlckRyYWc6IFwibm9uZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLm9uSGFtbWVySW5wdXQgPSB0aGlzLm9uSGFtbWVySW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUGFubW92ZSA9IHRoaXMub25QYW5tb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblBhbmVuZCA9IHRoaXMub25QYW5lbmQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gUGFuSW5wdXQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ubWFwQXhlcyA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgdmFyIHVzZUhvcml6b250YWwgPSAhIWF4ZXNbMF07XG4gICAgdmFyIHVzZVZlcnRpY2FsID0gISFheGVzWzFdO1xuXG4gICAgaWYgKHVzZUhvcml6b250YWwgJiYgdXNlVmVydGljYWwpIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IERJUkVDVElPTl9BTEw7XG4gICAgfSBlbHNlIGlmICh1c2VIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbiAgICB9IGVsc2UgaWYgKHVzZVZlcnRpY2FsKSB7XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSBESVJFQ1RJT05fVkVSVElDQUw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHRoaXMuYXhlcyA9IGF4ZXM7XG4gIH07XG5cbiAgX19wcm90by5jb25uZWN0ID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgdmFyIGhhbW1lck9wdGlvbiA9IHtcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZGlyZWN0aW9uLFxuICAgICAgdGhyZXNob2xkOiB0aGlzLm9wdGlvbnMudGhyZXNob2xkXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmhhbW1lcikge1xuICAgICAgLy8gZm9yIHNoYXJpbmcgaGFtbWVyIGluc3RhbmNlLlxuICAgICAgLy8gaGFtbWVyIHJlbW92ZSBwcmV2aW91cyBQYW5SZWNvZ25pemVyLlxuICAgICAgdGhpcy5yZW1vdmVSZWNvZ25pemVyKCk7XG4gICAgICB0aGlzLmRldHRhY2hFdmVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmVsZW1lbnRbVU5JUVVFS0VZXTtcblxuICAgICAgaWYgKCFrZXlWYWx1ZSkge1xuICAgICAgICBrZXlWYWx1ZSA9IFN0cmluZyhNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBuZXcgRGF0ZSgpLmdldFRpbWUoKSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXRDbGFzcyA9IGNvbnZlcnRJbnB1dFR5cGUodGhpcy5vcHRpb25zLmlucHV0VHlwZSk7XG5cbiAgICAgIGlmICghaW5wdXRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dFR5cGUgcGFyYW1ldGVyIVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oYW1tZXIgPSBjcmVhdGVIYW1tZXIodGhpcy5lbGVtZW50LCBfX2Fzc2lnbih7XG4gICAgICAgIGlucHV0Q2xhc3M6IGlucHV0Q2xhc3NcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5oYW1tZXJNYW5hZ2VyT3B0aW9ucykpO1xuICAgICAgdGhpcy5lbGVtZW50W1VOSVFVRUtFWV0gPSBrZXlWYWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnBhblJlY29nbml6ZXIgPSBuZXcgUGFuKGhhbW1lck9wdGlvbik7XG4gICAgdGhpcy5oYW1tZXIuYWRkKHRoaXMucGFuUmVjb2duaXplcik7XG4gICAgdGhpcy5hdHRhY2hFdmVudChvYnNlcnZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVtb3ZlUmVjb2duaXplcigpO1xuXG4gICAgaWYgKHRoaXMuaGFtbWVyKSB7XG4gICAgICB0aGlzLmRldHRhY2hFdmVudCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgKiBEZXN0cm95cyBlbGVtZW50cywgcHJvcGVydGllcywgYW5kIGV2ZW50cyB1c2VkIGluIGEgbW9kdWxlLlxuICAqIEBrbyDrqqjrk4jsl5Ag7IKs7Jqp7ZWcIOyXmOumrOuovO2KuOyZgCDsho3shLEsIOydtOuypO2KuOulvCDtlbTsoJztlZzri6QuXG4gICogQG1ldGhvZCBlZy5BeGVzLlBhbklucHV0I2Rlc3Ryb3lcbiAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcblxuICAgIGlmICh0aGlzLmhhbW1lciAmJiB0aGlzLmhhbW1lci5yZWNvZ25pemVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5lbGVtZW50W1VOSVFVRUtFWV07XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBFbmFibGVzIGlucHV0IGRldmljZXNcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7Jqp7ZWgIOyImCDsnojqsowg7ZWc64ukXG4gICAqIEBtZXRob2QgZWcuQXhlcy5QYW5JbnB1dCNlbmFibGVcbiAgICogQHJldHVybiB7ZWcuQXhlcy5QYW5JbnB1dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYW1tZXIgJiYgKHRoaXMuaGFtbWVyLmdldChcInBhblwiKS5vcHRpb25zLmVuYWJsZSA9IHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGlzYWJsZXMgaW5wdXQgZGV2aWNlc1xuICAgKiBAa28g7J6F66ClIOyepey5mOulvCDsgqzsmqntlaAg7IiYIOyXhuqyjCDtlZzri6QuXG4gICAqIEBtZXRob2QgZWcuQXhlcy5QYW5JbnB1dCNkaXNhYmxlXG4gICAqIEByZXR1cm4ge2VnLkF4ZXMuUGFuSW5wdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhbW1lciAmJiAodGhpcy5oYW1tZXIuZ2V0KFwicGFuXCIpLm9wdGlvbnMuZW5hYmxlID0gZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRvIHVzZSBhbiBpbnB1dCBkZXZpY2VcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7JqpIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAqIEBtZXRob2QgZWcuQXhlcy5QYW5JbnB1dCNpc0VuYWJsZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRvIHVzZSBhbiBpbnB1dCBkZXZpY2UgPGtvPuyeheugpeyepey5mCDsgqzsmqnsl6zrtoA8L2tvPlxuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNFbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuaGFtbWVyICYmIHRoaXMuaGFtbWVyLmdldChcInBhblwiKS5vcHRpb25zLmVuYWJsZSk7XG4gIH07XG5cbiAgX19wcm90by5yZW1vdmVSZWNvZ25pemVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmhhbW1lciAmJiB0aGlzLnBhblJlY29nbml6ZXIpIHtcbiAgICAgIHRoaXMuaGFtbWVyLnJlbW92ZSh0aGlzLnBhblJlY29nbml6ZXIpO1xuICAgICAgdGhpcy5wYW5SZWNvZ25pemVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5vbkhhbW1lcklucHV0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNFbmFibGUoKSkge1xuICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgdGhpcy5wYW5GbGFnID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGV2ZW50LnNyY0V2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuaG9sZCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgdGhpcy5pc1JpZ2h0RWRnZSA9IElTX0lPU19TQUZBUkkgJiYgZXZlbnQuY2VudGVyLnggPiB3aW5kb3cuaW5uZXJXaWR0aCAtIGVkZ2VUaHJlc2hvbGQ7XG4gICAgICAgICAgdGhpcy5wYW5GbGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudC5pc0ZpbmFsKSB7XG4gICAgICAgIHRoaXMub25QYW5lbmQoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLm9uUGFubW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMucGFuRmxhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgaU9TRWRnZVN3aXBlVGhyZXNob2xkID0gX2EuaU9TRWRnZVN3aXBlVGhyZXNob2xkLFxuICAgICAgICByZWxlYXNlT25TY3JvbGwgPSBfYS5yZWxlYXNlT25TY3JvbGw7XG4gICAgdmFyIHVzZXJEaXJlY3Rpb24gPSBnZXREaXJlY3Rpb25CeUFuZ2xlKGV2ZW50LmFuZ2xlLCB0aGlzLm9wdGlvbnMudGhyZXNob2xkQW5nbGUpOyAvLyBub3Qgc3VwcG9ydCBvZmZzZXQgcHJvcGVydGllcyBpbiBIYW1tZXJqcyAtIHN0YXJ0XG5cbiAgICB2YXIgcHJldklucHV0ID0gdGhpcy5oYW1tZXIuc2Vzc2lvbi5wcmV2SW5wdXQ7XG5cbiAgICBpZiAocmVsZWFzZU9uU2Nyb2xsICYmICFldmVudC5zcmNFdmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICB0aGlzLm9uUGFuZW5kKF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudCksIHtcbiAgICAgICAgdmVsb2NpdHlYOiAwLFxuICAgICAgICB2ZWxvY2l0eVk6IDAsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDBcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldklucHV0ICYmIElTX0lPU19TQUZBUkkpIHtcbiAgICAgIHZhciBzd2lwZUxlZnRUb1JpZ2h0ID0gZXZlbnQuY2VudGVyLnggPCAwO1xuXG4gICAgICBpZiAoc3dpcGVMZWZ0VG9SaWdodCkge1xuICAgICAgICAvLyBpT1Mgc3dpcGUgbGVmdCA9PiByaWdodFxuICAgICAgICB0aGlzLm9uUGFuZW5kKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2SW5wdXQpLCB7XG4gICAgICAgICAgdmVsb2NpdHlYOiAwLFxuICAgICAgICAgIHZlbG9jaXR5WTogMCxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNSaWdodEVkZ2UpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmlnaHRFZGdlVGltZXIpOyAvLyAtIGlzIHJpZ2h0IHRvIGxlZnRcblxuICAgICAgICB2YXIgc3dpcGVSaWdodFRvTGVmdCA9IGV2ZW50LmRlbHRhWCA8IC1pT1NFZGdlU3dpcGVUaHJlc2hvbGQ7XG5cbiAgICAgICAgaWYgKHN3aXBlUmlnaHRUb0xlZnQpIHtcbiAgICAgICAgICB0aGlzLmlzUmlnaHRFZGdlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaU9TIHN3aXBlIHJpZ2h0ID0+IGxlZnRcbiAgICAgICAgICB0aGlzLnJpZ2h0RWRnZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub25QYW5lbmQoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZJbnB1dCksIHtcbiAgICAgICAgICAgICAgdmVsb2NpdHlYOiAwLFxuICAgICAgICAgICAgICB2ZWxvY2l0eVk6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cblxuICAgIGlmIChwcmV2SW5wdXQpIHtcbiAgICAgIGV2ZW50Lm9mZnNldFggPSBldmVudC5kZWx0YVggLSBwcmV2SW5wdXQuZGVsdGFYO1xuICAgICAgZXZlbnQub2Zmc2V0WSA9IGV2ZW50LmRlbHRhWSAtIHByZXZJbnB1dC5kZWx0YVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50Lm9mZnNldFggPSAwO1xuICAgICAgZXZlbnQub2Zmc2V0WSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KFtldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXSwgW3VzZURpcmVjdGlvbihESVJFQ1RJT05fSE9SSVpPTlRBTCwgdGhpcy5fZGlyZWN0aW9uLCB1c2VyRGlyZWN0aW9uKSwgdXNlRGlyZWN0aW9uKERJUkVDVElPTl9WRVJUSUNBTCwgdGhpcy5fZGlyZWN0aW9uLCB1c2VyRGlyZWN0aW9uKV0pO1xuICAgIHZhciBwcmV2ZW50ID0gb2Zmc2V0LnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICE9PSAwO1xuICAgIH0pO1xuXG4gICAgaWYgKHByZXZlbnQpIHtcbiAgICAgIHZhciBzcmNFdmVudCA9IGV2ZW50LnNyY0V2ZW50O1xuXG4gICAgICBpZiAoc3JjRXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudFN5c3RlbUV2ZW50ID0gcHJldmVudDtcbiAgICBwcmV2ZW50ICYmIHRoaXMub2JzZXJ2ZXIuY2hhbmdlKHRoaXMsIGV2ZW50LCB0b0F4aXModGhpcy5heGVzLCBvZmZzZXQpKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUGFuZW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBhbkZsYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yaWdodEVkZ2VUaW1lcik7XG4gICAgdGhpcy5wYW5GbGFnID0gZmFsc2U7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KFtNYXRoLmFicyhldmVudC52ZWxvY2l0eVgpICogKGV2ZW50LmRlbHRhWCA8IDAgPyAtMSA6IDEpLCBNYXRoLmFicyhldmVudC52ZWxvY2l0eVkpICogKGV2ZW50LmRlbHRhWSA8IDAgPyAtMSA6IDEpXSwgW3VzZURpcmVjdGlvbihESVJFQ1RJT05fSE9SSVpPTlRBTCwgdGhpcy5fZGlyZWN0aW9uKSwgdXNlRGlyZWN0aW9uKERJUkVDVElPTl9WRVJUSUNBTCwgdGhpcy5fZGlyZWN0aW9uKV0pO1xuICAgIG9mZnNldCA9IGdldE5leHRPZmZzZXQob2Zmc2V0LCB0aGlzLm9ic2VydmVyLm9wdGlvbnMuZGVjZWxlcmF0aW9uKTtcbiAgICB0aGlzLm9ic2VydmVyLnJlbGVhc2UodGhpcywgZXZlbnQsIHRvQXhpcyh0aGlzLmF4ZXMsIG9mZnNldCkpO1xuICB9O1xuXG4gIF9fcHJvdG8uYXR0YWNoRXZlbnQgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5oYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgdGhpcy5vbkhhbW1lcklucHV0KS5vbihcInBhbnN0YXJ0IHBhbm1vdmVcIiwgdGhpcy5vblBhbm1vdmUpO1xuICB9O1xuXG4gIF9fcHJvdG8uZGV0dGFjaEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFtbWVyLm9mZihcImhhbW1lci5pbnB1dFwiLCB0aGlzLm9uSGFtbWVySW5wdXQpLm9mZihcInBhbnN0YXJ0IHBhbm1vdmVcIiwgdGhpcy5vblBhbm1vdmUpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGRpcmVjdGlvbikge1xuICAgIHZhciBvZmZzZXQgPSBbMCwgMF07XG4gICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxlO1xuXG4gICAgaWYgKGRpcmVjdGlvblswXSkge1xuICAgICAgb2Zmc2V0WzBdID0gcHJvcGVydGllc1swXSAqIHNjYWxlWzBdO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb25bMV0pIHtcbiAgICAgIG9mZnNldFsxXSA9IHByb3BlcnRpZXNbMV0gKiBzY2FsZVsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHJldHVybiBQYW5JbnB1dDtcbn0oKTtcblxuLyoqXG4gKiBAY2xhc3MgZWcuQXhlcy5Sb3RhdGVQYW5JbnB1dFxuICogQGNsYXNzZGVzYyBBIG1vZHVsZSB0aGF0IHBhc3NlcyB0aGUgYW5nbGUgbW92ZWQgYnkgdG91Y2ggdG8gQXhlcyBhbmQgdXNlcyBvbmUgYXhpcyBvZiByb3RhdGlvbi48YnI+W0RldGFpbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXMvd2lraS9Sb3RhdGVQYW5JbnB1dClcbiAqIEBrbyDthLDsuZjsl5Ag7J2Y7ZW0IOybgOyngeyduCDqsIHrj4TrpbwgQXhlcyDsl5Ag7KCE64us7ZWY66mwIDHqsJzsnZgg7ZqM7KCE7LaV66eMIOyCrOyaqe2VnOuLpC48YnI+W+yDgeyEuOuCtOyaqV0oaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtYXhlcy93aWtpL1JvdGF0ZVBhbklucHV0LSU3Qy0lRUQlOTUlOUMlRUElQjUlQUQlRUMlOTYlQjQpXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGlucHV0ID0gbmV3IGVnLkF4ZXMuUm90YXRlUGFuSW5wdXQoXCIjYXJlYVwiKTtcbiAqXG4gKiB2YXIgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAqXHQvLyBwcm9wZXJ0eSBuYW1lKCdhbmdsZScpIGNvdWxkIGJlIGFueXRoaW5nIHlvdSB3YW50IChlZy4geCwgeSwgei4uLilcbiAqIFx0YW5nbGU6IHtcbiAqIFx0XHRyYW5nZTogWy0xODAsIDE4MF0gLy8gZnJvbSAtMTgwZGVnIHRvIDE4MGRlZ1xuICogXHR9XG4gKiB9KTtcbiAqXG4gKiBheGVzLmNvbm5lY3QoXCJhbmdsZVwiLCBpbnB1dClcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ3xqUXVlcnl9IGVsZW1lbnQgQW4gZWxlbWVudCB0byB1c2UgdGhlIGVnLkF4ZXMuUm90YXRlUGFuSW5wdXQgbW9kdWxlIDxrbz5lZy5BeGVzLlJvdGF0ZVBhbklucHV0IOuqqOuTiOydhCDsgqzsmqntlaAg7JeY66as66i87Yq4PC9rbz5cbiAqIEBwYXJhbSB7UGFuSW5wdXRPcHRpb259IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcy5QYW5JbnB1dCBtb2R1bGU8a28+ZWcuQXhlcy5QYW5JbnB1dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKiBAZXh0ZW5kcyBlZy5BeGVzLlBhbklucHV0XG4gKi9cblxudmFyIFJvdGF0ZVBhbklucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFJvdGF0ZVBhbklucHV0LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFJvdGF0ZVBhbklucHV0KGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWwsIG9wdGlvbnMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5wcmV2UXVhZHJhbnQgPSBudWxsO1xuICAgIF90aGlzLmxhc3REaWZmID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFJvdGF0ZVBhbklucHV0LnByb3RvdHlwZTtcblxuICBfX3Byb3RvLm1hcEF4ZXMgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IEF4ZXMuRElSRUNUSU9OX0FMTDtcbiAgICB0aGlzLmF4ZXMgPSBheGVzO1xuICB9O1xuXG4gIF9fcHJvdG8ub25IYW1tZXJJbnB1dCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLmlzRW5hYmxlKCkpIHtcbiAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuaG9sZCh0aGlzLCBldmVudCk7XG4gICAgICAgIHRoaXMub25QYW5zdGFydChldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmlzRmluYWwpIHtcbiAgICAgICAgdGhpcy5vblBhbmVuZChldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8ub25QYW5zdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpdmVcbiAgICAgKi9cbiAgICAvLyBUT0RPOiBob3cgdG8gZG8gaWYgZWxlbWVudCBpcyBlbGxpcHNlIG5vdCBjaXJjbGUuXG5cbiAgICB0aGlzLmNvZWZmaWNpZW50Rm9yRGlzdGFuY2VUb0FuZ2xlID0gMzYwIC8gKHJlY3Qud2lkdGggKiBNYXRoLlBJKTsgLy8gZnJvbSAyKnBpKnIgKiB4IC8gMzYwXG4gICAgLy8gVE9ETzogcHJvdmlkZSBhIHdheSB0byBzZXQgb3JpZ2luIGxpa2UgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1vcmlnaW5cblxuICAgIHRoaXMucm90YXRlT3JpZ2luID0gW3JlY3QubGVmdCArIChyZWN0LndpZHRoIC0gMSkgLyAyLCByZWN0LnRvcCArIChyZWN0LmhlaWdodCAtIDEpIC8gMl07IC8vIGluaXQgYW5nbGUuXG5cbiAgICB0aGlzLnByZXZBbmdsZSA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VyQ2hhbmdlKGV2ZW50KTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUGFubW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMudHJpZ2dlckNoYW5nZShldmVudCk7XG4gIH07XG5cbiAgX19wcm90by5vblBhbmVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMudHJpZ2dlckNoYW5nZShldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyQW5pbWF0aW9uKGV2ZW50KTtcbiAgfTtcblxuICBfX3Byb3RvLnRyaWdnZXJDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgYW5nbGUgPSB0aGlzLmdldEFuZ2xlKGV2ZW50LmNlbnRlci54LCBldmVudC5jZW50ZXIueSk7XG4gICAgdmFyIHF1YWRyYW50ID0gdGhpcy5nZXRRdWFkcmFudChldmVudC5jZW50ZXIueCwgZXZlbnQuY2VudGVyLnkpO1xuICAgIHZhciBkaWZmID0gdGhpcy5nZXREaWZmZXJlbmNlKHRoaXMucHJldkFuZ2xlLCBhbmdsZSwgdGhpcy5wcmV2UXVhZHJhbnQsIHF1YWRyYW50KTtcbiAgICB0aGlzLnByZXZBbmdsZSA9IGFuZ2xlO1xuICAgIHRoaXMucHJldlF1YWRyYW50ID0gcXVhZHJhbnQ7XG5cbiAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubGFzdERpZmYgPSBkaWZmO1xuICAgIHRoaXMub2JzZXJ2ZXIuY2hhbmdlKHRoaXMsIGV2ZW50LCB0b0F4aXModGhpcy5heGVzLCBbLWRpZmZdKSk7IC8vIG1pbnVzIGZvciBjbG9ja3dpc2VcbiAgfTtcblxuICBfX3Byb3RvLnRyaWdnZXJBbmltYXRpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdnggPSBldmVudC52ZWxvY2l0eVg7XG4gICAgdmFyIHZ5ID0gZXZlbnQudmVsb2NpdHlZO1xuICAgIHZhciB2ZWxvY2l0eSA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSkgKiAodGhpcy5sYXN0RGlmZiA+IDAgPyAtMSA6IDEpOyAvLyBjbG9ja3dpc2VcblxuICAgIHZhciBkdXJhdGlvbiA9IE1hdGguYWJzKHZlbG9jaXR5IC8gLXRoaXMub2JzZXJ2ZXIub3B0aW9ucy5kZWNlbGVyYXRpb24pO1xuICAgIHZhciBkaXN0YW5jZSA9IHZlbG9jaXR5IC8gMiAqIGR1cmF0aW9uO1xuICAgIHRoaXMub2JzZXJ2ZXIucmVsZWFzZSh0aGlzLCBldmVudCwgdG9BeGlzKHRoaXMuYXhlcywgW2Rpc3RhbmNlICogdGhpcy5jb2VmZmljaWVudEZvckRpc3RhbmNlVG9BbmdsZV0pKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJldkFuZ2xlLCBhbmdsZSwgcHJldlF1YWRyYW50LCBxdWFkcmFudCkge1xuICAgIHZhciBkaWZmO1xuXG4gICAgaWYgKHByZXZBbmdsZSA9PT0gbnVsbCkge1xuICAgICAgZGlmZiA9IDA7XG4gICAgfSBlbHNlIGlmIChwcmV2UXVhZHJhbnQgPT09IDEgJiYgcXVhZHJhbnQgPT09IDQpIHtcbiAgICAgIGRpZmYgPSAtcHJldkFuZ2xlIC0gKDM2MCAtIGFuZ2xlKTtcbiAgICB9IGVsc2UgaWYgKHByZXZRdWFkcmFudCA9PT0gNCAmJiBxdWFkcmFudCA9PT0gMSkge1xuICAgICAgZGlmZiA9IDM2MCAtIHByZXZBbmdsZSArIGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmID0gYW5nbGUgLSBwcmV2QW5nbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmY7XG4gIH07XG5cbiAgX19wcm90by5nZXRQb3NGcm9tT3JpZ2luID0gZnVuY3Rpb24gKHBvc1gsIHBvc1kpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9zWCAtIHRoaXMucm90YXRlT3JpZ2luWzBdLFxuICAgICAgeTogdGhpcy5yb3RhdGVPcmlnaW5bMV0gLSBwb3NZXG4gICAgfTtcbiAgfTtcblxuICBfX3Byb3RvLmdldEFuZ2xlID0gZnVuY3Rpb24gKHBvc1gsIHBvc1kpIHtcbiAgICB2YXIgX2EgPSB0aGlzLmdldFBvc0Zyb21PcmlnaW4ocG9zWCwgcG9zWSksXG4gICAgICAgIHggPSBfYS54LFxuICAgICAgICB5ID0gX2EueTtcblxuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJOyAvLyBjb25zb2xlLmxvZyhhbmdsZSwgeCwgeSk7XG5cbiAgICByZXR1cm4gYW5nbGUgPCAwID8gMzYwICsgYW5nbGUgOiBhbmdsZTtcbiAgfTtcbiAgLyoqXG4gICAqIFF1YWRyYW50XG4gICAqICAgICAgIHkoKylcbiAgICogICAgICAgfFxuICAgKiAgIDIgICB8ICAgIDFcbiAgICogLS0tLS0tLS0tLS0tLS0tPngoKylcbiAgICogICAzICAgfCAgICA0XG4gICAqICAgICAgIHxcbiAgICovXG5cblxuICBfX3Byb3RvLmdldFF1YWRyYW50ID0gZnVuY3Rpb24gKHBvc1gsIHBvc1kpIHtcbiAgICB2YXIgX2EgPSB0aGlzLmdldFBvc0Zyb21PcmlnaW4ocG9zWCwgcG9zWSksXG4gICAgICAgIHggPSBfYS54LFxuICAgICAgICB5ID0gX2EueTtcblxuICAgIHZhciBxID0gMDtcblxuICAgIGlmICh4ID49IDAgJiYgeSA+PSAwKSB7XG4gICAgICBxID0gMTtcbiAgICB9IGVsc2UgaWYgKHggPCAwICYmIHkgPj0gMCkge1xuICAgICAgcSA9IDI7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgcSA9IDM7XG4gICAgfSBlbHNlIGlmICh4ID49IDAgJiYgeSA8IDApIHtcbiAgICAgIHEgPSA0O1xuICAgIH1cblxuICAgIHJldHVybiBxO1xuICB9O1xuXG4gIHJldHVybiBSb3RhdGVQYW5JbnB1dDtcbn0oUGFuSW5wdXQpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBpbmNoSW5wdXRPcHRpb24gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMuUGluY2hJbnB1dCBtb2R1bGVcbiAqIEBrbyBlZy5BeGVzLlBpbmNoSW5wdXQg66qo65OI7J2YIOyYteyFmCDqsJ3ssrRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2NhbGU9MV0gQ29vcmRpbmF0ZSBzY2FsZSB0aGF0IGEgdXNlciBjYW4gbW92ZTxrbz7sgqzsmqnsnpDsnZgg64+Z7J6R7Jy866GcIOydtOuPme2VmOuKlCDsooztkZzsnZgg67Cw7JyoPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGhyZXNob2xkPTBdIE1pbmltYWwgc2NhbGUgYmVmb3JlIHJlY29nbml6aW5nIDxrbz7sgqzsmqnsnpDsnZggUGluY2gg64+Z7J6R7J2EIOyduOyLne2VmOq4sCDsnITtlbTsgrAg7LWc7IaM7ZWc7J2YIOuwsOycqDwva28+XG4gKiBAcHJvcGVydHkge09iamVjdH0gW2hhbW1lck1hbmFnZXJPcHRpb25zPXtjc3NQcm9wczoge3VzZXJTZWxlY3Q6IFwibm9uZVwiLHRvdWNoU2VsZWN0OiBcIm5vbmVcIix0b3VjaENhbGxvdXQ6IFwibm9uZVwiLHVzZXJEcmFnOiBcIm5vbmVcIn1dIE9wdGlvbnMgb2YgSGFtbWVyLk1hbmFnZXIgPGtvPkhhbW1lci5NYW5hZ2Vy7J2YIOyYteyFmDwva28+XG4qKi9cblxuLyoqXG4gKiBAY2xhc3MgZWcuQXhlcy5QaW5jaElucHV0XG4gKiBAY2xhc3NkZXNjIEEgbW9kdWxlIHRoYXQgcGFzc2VzIHRoZSBhbW91bnQgb2YgY2hhbmdlIHRvIGVnLkF4ZXMgd2hlbiB0d28gcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuIHVzZSBvbmUgYXhpcy5cbiAqIEBrbyAy6rCc7J2YIHBvaW50ZXLrpbwg7J207Jqp7ZWY7JesIHpvb20taW7tlZjqsbDrgpggem9vbS1vdXQg7ZWY64qUIOuPmeyekeydmCDrs4DtmZTrn4nsnYQgZWcuQXhlc+yXkCDsoITri6ztlZjripQg66qo65OILiDtlZwg6rCcIOydmCDstpXsnYQg7IKs7Jqp7ZWc64ukLlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHBpbmNoID0gbmV3IGVnLkF4ZXMuUGluY2hJbnB1dChcIiNhcmVhXCIsIHtcbiAqIFx0XHRzY2FsZTogMVxuICogfSk7XG4gKlxuICogLy8gQ29ubmVjdCAnc29tZXRoaW5nJyBheGlzIHdoZW4gdHdvIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogYXhlcy5jb25uZWN0KFwic29tZXRoaW5nXCIsIHBpbmNoKTtcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ3xqUXVlcnl9IGVsZW1lbnQgQW4gZWxlbWVudCB0byB1c2UgdGhlIGVnLkF4ZXMuUGluY2hJbnB1dCBtb2R1bGUgPGtvPmVnLkF4ZXMuUGluY2hJbnB1dCDrqqjrk4jsnYQg7IKs7Jqp7ZWgIOyXmOumrOuovO2KuDwva28+XG4gKiBAcGFyYW0ge1BpbmNoSW5wdXRPcHRpb259IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcy5QaW5jaElucHV0IG1vZHVsZTxrbz5lZy5BeGVzLlBpbmNoSW5wdXQg66qo65OI7J2YIOyYteyFmCDqsJ3ssrQ8L2tvPlxuICovXG5cbnZhciBQaW5jaElucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGluY2hJbnB1dChlbCwgb3B0aW9ucykge1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2Jhc2UgPSBudWxsO1xuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIHRoaXMucGluY2hSZWNvZ25pemVyID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBIYW1tZXIgaGVscHMgeW91IGFkZCBzdXBwb3J0IGZvciB0b3VjaCBnZXN0dXJlcyB0byB5b3VyIHBhZ2VcbiAgICAgKlxuICAgICAqIEBleHRlcm5hbCBIYW1tZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvfEhhbW1lci5KU31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2pzZG9jL0hhbW1lci5odG1sfEhhbW1lci5KUyBBUEkgZG9jdW1lbnRzfVxuICAgICAqIEBzZWUgSGFtbWVyLkpTIGFwcGxpZXMgc3BlY2lmaWMgQ1NTIHByb3BlcnRpZXMgYnkge0BsaW5rIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vanNkb2MvSGFtbWVyLmRlZmF1bHRzLmNzc1Byb3BzLmh0bWx8ZGVmYXVsdH0gd2hlbiBjcmVhdGluZyBhbiBpbnN0YW5jZS4gVGhlIGVnLkF4ZXMgbW9kdWxlIHJlbW92ZXMgYWxsIGRlZmF1bHQgQ1NTIHByb3BlcnRpZXMgcHJvdmlkZWQgYnkgSGFtbWVyLkpTXG4gICAgICovXG5cbiAgICBpZiAodHlwZW9mIE1hbmFnZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBIYW1tZXJqcyBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgZWcuQXhlcy5QaW5jaElucHV0Llxcbmh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudCA9ICQoZWwpO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKHtcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgaW5wdXRUeXBlOiBbXCJ0b3VjaFwiLCBcInBvaW50ZXJcIl0sXG4gICAgICBoYW1tZXJNYW5hZ2VyT3B0aW9uczoge1xuICAgICAgICAvLyBjc3MgcHJvcGVydGllcyB3ZXJlIHJlbW92ZWQgZHVlIHRvIHVzYWJsaWxpdHkgaXNzdWVcbiAgICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9qc2RvYy9IYW1tZXIuZGVmYXVsdHMuY3NzUHJvcHMuaHRtbFxuICAgICAgICBjc3NQcm9wczoge1xuICAgICAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgICAgIHRvdWNoU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgICAgICB0b3VjaENhbGxvdXQ6IFwibm9uZVwiLFxuICAgICAgICAgIHVzZXJEcmFnOiBcIm5vbmVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vblBpbmNoU3RhcnQgPSB0aGlzLm9uUGluY2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25QaW5jaE1vdmUgPSB0aGlzLm9uUGluY2hNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblBpbmNoRW5kID0gdGhpcy5vblBpbmNoRW5kLmJpbmQodGhpcyk7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFBpbmNoSW5wdXQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ubWFwQXhlcyA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgdGhpcy5heGVzID0gYXhlcztcbiAgfTtcblxuICBfX3Byb3RvLmNvbm5lY3QgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICB2YXIgaGFtbWVyT3B0aW9uID0ge1xuICAgICAgdGhyZXNob2xkOiB0aGlzLm9wdGlvbnMudGhyZXNob2xkXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmhhbW1lcikge1xuICAgICAgLy8gZm9yIHNoYXJpbmcgaGFtbWVyIGluc3RhbmNlLlxuICAgICAgLy8gaGFtbWVyIHJlbW92ZSBwcmV2aW91cyBQaW5jaFJlY29nbml6ZXIuXG4gICAgICB0aGlzLnJlbW92ZVJlY29nbml6ZXIoKTtcbiAgICAgIHRoaXMuZGV0dGFjaEV2ZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlWYWx1ZSA9IHRoaXMuZWxlbWVudFtVTklRVUVLRVldO1xuXG4gICAgICBpZiAoIWtleVZhbHVlKSB7XG4gICAgICAgIGtleVZhbHVlID0gU3RyaW5nKE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIG5ldyBEYXRlKCkuZ2V0VGltZSgpKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dENsYXNzID0gY29udmVydElucHV0VHlwZSh0aGlzLm9wdGlvbnMuaW5wdXRUeXBlKTtcblxuICAgICAgaWYgKCFpbnB1dENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0VHlwZSBwYXJhbWV0ZXIhXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhbW1lciA9IGNyZWF0ZUhhbW1lcih0aGlzLmVsZW1lbnQsIF9fYXNzaWduKHtcbiAgICAgICAgaW5wdXRDbGFzczogaW5wdXRDbGFzc1xuICAgICAgfSwgdGhpcy5vcHRpb25zLmhhbW1lck1hbmFnZXJPcHRpb25zKSk7XG4gICAgICB0aGlzLmVsZW1lbnRbVU5JUVVFS0VZXSA9IGtleVZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMucGluY2hSZWNvZ25pemVyID0gbmV3IFBpbmNoKGhhbW1lck9wdGlvbik7XG4gICAgdGhpcy5oYW1tZXIuYWRkKHRoaXMucGluY2hSZWNvZ25pemVyKTtcbiAgICB0aGlzLmF0dGFjaEV2ZW50KG9ic2VydmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW1vdmVSZWNvZ25pemVyKCk7XG5cbiAgICBpZiAodGhpcy5oYW1tZXIpIHtcbiAgICAgIHRoaXMuaGFtbWVyLnJlbW92ZSh0aGlzLnBpbmNoUmVjb2duaXplcik7XG4gICAgICB0aGlzLnBpbmNoUmVjb2duaXplciA9IG51bGw7XG4gICAgICB0aGlzLmRldHRhY2hFdmVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgKiBEZXN0cm95cyBlbGVtZW50cywgcHJvcGVydGllcywgYW5kIGV2ZW50cyB1c2VkIGluIGEgbW9kdWxlLlxuICAqIEBrbyDrqqjrk4jsl5Ag7IKs7Jqp7ZWcIOyXmOumrOuovO2KuOyZgCDsho3shLEsIOydtOuypO2KuOulvCDtlbTsoJztlZzri6QuXG4gICogQG1ldGhvZCBlZy5BeGVzLlBpbmNoSW5wdXQjZGVzdHJveVxuICAqL1xuXG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgaWYgKHRoaXMuaGFtbWVyICYmIHRoaXMuaGFtbWVyLnJlY29nbml6ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnRbVU5JUVVFS0VZXTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLnJlbW92ZVJlY29nbml6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaGFtbWVyICYmIHRoaXMucGluY2hSZWNvZ25pemVyKSB7XG4gICAgICB0aGlzLmhhbW1lci5yZW1vdmUodGhpcy5waW5jaFJlY29nbml6ZXIpO1xuICAgICAgdGhpcy5waW5jaFJlY29nbml6ZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2Jhc2UgPSB0aGlzLm9ic2VydmVyLmdldCh0aGlzKVt0aGlzLmF4ZXNbMF1dO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLmdldE9mZnNldChldmVudC5zY2FsZSk7XG4gICAgdGhpcy5vYnNlcnZlci5ob2xkKHRoaXMsIGV2ZW50KTtcbiAgICB0aGlzLm9ic2VydmVyLmNoYW5nZSh0aGlzLCBldmVudCwgdG9BeGlzKHRoaXMuYXhlcywgW29mZnNldF0pKTtcbiAgICB0aGlzLl9wcmV2ID0gZXZlbnQuc2NhbGU7XG4gIH07XG5cbiAgX19wcm90by5vblBpbmNoTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLmdldE9mZnNldChldmVudC5zY2FsZSwgdGhpcy5fcHJldik7XG4gICAgdGhpcy5vYnNlcnZlci5jaGFuZ2UodGhpcywgZXZlbnQsIHRvQXhpcyh0aGlzLmF4ZXMsIFtvZmZzZXRdKSk7XG4gICAgdGhpcy5fcHJldiA9IGV2ZW50LnNjYWxlO1xuICB9O1xuXG4gIF9fcHJvdG8ub25QaW5jaEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLmdldE9mZnNldChldmVudC5zY2FsZSwgdGhpcy5fcHJldik7XG4gICAgdGhpcy5vYnNlcnZlci5jaGFuZ2UodGhpcywgZXZlbnQsIHRvQXhpcyh0aGlzLmF4ZXMsIFtvZmZzZXRdKSk7XG4gICAgdGhpcy5vYnNlcnZlci5yZWxlYXNlKHRoaXMsIGV2ZW50LCB0b0F4aXModGhpcy5heGVzLCBbMF0pLCAwKTtcbiAgICB0aGlzLl9iYXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLmdldE9mZnNldCA9IGZ1bmN0aW9uIChwaW5jaFNjYWxlLCBwcmV2KSB7XG4gICAgaWYgKHByZXYgPT09IHZvaWQgMCkge1xuICAgICAgcHJldiA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2UgKiAocGluY2hTY2FsZSAtIHByZXYpICogdGhpcy5vcHRpb25zLnNjYWxlO1xuICB9O1xuXG4gIF9fcHJvdG8uYXR0YWNoRXZlbnQgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5oYW1tZXIub24oXCJwaW5jaHN0YXJ0XCIsIHRoaXMub25QaW5jaFN0YXJ0KS5vbihcInBpbmNobW92ZVwiLCB0aGlzLm9uUGluY2hNb3ZlKS5vbihcInBpbmNoZW5kXCIsIHRoaXMub25QaW5jaEVuZCk7XG4gIH07XG5cbiAgX19wcm90by5kZXR0YWNoRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYW1tZXIub2ZmKFwicGluY2hzdGFydFwiLCB0aGlzLm9uUGluY2hTdGFydCkub2ZmKFwicGluY2htb3ZlXCIsIHRoaXMub25QaW5jaE1vdmUpLm9mZihcInBpbmNoZW5kXCIsIHRoaXMub25QaW5jaEVuZCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBFbmFibGVzIGlucHV0IGRldmljZXNcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7Jqp7ZWgIOyImCDsnojqsowg7ZWc64ukXG4gICAqIEBtZXRob2QgZWcuQXhlcy5QaW5jaElucHV0I2VuYWJsZVxuICAgKiBAcmV0dXJuIHtlZy5BeGVzLlBpbmNoSW5wdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFtbWVyICYmICh0aGlzLmhhbW1lci5nZXQoXCJwaW5jaFwiKS5vcHRpb25zLmVuYWJsZSA9IHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGlzYWJsZXMgaW5wdXQgZGV2aWNlc1xuICAgKiBAa28g7J6F66ClIOyepey5mOulvCDsgqzsmqntlaAg7IiYIOyXhuqyjCDtlZzri6QuXG4gICAqIEBtZXRob2QgZWcuQXhlcy5QaW5jaElucHV0I2Rpc2FibGVcbiAgICogQHJldHVybiB7ZWcuQXhlcy5QaW5jaElucHV0fSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICovXG5cblxuICBfX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYW1tZXIgJiYgKHRoaXMuaGFtbWVyLmdldChcInBpbmNoXCIpLm9wdGlvbnMuZW5hYmxlID0gZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRvIHVzZSBhbiBpbnB1dCBkZXZpY2VcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7JqpIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAqIEBtZXRob2QgZWcuQXhlcy5QaW5jaElucHV0I2lzRW5hYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdG8gdXNlIGFuIGlucHV0IGRldmljZSA8a28+7J6F66Cl7J6l7LmYIOyCrOyaqeyXrOu2gDwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5pc0VuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEodGhpcy5oYW1tZXIgJiYgdGhpcy5oYW1tZXIuZ2V0KFwicGluY2hcIikub3B0aW9ucy5lbmFibGUpO1xuICB9O1xuXG4gIHJldHVybiBQaW5jaElucHV0O1xufSgpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdoZWVsSW5wdXRPcHRpb24gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMuV2hlZWxJbnB1dCBtb2R1bGVcbiAqIEBrbyBlZy5BeGVzLldoZWVsSW5wdXQg66qo65OI7J2YIOyYteyFmCDqsJ3ssrRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2NhbGU9MV0gQ29vcmRpbmF0ZSBzY2FsZSB0aGF0IGEgdXNlciBjYW4gbW92ZTxrbz7sgqzsmqnsnpDsnZgg64+Z7J6R7Jy866GcIOydtOuPme2VmOuKlCDsooztkZzsnZgg67Cw7JyoPC9rbz5cbioqL1xuXG4vKipcbiAqIEBjbGFzcyBlZy5BeGVzLldoZWVsSW5wdXRcbiAqIEBjbGFzc2Rlc2MgQSBtb2R1bGUgdGhhdCBwYXNzZXMgdGhlIGFtb3VudCBvZiBjaGFuZ2UgdG8gZWcuQXhlcyB3aGVuIHRoZSBtb3VzZSB3aGVlbCBpcyBtb3ZlZC4gdXNlIG9uZSBheGlzLlxuICogQGtvIOuniOyasOyKpCDtnKDsnbQg7JuA7KeB7J2865WM7J2YIOuzgO2ZlOufieydhCBlZy5BeGVz7JeQIOyghOuLrO2VmOuKlCDrqqjrk4guIO2VnCDqsJwg7J2YIOy2leydhCDsgqzsmqntlZzri6QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHdoZWVsID0gbmV3IGVnLkF4ZXMuV2hlZWxJbnB1dChcIiNhcmVhXCIsIHtcbiAqIFx0XHRzY2FsZTogMVxuICogfSk7XG4gKlxuICogLy8gQ29ubmVjdCAnc29tZXRoaW5nJyBheGlzIHdoZW4gdGhlIG1vdXNld2hlZWwgaXMgbW92ZWQuXG4gKiBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmdcIiwgd2hlZWwpO1xuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfGpRdWVyeX0gZWxlbWVudCBBbiBlbGVtZW50IHRvIHVzZSB0aGUgZWcuQXhlcy5XaGVlbElucHV0IG1vZHVsZSA8a28+ZWcuQXhlcy5XaGVlbElucHV0IOuqqOuTiOydhCDsgqzsmqntlaAg7JeY66as66i87Yq4PC9rbz5cbiAqIEBwYXJhbSB7V2hlZWxJbnB1dE9wdGlvbn0gW29wdGlvbnNdIFRoZSBvcHRpb24gb2JqZWN0IG9mIHRoZSBlZy5BeGVzLldoZWVsSW5wdXQgbW9kdWxlPGtvPmVnLkF4ZXMuV2hlZWxJbnB1dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKi9cblxudmFyIFdoZWVsSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXaGVlbElucHV0KGVsLCBvcHRpb25zKSB7XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0hvbGRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBzY2FsZTogMSxcbiAgICAgIHVzZU5vcm1hbGl6ZWQ6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLm9uV2hlZWwgPSB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gV2hlZWxJbnB1dC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5tYXBBeGVzID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICB0aGlzLmF4ZXMgPSBheGVzO1xuICB9O1xuXG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIHRoaXMuZGV0dGFjaEV2ZW50KCk7XG4gICAgdGhpcy5hdHRhY2hFdmVudChvYnNlcnZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGV0dGFjaEV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAqIERlc3Ryb3lzIGVsZW1lbnRzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzIHVzZWQgaW4gYSBtb2R1bGUuXG4gICogQGtvIOuqqOuTiOyXkCDsgqzsmqntlZwg7JeY66as66i87Yq47JmAIOyGjeyEsSwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkF4ZXMuV2hlZWxJbnB1dCNkZXN0cm95XG4gICovXG5cblxuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLm9uV2hlZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGV2ZW50LmRlbHRhWSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faXNIb2xkZWQpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuaG9sZCh0aGlzLCBldmVudCk7XG4gICAgICB0aGlzLl9pc0hvbGRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IChldmVudC5kZWx0YVkgPiAwID8gLTEgOiAxKSAqIHRoaXMub3B0aW9ucy5zY2FsZSAqICh0aGlzLm9wdGlvbnMudXNlTm9ybWFsaXplZCA/IDEgOiBNYXRoLmFicyhldmVudC5kZWx0YVkpKTtcbiAgICB0aGlzLm9ic2VydmVyLmNoYW5nZSh0aGlzLCBldmVudCwgdG9BeGlzKHRoaXMuYXhlcywgW29mZnNldF0pKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuX2lzSG9sZGVkKSB7XG4gICAgICAgIF90aGlzLl9pc0hvbGRlZCA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLm9ic2VydmVyLnJlbGVhc2UoX3RoaXMsIGV2ZW50LCB0b0F4aXMoX3RoaXMuYXhlcywgWzBdKSk7XG4gICAgICB9XG4gICAgfSwgNTApO1xuICB9O1xuXG4gIF9fcHJvdG8uYXR0YWNoRXZlbnQgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwpO1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gIH07XG5cbiAgX19wcm90by5kZXR0YWNoRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwpO1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEVuYWJsZXMgaW5wdXQgZGV2aWNlc1xuICAgKiBAa28g7J6F66ClIOyepey5mOulvCDsgqzsmqntlaAg7IiYIOyeiOqyjCDtlZzri6RcbiAgICogQG1ldGhvZCBlZy5BeGVzLldoZWVsSW5wdXQjZW5hYmxlXG4gICAqIEByZXR1cm4ge2VnLkF4ZXMuV2hlZWxJbnB1dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERpc2FibGVzIGlucHV0IGRldmljZXNcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7Jqp7ZWgIOyImCDsl4bqsowg7ZWc64ukLlxuICAgKiBAbWV0aG9kIGVnLkF4ZXMuV2hlZWxJbnB1dCNkaXNhYmxlXG4gICAqIEByZXR1cm4ge2VnLkF4ZXMuV2hlZWxJbnB1dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRvIHVzZSBhbiBpbnB1dCBkZXZpY2VcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7JqpIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAqIEBtZXRob2QgZWcuQXhlcy5XaGVlbElucHV0I2lzRW5hYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdG8gdXNlIGFuIGlucHV0IGRldmljZSA8a28+7J6F66Cl7J6l7LmYIOyCrOyaqeyXrOu2gDwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5pc0VuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNFbmFibGVkO1xuICB9O1xuXG4gIHJldHVybiBXaGVlbElucHV0O1xufSgpO1xuXG52YXIgS0VZX0xFRlRfQVJST1cgPSAzNztcbnZhciBLRVlfQSA9IDY1O1xudmFyIEtFWV9VUF9BUlJPVyA9IDM4O1xudmFyIEtFWV9XID0gODc7XG52YXIgS0VZX1JJR0hUX0FSUk9XID0gMzk7XG52YXIgS0VZX0QgPSA2ODtcbnZhciBLRVlfRE9XTl9BUlJPVyA9IDQwO1xudmFyIEtFWV9TID0gODM7XG52YXIgRElSRUNUSU9OX1JFVkVSU0UgPSAtMTtcbnZhciBESVJFQ1RJT05fRk9SV0FSRCA9IDE7XG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwkMSA9IC0xO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCQxID0gMTtcbnZhciBERUxBWSA9IDgwO1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNb3ZlS2V5SW5wdXRPcHRpb24gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMuTW92ZUtleUlucHV0IG1vZHVsZVxuICogQGtvIGVnLkF4ZXMuTW92ZUtleUlucHV0IOuqqOuTiOydmCDsmLXshZgg6rCd7LK0XG4gKiBAcHJvcGVydHkge0FycmF5PE51bWJlcj59IFtzY2FsZV0gQ29vcmRpbmF0ZSBzY2FsZSB0aGF0IGEgdXNlciBjYW4gbW92ZTxrbz7sgqzsmqnsnpDsnZgg64+Z7J6R7Jy866GcIOydtOuPme2VmOuKlCDsooztkZzsnZgg67Cw7JyoPC9rbz5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2NhbGVbMF09MV0gQ29vcmRpbmF0ZSBzY2FsZSBmb3IgdGhlIGZpcnN0IGF4aXM8a28+7LKr67KI7Ke4IOy2leydmCDrsLDsnKg8L2tvPlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzY2FsZVsxXT0xXSBDb29yZGluYXRlIHNjYWxlIGZvciB0aGUgZGVjb25kIGF4aXM8a28+65GQ67KI7Ke4IOy2leydmCDrsLDsnKg8L2tvPlxuKiovXG5cbi8qKlxuICogQGNsYXNzIGVnLkF4ZXMuTW92ZUtleUlucHV0XG4gKiBAY2xhc3NkZXNjIEEgbW9kdWxlIHRoYXQgcGFzc2VzIHRoZSBhbW91bnQgb2YgY2hhbmdlIHRvIGVnLkF4ZXMgd2hlbiB0aGUgbW92ZSBrZXkgc3Ryb2tlIGlzIG9jY3VyZWQuIHVzZSB0d28gYXhpcy5cbiAqIEBrbyDsnbTrj5ntgqQg7J6F66Cl7J20IOuwnOyDne2WiOydhCDrlYzsnZgg67OA7ZmU65+J7J2EIGVnLkF4ZXPsl5Ag7KCE64us7ZWY64qUIOuqqOuTiC4g65GQIOqwnCDsnZgg7LaV7J2EIOyCrOyaqe2VnOuLpC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbW92ZUtleSA9IG5ldyBlZy5BeGVzLk1vdmVLZXlJbnB1dChcIiNhcmVhXCIsIHtcbiAqIFx0XHRzY2FsZTogWzEsIDFdXG4gKiB9KTtcbiAqXG4gKiAvLyBDb25uZWN0ICd4JywgJ3knIGF4ZXMgd2hlbiB0aGUgbW92ZUtleSBpcyBwcmVzc2VkLlxuICogYXhlcy5jb25uZWN0KFtcInhcIiwgXCJ5XCJdLCBtb3ZlS2V5KTtcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ3xqUXVlcnl9IGVsZW1lbnQgQW4gZWxlbWVudCB0byB1c2UgdGhlIGVnLkF4ZXMuTW92ZUtleUlucHV0IG1vZHVsZSA8a28+ZWcuQXhlcy5Nb3ZlS2V5SW5wdXQg66qo65OI7J2EIOyCrOyaqe2VoCDsl5jrpqzrqLztirg8L2tvPlxuICogQHBhcmFtIHtNb3ZlS2V5SW5wdXRPcHRpb259IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcy5Nb3ZlS2V5SW5wdXQgbW9kdWxlPGtvPmVnLkF4ZXMuTW92ZUtleUlucHV0IOuqqOuTiOydmCDsmLXshZgg6rCd7LK0PC9rbz5cbiAqL1xuXG52YXIgTW92ZUtleUlucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW92ZUtleUlucHV0KGVsLCBvcHRpb25zKSB7XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0hvbGRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBzY2FsZTogWzEsIDFdXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbktleWRvd24gPSB0aGlzLm9uS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25LZXl1cCA9IHRoaXMub25LZXl1cC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBNb3ZlS2V5SW5wdXQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ubWFwQXhlcyA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgdGhpcy5heGVzID0gYXhlcztcbiAgfTtcblxuICBfX3Byb3RvLmNvbm5lY3QgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLmRldHRhY2hFdmVudCgpOyAvLyBhZGQgdGFiaW5kZXg9XCIwXCIgdG8gdGhlIGNvbnRhaW5lciBmb3IgbWFraW5nIGl0IGZvY3VzYWJsZVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSAhPT0gXCIwXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgfVxuXG4gICAgdGhpcy5hdHRhY2hFdmVudChvYnNlcnZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGV0dGFjaEV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAqIERlc3Ryb3lzIGVsZW1lbnRzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzIHVzZWQgaW4gYSBtb2R1bGUuXG4gICogQGtvIOuqqOuTiOyXkCDsgqzsmqntlZwg7JeY66as66i87Yq47JmAIOyGjeyEsSwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkF4ZXMuTW92ZUtleUlucHV0I2Rlc3Ryb3lcbiAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8ub25LZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc01vdmVLZXkgPSB0cnVlO1xuICAgIHZhciBkaXJlY3Rpb24gPSBESVJFQ1RJT05fRk9SV0FSRDtcbiAgICB2YXIgbW92ZSA9IERJUkVDVElPTl9IT1JJWk9OVEFMJDE7XG5cbiAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgY2FzZSBLRVlfTEVGVF9BUlJPVzpcbiAgICAgIGNhc2UgS0VZX0E6XG4gICAgICAgIGRpcmVjdGlvbiA9IERJUkVDVElPTl9SRVZFUlNFO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfUklHSFRfQVJST1c6XG4gICAgICBjYXNlIEtFWV9EOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfRE9XTl9BUlJPVzpcbiAgICAgIGNhc2UgS0VZX1M6XG4gICAgICAgIGRpcmVjdGlvbiA9IERJUkVDVElPTl9SRVZFUlNFO1xuICAgICAgICBtb3ZlID0gRElSRUNUSU9OX1ZFUlRJQ0FMJDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEtFWV9VUF9BUlJPVzpcbiAgICAgIGNhc2UgS0VZX1c6XG4gICAgICAgIG1vdmUgPSBESVJFQ1RJT05fVkVSVElDQUwkMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlzTW92ZUtleSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChtb3ZlID09PSBESVJFQ1RJT05fSE9SSVpPTlRBTCQxICYmICF0aGlzLmF4ZXNbMF0gfHwgbW92ZSA9PT0gRElSRUNUSU9OX1ZFUlRJQ0FMJDEgJiYgIXRoaXMuYXhlc1sxXSkge1xuICAgICAgaXNNb3ZlS2V5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc01vdmVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IG1vdmUgPT09IERJUkVDVElPTl9IT1JJWk9OVEFMJDEgPyBbK3RoaXMub3B0aW9ucy5zY2FsZVswXSAqIGRpcmVjdGlvbiwgMF0gOiBbMCwgK3RoaXMub3B0aW9ucy5zY2FsZVsxXSAqIGRpcmVjdGlvbl07XG5cbiAgICBpZiAoIXRoaXMuX2lzSG9sZGVkKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLmhvbGQodGhpcywgZXZlbnQpO1xuICAgICAgdGhpcy5faXNIb2xkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgdGhpcy5vYnNlcnZlci5jaGFuZ2UodGhpcywgZXZlbnQsIHRvQXhpcyh0aGlzLmF4ZXMsIG9mZnNldHMpKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uS2V5dXAgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuX2lzSG9sZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub2JzZXJ2ZXIucmVsZWFzZShfdGhpcywgZSwgdG9BeGlzKF90aGlzLmF4ZXMsIFswLCAwXSkpO1xuXG4gICAgICBfdGhpcy5faXNIb2xkZWQgPSBmYWxzZTtcbiAgICB9LCBERUxBWSk7XG4gIH07XG5cbiAgX19wcm90by5hdHRhY2hFdmVudCA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleWRvd24sIGZhbHNlKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIHRoaXMub25LZXlkb3duLCBmYWxzZSk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLm9uS2V5dXAsIGZhbHNlKTtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uZGV0dGFjaEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5ZG93biwgZmFsc2UpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgdGhpcy5vbktleWRvd24sIGZhbHNlKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXl1cCwgZmFsc2UpO1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyBpbnB1dCBkZXZpY2VzXG4gICAqIEBrbyDsnoXroKUg7J6l7LmY66W8IOyCrOyaqe2VoCDsiJgg7J6I6rKMIO2VnOuLpFxuICAgKiBAbWV0aG9kIGVnLkF4ZXMuTW92ZUtleUlucHV0I2VuYWJsZVxuICAgKiBAcmV0dXJuIHtlZy5BeGVzLk1vdmVLZXlJbnB1dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERpc2FibGVzIGlucHV0IGRldmljZXNcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7Jqp7ZWgIOyImCDsl4bqsowg7ZWc64ukLlxuICAgKiBAbWV0aG9kIGVnLkF4ZXMuTW92ZUtleUlucHV0I2Rpc2FibGVcbiAgICogQHJldHVybiB7ZWcuQXhlcy5Nb3ZlS2V5SW5wdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0byB1c2UgYW4gaW5wdXQgZGV2aWNlXG4gICAqIEBrbyDsnoXroKUg7J6l7LmY66W8IOyCrOyaqSDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLlxuICAgKiBAbWV0aG9kIGVnLkF4ZXMuTW92ZUtleUlucHV0I2lzRW5hYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdG8gdXNlIGFuIGlucHV0IGRldmljZSA8a28+7J6F66Cl7J6l7LmYIOyCrOyaqeyXrOu2gDwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5pc0VuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNFbmFibGVkO1xuICB9O1xuXG4gIHJldHVybiBNb3ZlS2V5SW5wdXQ7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4ZXM7XG5leHBvcnQgeyBQYW5JbnB1dCwgUm90YXRlUGFuSW5wdXQsIFBpbmNoSW5wdXQsIFdoZWVsSW5wdXQsIE1vdmVLZXlJbnB1dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXhlcy5lc20uanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@egjs/axes/dist/axes.esm.js\n')},"./node_modules/@egjs/axes/node_modules/@egjs/component/dist/component.esm.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@egjs/axes/node_modules/@egjs/component/dist/component.esm.js ***!
  \************************************************************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/*\nCopyright (c) NAVER Corp.\nname: @egjs/component\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-component\nversion: 2.2.2\n*/\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nfunction __values(o) {\n  var s = typeof Symbol === "function" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === "number") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nfunction isUndefined(value) {\n  return typeof value === "undefined";\n}\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n * @alias eg.Component\n */\n\n\nvar Component =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}\n   */\n  function Component() {\n    /**\n     * @deprecated\n     * @private\n     */\n    this.options = {};\n    this._eventHandler = {};\n  }\n  /**\n   * Triggers a custom event.\n   * @ko 커스텀 이벤트를 발생시킨다\n   * @param {string} eventName The name of the custom event to be triggered <ko>발생할 커스텀 이벤트의 이름</ko>\n   * @param {object} customEvent Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n   * @param {any[]} restParam Additional parameters when triggering a custom event <ko>커스텀 이벤트가 발생할 때 필요시 추가적으로 전달할 데이터</ko>\n   * @return Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <a href="https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F">Ref</a> <ko>이벤트 발생 여부. 커스텀 이벤트 핸들러에서 stop() 메서드를 호출하면 \'false\'를 반환하고 이벤트 발생을 중단한다. <a href="https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F">참고</a></ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   some(){\n   *     if(this.trigger("beforeHi")){ // When event call to stop return false.\n   *       this.trigger("hi");// fire hi event.\n   *     }\n   *   }\n   * }\n   *\n   * const some = new Some();\n   * some.on("beforeHi", (e) => {\n   *   if(condition){\n   *     e.stop(); // When event call to stop, `hi` event not call.\n   *   }\n   * });\n   * some.on("hi", (e) => {\n   *   // `currentTarget` is component instance.\n   *   console.log(some === e.currentTarget); // true\n   * });\n   * // If you want to more know event design. You can see article.\n   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n   * ```\n   */\n\n\n  var __proto = Component.prototype;\n\n  __proto.trigger = function (eventName) {\n    var _this = this;\n\n    var params = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      params[_i - 1] = arguments[_i];\n    }\n\n    var handlerList = this._eventHandler[eventName] || [];\n    var hasHandlerList = handlerList.length > 0;\n\n    if (!hasHandlerList) {\n      return true;\n    }\n\n    var customEvent = params[0] || {};\n    var restParams = params.slice(1); // If detach method call in handler in first time then handler list calls.\n\n    handlerList = handlerList.concat();\n    var isCanceled = false; // This should be done like this to pass previous tests\n\n    customEvent.eventType = eventName;\n\n    customEvent.stop = function () {\n      isCanceled = true;\n    };\n\n    customEvent.currentTarget = this;\n    var arg = [customEvent];\n\n    if (restParams.length >= 1) {\n      arg = arg.concat(restParams);\n    }\n\n    handlerList.forEach(function (handler) {\n      handler.apply(_this, arg);\n    });\n    return !isCanceled;\n  };\n  /**\n   * Executed event just one time.\n   * @ko 이벤트가 한번만 실행된다.\n   * @param {string} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   * hi() {\n   *   alert("hi");\n   * }\n   * thing() {\n   *   this.once("hi", this.hi);\n   * }\n   *\n   * var some = new Some();\n   * some.thing();\n   * some.trigger("hi");\n   * // fire alert("hi");\n   * some.trigger("hi");\n   * // Nothing happens\n   * ```\n   */\n\n\n  __proto.once = function (eventName, handlerToAttach) {\n    var _this = this;\n\n    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {\n      var eventHash = eventName;\n\n      for (var key in eventHash) {\n        this.once(key, eventHash[key]);\n      }\n\n      return this;\n    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {\n      var listener_1 = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        handlerToAttach.apply(_this, args);\n\n        _this.off(eventName, listener_1);\n      };\n\n      this.on(eventName, listener_1);\n    }\n\n    return this;\n  };\n  /**\n   * Checks whether an event has been attached to a component.\n   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   some() {\n   *     this.hasOn("hi");// check hi event.\n   *   }\n   * }\n   * ```\n   */\n\n\n  __proto.hasOn = function (eventName) {\n    return !!this._eventHandler[eventName];\n  };\n  /**\n   * Attaches an event to a component.\n   * @ko 컴포넌트에 이벤트를 등록한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   hi() {\n   *     console.log("hi");\n   *   }\n   *   some() {\n   *     this.on("hi",this.hi); //attach event\n   *   }\n   * }\n   * ```\n   */\n\n\n  __proto.on = function (eventName, handlerToAttach) {\n    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {\n      var eventHash = eventName;\n\n      for (var name in eventHash) {\n        this.on(name, eventHash[name]);\n      }\n\n      return this;\n    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {\n      var handlerList = this._eventHandler[eventName];\n\n      if (isUndefined(handlerList)) {\n        this._eventHandler[eventName] = [];\n        handlerList = this._eventHandler[eventName];\n      }\n\n      handlerList.push(handlerToAttach);\n    }\n\n    return this;\n  };\n  /**\n   * Detaches an event from the component.\n   * @ko 컴포넌트에 등록된 이벤트를 해제한다\n   * @param {string} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n   * @param {function} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   hi() {\n   *     console.log("hi");\n   *   }\n   *   some() {\n   *     this.off("hi",this.hi); //detach event\n   *   }\n   * }\n   * ```\n   */\n\n\n  __proto.off = function (eventName, handlerToDetach) {\n    var e_1, _a; // Detach all event handlers.\n\n\n    if (isUndefined(eventName)) {\n      this._eventHandler = {};\n      return this;\n    } // Detach all handlers for eventname or detach event handlers by object.\n\n\n    if (isUndefined(handlerToDetach)) {\n      if (typeof eventName === "string") {\n        delete this._eventHandler[eventName];\n        return this;\n      } else {\n        var eventHash = eventName;\n\n        for (var name in eventHash) {\n          this.off(name, eventHash[name]);\n        }\n\n        return this;\n      }\n    } // Detach single event handler\n\n\n    var handlerList = this._eventHandler[eventName];\n\n    if (handlerList) {\n      var idx = 0;\n\n      try {\n        for (var handlerList_1 = __values(handlerList), handlerList_1_1 = handlerList_1.next(); !handlerList_1_1.done; handlerList_1_1 = handlerList_1.next()) {\n          var handlerFunction = handlerList_1_1.value;\n\n          if (handlerFunction === handlerToDetach) {\n            handlerList.splice(idx, 1);\n            break;\n          }\n\n          idx++;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (handlerList_1_1 && !handlerList_1_1.done && (_a = handlerList_1.return)) _a.call(handlerList_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @example\n   * eg.Component.VERSION;  // ex) 2.0.0\n   * @memberof eg.Component\n   */\n\n\n  Component.VERSION = "2.2.2";\n  return Component;\n}();\n\n/* harmony default export */ __webpack_exports__["default"] = (Component);\n//# sourceMappingURL=component.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvYXhlcy9ub2RlX21vZHVsZXMvQGVnanMvY29tcG9uZW50L2Rpc3QvY29tcG9uZW50LmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZWdqcy9heGVzL25vZGVfbW9kdWxlcy9AZWdqcy9jb21wb25lbnQvZGlzdC9jb21wb25lbnQuZXNtLmpzPzg1NWIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2NvbXBvbmVudFxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnRcbnZlcnNpb246IDIuMi4yXG4qL1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgbSA9IHMgJiYgb1tzXSxcbiAgICAgIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgIGRvbmU6ICFvXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufVxuLyoqXG4gKiBBIGNsYXNzIHVzZWQgdG8gbWFuYWdlIGV2ZW50cyBpbiBhIGNvbXBvbmVudFxuICogQGtvIOy7tO2PrOuEjO2KuOydmCDsnbTrsqTtirjsnYQg6rSA66as7ZWgIOyImCDsnojqsowg7ZWY64qUIO2BtOuemOyKpFxuICogQGFsaWFzIGVnLkNvbXBvbmVudFxuICovXG5cblxudmFyIENvbXBvbmVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAc3VwcG9ydCB7XCJpZVwiOiBcIjcrXCIsIFwiY2hcIiA6IFwibGF0ZXN0XCIsIFwiZmZcIiA6IFwibGF0ZXN0XCIsICBcInNmXCIgOiBcImxhdGVzdFwiLCBcImVkZ2VcIiA6IFwibGF0ZXN0XCIsIFwiaW9zXCIgOiBcIjcrXCIsIFwiYW5cIiA6IFwiMi4xKyAoZXhjZXB0IDMueClcIn1cbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudCgpIHtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgY3VzdG9tIGV2ZW50LlxuICAgKiBAa28g7Luk7Iqk7YWAIOydtOuypO2KuOulvCDrsJzsg53si5ztgqjri6RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IHRvIGJlIHRyaWdnZXJlZCA8a28+67Cc7IOd7ZWgIOy7pOyKpO2FgCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHBhcmFtIHtvYmplY3R9IGN1c3RvbUV2ZW50IEV2ZW50IGRhdGEgdG8gYmUgc2VudCB3aGVuIHRyaWdnZXJpbmcgYSBjdXN0b20gZXZlbnQgPGtvPuy7pOyKpO2FgCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWgIOuVjCDsoITri6ztlaAg642w7J207YSwPC9rbz5cbiAgICogQHBhcmFtIHthbnlbXX0gcmVzdFBhcmFtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aGVuIHRyaWdnZXJpbmcgYSBjdXN0b20gZXZlbnQgPGtvPuy7pOyKpO2FgCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWgIOuVjCDtlYTsmpTsi5wg7LaU6rCA7KCB7Jy866GcIOyghOuLrO2VoCDrjbDsnbTthLA8L2tvPlxuICAgKiBAcmV0dXJuIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCBoYXMgb2NjdXJyZWQuIElmIHRoZSBzdG9wKCkgbWV0aG9kIGlzIGNhbGxlZCBieSBhIGN1c3RvbSBldmVudCBoYW5kbGVyLCBpdCB3aWxsIHJldHVybiBmYWxzZSBhbmQgcHJldmVudCB0aGUgZXZlbnQgZnJvbSBvY2N1cnJpbmcuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnQvd2lraS9Ib3ctdG8tbWFrZS1Db21wb25lbnQtZXZlbnQtZGVzaWduJTNGXCI+UmVmPC9hPiA8a28+7J2067Kk7Yq4IOuwnOyDnSDsl6zrtoAuIOy7pOyKpO2FgCDsnbTrsqTtirgg7ZW465Ok65+s7JeQ7IScIHN0b3AoKSDrqZTshJzrk5zrpbwg7Zi47Lac7ZWY66m0ICdmYWxzZSfrpbwg67CY7ZmY7ZWY6rOgIOydtOuypO2KuCDrsJzsg53snYQg7KSR64uo7ZWc64ukLiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29tcG9uZW50L3dpa2kvSG93LXRvLW1ha2UtQ29tcG9uZW50LWV2ZW50LWRlc2lnbiUzRlwiPuywuOqzoDwvYT48L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIGVnLkNvbXBvbmVudCB7XG4gICAqICAgc29tZSgpe1xuICAgKiAgICAgaWYodGhpcy50cmlnZ2VyKFwiYmVmb3JlSGlcIikpeyAvLyBXaGVuIGV2ZW50IGNhbGwgdG8gc3RvcCByZXR1cm4gZmFsc2UuXG4gICAqICAgICAgIHRoaXMudHJpZ2dlcihcImhpXCIpOy8vIGZpcmUgaGkgZXZlbnQuXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHNvbWUgPSBuZXcgU29tZSgpO1xuICAgKiBzb21lLm9uKFwiYmVmb3JlSGlcIiwgKGUpID0+IHtcbiAgICogICBpZihjb25kaXRpb24pe1xuICAgKiAgICAgZS5zdG9wKCk7IC8vIFdoZW4gZXZlbnQgY2FsbCB0byBzdG9wLCBgaGlgIGV2ZW50IG5vdCBjYWxsLlxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIHNvbWUub24oXCJoaVwiLCAoZSkgPT4ge1xuICAgKiAgIC8vIGBjdXJyZW50VGFyZ2V0YCBpcyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqICAgY29uc29sZS5sb2coc29tZSA9PT0gZS5jdXJyZW50VGFyZ2V0KTsgLy8gdHJ1ZVxuICAgKiB9KTtcbiAgICogLy8gSWYgeW91IHdhbnQgdG8gbW9yZSBrbm93IGV2ZW50IGRlc2lnbi4gWW91IGNhbiBzZWUgYXJ0aWNsZS5cbiAgICogLy8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29tcG9uZW50L3dpa2kvSG93LXRvLW1ha2UtQ29tcG9uZW50LWV2ZW50LWRlc2lnbiUzRlxuICAgKiBgYGBcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgX19wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdIHx8IFtdO1xuICAgIHZhciBoYXNIYW5kbGVyTGlzdCA9IGhhbmRsZXJMaXN0Lmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoIWhhc0hhbmRsZXJMaXN0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY3VzdG9tRXZlbnQgPSBwYXJhbXNbMF0gfHwge307XG4gICAgdmFyIHJlc3RQYXJhbXMgPSBwYXJhbXMuc2xpY2UoMSk7IC8vIElmIGRldGFjaCBtZXRob2QgY2FsbCBpbiBoYW5kbGVyIGluIGZpcnN0IHRpbWUgdGhlbiBoYW5kbGVyIGxpc3QgY2FsbHMuXG5cbiAgICBoYW5kbGVyTGlzdCA9IGhhbmRsZXJMaXN0LmNvbmNhdCgpO1xuICAgIHZhciBpc0NhbmNlbGVkID0gZmFsc2U7IC8vIFRoaXMgc2hvdWxkIGJlIGRvbmUgbGlrZSB0aGlzIHRvIHBhc3MgcHJldmlvdXMgdGVzdHNcblxuICAgIGN1c3RvbUV2ZW50LmV2ZW50VHlwZSA9IGV2ZW50TmFtZTtcblxuICAgIGN1c3RvbUV2ZW50LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY3VzdG9tRXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgdmFyIGFyZyA9IFtjdXN0b21FdmVudF07XG5cbiAgICBpZiAocmVzdFBhcmFtcy5sZW5ndGggPj0gMSkge1xuICAgICAgYXJnID0gYXJnLmNvbmNhdChyZXN0UGFyYW1zKTtcbiAgICB9XG5cbiAgICBoYW5kbGVyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyLmFwcGx5KF90aGlzLCBhcmcpO1xuICAgIH0pO1xuICAgIHJldHVybiAhaXNDYW5jZWxlZDtcbiAgfTtcbiAgLyoqXG4gICAqIEV4ZWN1dGVkIGV2ZW50IGp1c3Qgb25lIHRpbWUuXG4gICAqIEBrbyDsnbTrsqTtirjqsIAg7ZWc67KI66eMIOyLpO2WieuQnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclRvQXR0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIGVnLkNvbXBvbmVudCB7XG4gICAqIGhpKCkge1xuICAgKiAgIGFsZXJ0KFwiaGlcIik7XG4gICAqIH1cbiAgICogdGhpbmcoKSB7XG4gICAqICAgdGhpcy5vbmNlKFwiaGlcIiwgdGhpcy5oaSk7XG4gICAqIH1cbiAgICpcbiAgICogdmFyIHNvbWUgPSBuZXcgU29tZSgpO1xuICAgKiBzb21lLnRoaW5nKCk7XG4gICAqIHNvbWUudHJpZ2dlcihcImhpXCIpO1xuICAgKiAvLyBmaXJlIGFsZXJ0KFwiaGlcIik7XG4gICAqIHNvbWUudHJpZ2dlcihcImhpXCIpO1xuICAgKiAvLyBOb3RoaW5nIGhhcHBlbnNcbiAgICogYGBgXG4gICAqL1xuXG5cbiAgX19wcm90by5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlclRvQXR0YWNoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcIm9iamVjdFwiICYmIGlzVW5kZWZpbmVkKGhhbmRsZXJUb0F0dGFjaCkpIHtcbiAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBldmVudEhhc2gpIHtcbiAgICAgICAgdGhpcy5vbmNlKGtleSwgZXZlbnRIYXNoW2tleV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGhhbmRsZXJUb0F0dGFjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgbGlzdGVuZXJfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZXJUb0F0dGFjaC5hcHBseShfdGhpcywgYXJncyk7XG5cbiAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXJfMSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJfMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhbiBldmVudCBoYXMgYmVlbiBhdHRhY2hlZCB0byBhIGNvbXBvbmVudC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDsnbTrsqTtirjqsIAg65Ox66Gd65CQ64qU7KeAIO2ZleyduO2VnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhnSDsl6zrtoDrpbwg7ZmV7J247ZWgIOydtOuypO2KuOydmCDsnbTrpoQ8L2tvPlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgaXMgYXR0YWNoZWQuIDxrbz7snbTrsqTtirgg65Ox66GdIOyXrOu2gDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgZWcuQ29tcG9uZW50IHtcbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5oYXNPbihcImhpXCIpOy8vIGNoZWNrIGhpIGV2ZW50LlxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG5cblxuICBfX3Byb3RvLmhhc09uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICB9O1xuICAvKipcbiAgICogQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBjb21wb25lbnQuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag7J2067Kk7Yq466W8IOuTseuhne2VnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclRvQXR0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIGVnLkNvbXBvbmVudCB7XG4gICAqICAgaGkoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcImhpXCIpO1xuICAgKiAgIH1cbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5vbihcImhpXCIsdGhpcy5oaSk7IC8vYXR0YWNoIGV2ZW50XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cblxuXG4gIF9fcHJvdG8ub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyVG9BdHRhY2gpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIiAmJiBpc1VuZGVmaW5lZChoYW5kbGVyVG9BdHRhY2gpKSB7XG4gICAgICB2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50SGFzaCkge1xuICAgICAgICB0aGlzLm9uKG5hbWUsIGV2ZW50SGFzaFtuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaGFuZGxlclRvQXR0YWNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuXG4gICAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdID0gW107XG4gICAgICAgIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXJMaXN0LnB1c2goaGFuZGxlclRvQXR0YWNoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERldGFjaGVzIGFuIGV2ZW50IGZyb20gdGhlIGNvbXBvbmVudC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDrk7HroZ3rkJwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDsnbTrpoQ8L2tvPlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyVG9EZXRhY2ggVGhlIGhhbmRsZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGRldGFjaGVkIDxrbz7tlbTsoJztlaAg7J2067Kk7Yq47J2YIO2VuOuTpOufrCDtlajsiJg8L2tvPlxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGl0c2VsZiA8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIGVnLkNvbXBvbmVudCB7XG4gICAqICAgaGkoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcImhpXCIpO1xuICAgKiAgIH1cbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5vZmYoXCJoaVwiLHRoaXMuaGkpOyAvL2RldGFjaCBldmVudFxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG5cblxuICBfX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXJUb0RldGFjaCkge1xuICAgIHZhciBlXzEsIF9hOyAvLyBEZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzLlxuXG5cbiAgICBpZiAoaXNVbmRlZmluZWQoZXZlbnROYW1lKSkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIERldGFjaCBhbGwgaGFuZGxlcnMgZm9yIGV2ZW50bmFtZSBvciBkZXRhY2ggZXZlbnQgaGFuZGxlcnMgYnkgb2JqZWN0LlxuXG5cbiAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlclRvRGV0YWNoKSkge1xuICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudEhhc2gpIHtcbiAgICAgICAgICB0aGlzLm9mZihuYW1lLCBldmVudEhhc2hbbmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSAvLyBEZXRhY2ggc2luZ2xlIGV2ZW50IGhhbmRsZXJcblxuXG4gICAgdmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG5cbiAgICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICAgIHZhciBpZHggPSAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBoYW5kbGVyTGlzdF8xID0gX192YWx1ZXMoaGFuZGxlckxpc3QpLCBoYW5kbGVyTGlzdF8xXzEgPSBoYW5kbGVyTGlzdF8xLm5leHQoKTsgIWhhbmRsZXJMaXN0XzFfMS5kb25lOyBoYW5kbGVyTGlzdF8xXzEgPSBoYW5kbGVyTGlzdF8xLm5leHQoKSkge1xuICAgICAgICAgIHZhciBoYW5kbGVyRnVuY3Rpb24gPSBoYW5kbGVyTGlzdF8xXzEudmFsdWU7XG5cbiAgICAgICAgICBpZiAoaGFuZGxlckZ1bmN0aW9uID09PSBoYW5kbGVyVG9EZXRhY2gpIHtcbiAgICAgICAgICAgIGhhbmRsZXJMaXN0LnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXJMaXN0XzFfMSAmJiAhaGFuZGxlckxpc3RfMV8xLmRvbmUgJiYgKF9hID0gaGFuZGxlckxpc3RfMS5yZXR1cm4pKSBfYS5jYWxsKGhhbmRsZXJMaXN0XzEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogVmVyc2lvbiBpbmZvIHN0cmluZ1xuICAgKiBAa28g67KE7KCE7KCV67O0IOusuOyekOyXtFxuICAgKiBAbmFtZSBWRVJTSU9OXG4gICAqIEBzdGF0aWNcbiAgICogQGV4YW1wbGVcbiAgICogZWcuQ29tcG9uZW50LlZFUlNJT047ICAvLyBleCkgMi4wLjBcbiAgICogQG1lbWJlcm9mIGVnLkNvbXBvbmVudFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5WRVJTSU9OID0gXCIyLjIuMlwiO1xuICByZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@egjs/axes/node_modules/@egjs/component/dist/component.esm.js\n')},"./node_modules/@egjs/component/dist/component.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/@egjs/component/dist/component.esm.js ***!
  \************************************************************/
/*! exports provided: default, ComponentEvent */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentEvent", function() { return ComponentEvent$1; });\n/*\nCopyright (c) NAVER Corp.\nname: @egjs/component\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-component\nversion: 3.0.2\n*/\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nfunction __values(o) {\n  var s = typeof Symbol === "function" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === "number") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === "function" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i["return"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nvar isUndefined = function (value) {\n  return typeof value === "undefined";\n};\n\n/**\n * Event class to provide additional properties\n * @ko Component에서 추가적인 프로퍼티를 제공하는 이벤트 클래스\n */\n\nvar ComponentEvent =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new instance of ComponentEvent.\n   * @ko ComponentEvent의 새로운 인스턴스를 생성한다.\n   * @param eventType The name of the event.<ko>이벤트 이름.</ko>\n   * @param props An object that contains additional event properties.<ko>추가적인 이벤트 프로퍼티 오브젝트.</ko>\n   */\n  function ComponentEvent(eventType, props) {\n    var e_1, _a;\n\n    this._canceled = false;\n\n    if (props) {\n      try {\n        for (var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n          this[key] = props[key];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    this.eventType = eventType;\n  }\n  /**\n   * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.\n   * @ko 이벤트를 중단한다. 이후 {@link ComponentEvent#isCanceled}가 `true`를 반환한다.\n   */\n\n\n  var __proto = ComponentEvent.prototype;\n\n  __proto.stop = function () {\n    this._canceled = true;\n  };\n  /**\n   * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.\n   * @ko {@link ComponentEvent#stop}이 호출되었는지 여부를 반환한다.\n   * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko>이전에 {@link ComponentEvent#stop}이 불려졌는지 여부를 반환한다.</ko>\n   */\n\n\n  __proto.isCanceled = function () {\n    return this._canceled;\n  };\n\n  return ComponentEvent;\n}();\n\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n */\n\nvar Component =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}\n   */\n  function Component() {\n    this._eventHandler = {};\n  }\n  /**\n   * Trigger a custom event.\n   * @ko 커스텀 이벤트를 발생시킨다\n   * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>발생할 커스텀 이벤트의 이름 또는 ComponentEvent의 인스턴스</ko>\n   * @param {any[]} params Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from "@egjs/component";\n   *\n   * class Some extends Component<{\n   *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;\n   *   hi: { foo: { a: number; b: boolean } };\n   *   someEvent: (foo: number, bar: string) => void;\n   *   someOtherEvent: void; // When there\'s no event argument\n   * }> {\n   *   some(){\n   *     if(this.trigger("beforeHi")){ // When event call to stop return false.\n   *       this.trigger("hi");// fire hi event.\n   *     }\n   *   }\n   * }\n   *\n   * const some = new Some();\n   * some.on("beforeHi", e => {\n   *   if(condition){\n   *     e.stop(); // When event call to stop, `hi` event not call.\n   *   }\n   *   // `currentTarget` is component instance.\n   *   console.log(some === e.currentTarget); // true\n   *\n   *   typeof e.foo; // number\n   *   typeof e.bar; // string\n   * });\n   * some.on("hi", e => {\n   *   typeof e.foo.b; // boolean\n   * });\n   * // If you want to more know event design. You can see article.\n   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n   * ```\n   */\n\n\n  var __proto = Component.prototype;\n\n  __proto.trigger = function (event) {\n    var params = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      params[_i - 1] = arguments[_i];\n    }\n\n    var eventName = event instanceof ComponentEvent ? event.eventType : event;\n\n    var handlers = __spread(this._eventHandler[eventName] || []);\n\n    if (handlers.length <= 0) {\n      return this;\n    }\n\n    if (event instanceof ComponentEvent) {\n      event.currentTarget = this;\n      handlers.forEach(function (handler) {\n        handler(event);\n      });\n    } else {\n      handlers.forEach(function (handler) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        handler.apply(void 0, __spread(params));\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Executed event just one time.\n   * @ko 이벤트가 한번만 실행된다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from "@egjs/component";\n   *\n   * class Some extends Component<{\n   *   hi: ComponentEvent;\n   * }> {\n   *   hi() {\n   *     alert("hi");\n   *   }\n   *   thing() {\n   *     this.once("hi", this.hi);\n   *   }\n   * }\n   *\n   * var some = new Some();\n   * some.thing();\n   * some.trigger(new ComponentEvent("hi"));\n   * // fire alert("hi");\n   * some.trigger(new ComponentEvent("hi"));\n   * // Nothing happens\n   * ```\n   */\n\n\n  __proto.once = function (eventName, handlerToAttach) {\n    var _this = this;\n\n    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {\n      var eventHash = eventName;\n\n      for (var key in eventHash) {\n        this.once(key, eventHash[key]);\n      }\n\n      return this;\n    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {\n      var listener_1 = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        } // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n\n\n        handlerToAttach.apply(void 0, __spread(args));\n\n        _this.off(eventName, listener_1);\n      };\n\n      this.on(eventName, listener_1);\n    }\n\n    return this;\n  };\n  /**\n   * Checks whether an event has been attached to a component.\n   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n   * @example\n   * ```ts\n   * import Component from "@egjs/component";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   some() {\n   *     this.hasOn("hi");// check hi event.\n   *   }\n   * }\n   * ```\n   */\n\n\n  __proto.hasOn = function (eventName) {\n    return !!this._eventHandler[eventName];\n  };\n  /**\n   * Attaches an event to a component.\n   * @ko 컴포넌트에 이벤트를 등록한다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from "@egjs/component";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log("hi");\n   *   }\n   *   some() {\n   *     this.on("hi",this.hi); //attach event\n   *   }\n   * }\n   * ```\n   */\n\n\n  __proto.on = function (eventName, handlerToAttach) {\n    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {\n      var eventHash = eventName;\n\n      for (var name in eventHash) {\n        this.on(name, eventHash[name]);\n      }\n\n      return this;\n    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {\n      var handlerList = this._eventHandler[eventName];\n\n      if (isUndefined(handlerList)) {\n        this._eventHandler[eventName] = [];\n        handlerList = this._eventHandler[eventName];\n      }\n\n      handlerList.push(handlerToAttach);\n    }\n\n    return this;\n  };\n  /**\n   * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.\n   * @ko 컴포넌트에 등록된 이벤트를 해제한다.<br/>`eventName`이 주어지지 않았을 경우 모든 이벤트 핸들러를 제거한다.<br/>`handlerToAttach`가 주어지지 않았을 경우 `eventName`에 해당하는 모든 이벤트 핸들러를 제거한다.\n   * @param {string?} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n   * @param {function?} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from "@egjs/component";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log("hi");\n   *   }\n   *   some() {\n   *     this.off("hi",this.hi); //detach event\n   *   }\n   * }\n   * ```\n   */\n\n\n  __proto.off = function (eventName, handlerToDetach) {\n    var e_1, _a; // Detach all event handlers.\n\n\n    if (isUndefined(eventName)) {\n      this._eventHandler = {};\n      return this;\n    } // Detach all handlers for eventname or detach event handlers by object.\n\n\n    if (isUndefined(handlerToDetach)) {\n      if (typeof eventName === "string") {\n        delete this._eventHandler[eventName];\n        return this;\n      } else {\n        var eventHash = eventName;\n\n        for (var name in eventHash) {\n          this.off(name, eventHash[name]);\n        }\n\n        return this;\n      }\n    } // Detach single event handler\n\n\n    var handlerList = this._eventHandler[eventName];\n\n    if (handlerList) {\n      var idx = 0;\n\n      try {\n        for (var handlerList_1 = __values(handlerList), handlerList_1_1 = handlerList_1.next(); !handlerList_1_1.done; handlerList_1_1 = handlerList_1.next()) {\n          var handlerFunction = handlerList_1_1.value;\n\n          if (handlerFunction === handlerToDetach) {\n            handlerList.splice(idx, 1);\n\n            if (handlerList.length <= 0) {\n              delete this._eventHandler[eventName];\n            }\n\n            break;\n          }\n\n          idx++;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (handlerList_1_1 && !handlerList_1_1.done && (_a = handlerList_1.return)) _a.call(handlerList_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @example\n   * Component.VERSION;  // ex) 3.0.0\n   * @memberof Component\n   */\n\n\n  Component.VERSION = "3.0.2";\n  return Component;\n}();\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nvar ComponentEvent$1 = ComponentEvent;\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/* harmony default export */ __webpack_exports__["default"] = (Component);\n\n//# sourceMappingURL=component.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvY29tcG9uZW50L2Rpc3QvY29tcG9uZW50LmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZWdqcy9jb21wb25lbnQvZGlzdC9jb21wb25lbnQuZXNtLmpzPzAzYzIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2NvbXBvbmVudFxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnRcbnZlcnNpb246IDMuMC4yXG4qL1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgbSA9IHMgJiYgb1tzXSxcbiAgICAgIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgIGRvbmU6ICFvXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgIHIsXG4gICAgICBhciA9IFtdLFxuICAgICAgZTtcblxuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGUgPSB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFyO1xufVxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG5cbiAgcmV0dXJuIGFyO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xudmFyIGlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59O1xuXG4vKipcbiAqIEV2ZW50IGNsYXNzIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAa28gQ29tcG9uZW507JeQ7IScIOy2lOqwgOyggeyduCDtlITroZztjbzti7Drpbwg7KCc6rO17ZWY64qUIOydtOuypO2KuCDtgbTrnpjsiqRcbiAqL1xuXG52YXIgQ29tcG9uZW50RXZlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIENvbXBvbmVudEV2ZW50LlxuICAgKiBAa28gQ29tcG9uZW50RXZlbnTsnZgg7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlZzri6QuXG4gICAqIEBwYXJhbSBldmVudFR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50Ljxrbz7snbTrsqTtirgg7J2066aELjwva28+XG4gICAqIEBwYXJhbSBwcm9wcyBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhZGRpdGlvbmFsIGV2ZW50IHByb3BlcnRpZXMuPGtvPuy2lOqwgOyggeyduCDsnbTrsqTtirgg7ZSE66Gc7Y287YuwIOyYpOu4jOygne2KuC48L2tvPlxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50RXZlbnQoZXZlbnRUeXBlLCBwcm9wcykge1xuICAgIHZhciBlXzEsIF9hO1xuXG4gICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhwcm9wcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG5cbiAgICAgICAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGUgZXZlbnQuIHtAbGluayBDb21wb25lbnRFdmVudCNpc0NhbmNlbGVkfSB3aWxsIHJldHVybiBgdHJ1ZWAgYWZ0ZXIuXG4gICAqIEBrbyDsnbTrsqTtirjrpbwg7KSR64uo7ZWc64ukLiDsnbTtm4Qge0BsaW5rIENvbXBvbmVudEV2ZW50I2lzQ2FuY2VsZWR96rCAIGB0cnVlYOulvCDrsJjtmZjtlZzri6QuXG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBDb21wb25lbnRFdmVudC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B9IGlzIGNhbGxlZCBiZWZvcmUuXG4gICAqIEBrbyB7QGxpbmsgQ29tcG9uZW50RXZlbnQjc3RvcH3snbQg7Zi47Lac65CY7JeI64qU7KeAIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfSBpcyBjYWxsZWQgYmVmb3JlLjxrbz7snbTsoITsl5Age0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B97J20IOu2iOugpOyhjOuKlOyngCDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqL1xuXG5cbiAgX19wcm90by5pc0NhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxlZDtcbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50RXZlbnQ7XG59KCk7XG5cbi8qKlxuICogQSBjbGFzcyB1c2VkIHRvIG1hbmFnZSBldmVudHMgaW4gYSBjb21wb25lbnRcbiAqIEBrbyDsu7Ttj6zrhIztirjsnZgg7J2067Kk7Yq47J2EIOq0gOumrO2VoCDsiJgg7J6I6rKMIO2VmOuKlCDtgbTrnpjsiqRcbiAqL1xuXG52YXIgQ29tcG9uZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBzdXBwb3J0IHtcImllXCI6IFwiNytcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjErIChleGNlcHQgMy54KVwifVxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KCkge1xuICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgY3VzdG9tIGV2ZW50LlxuICAgKiBAa28g7Luk7Iqk7YWAIOydtOuypO2KuOulvCDrsJzsg53si5ztgqjri6RcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBDb21wb25lbnRFdmVudH0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCB0byBiZSB0cmlnZ2VyZWQgb3IgYW4gaW5zdGFuY2Ugb2YgdGhlIENvbXBvbmVudEV2ZW50PGtvPuuwnOyDne2VoCDsu6TsiqTthYAg7J2067Kk7Yq47J2YIOydtOumhCDrmJDripQgQ29tcG9uZW50RXZlbnTsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQHBhcmFtIHthbnlbXX0gcGFyYW1zIEV2ZW50IGRhdGEgdG8gYmUgc2VudCB3aGVuIHRyaWdnZXJpbmcgYSBjdXN0b20gZXZlbnQgPGtvPuy7pOyKpO2FgCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWgIOuVjCDsoITri6ztlaAg642w7J207YSwPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGl0c2VsZjxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQsIHsgQ29tcG9uZW50RXZlbnQgfSBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGJlZm9yZUhpOiBDb21wb25lbnRFdmVudDx7IGZvbzogbnVtYmVyOyBiYXI6IHN0cmluZyB9PjtcbiAgICogICBoaTogeyBmb286IHsgYTogbnVtYmVyOyBiOiBib29sZWFuIH0gfTtcbiAgICogICBzb21lRXZlbnQ6IChmb286IG51bWJlciwgYmFyOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAqICAgc29tZU90aGVyRXZlbnQ6IHZvaWQ7IC8vIFdoZW4gdGhlcmUncyBubyBldmVudCBhcmd1bWVudFxuICAgKiB9PiB7XG4gICAqICAgc29tZSgpe1xuICAgKiAgICAgaWYodGhpcy50cmlnZ2VyKFwiYmVmb3JlSGlcIikpeyAvLyBXaGVuIGV2ZW50IGNhbGwgdG8gc3RvcCByZXR1cm4gZmFsc2UuXG4gICAqICAgICAgIHRoaXMudHJpZ2dlcihcImhpXCIpOy8vIGZpcmUgaGkgZXZlbnQuXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHNvbWUgPSBuZXcgU29tZSgpO1xuICAgKiBzb21lLm9uKFwiYmVmb3JlSGlcIiwgZSA9PiB7XG4gICAqICAgaWYoY29uZGl0aW9uKXtcbiAgICogICAgIGUuc3RvcCgpOyAvLyBXaGVuIGV2ZW50IGNhbGwgdG8gc3RvcCwgYGhpYCBldmVudCBub3QgY2FsbC5cbiAgICogICB9XG4gICAqICAgLy8gYGN1cnJlbnRUYXJnZXRgIGlzIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogICBjb25zb2xlLmxvZyhzb21lID09PSBlLmN1cnJlbnRUYXJnZXQpOyAvLyB0cnVlXG4gICAqXG4gICAqICAgdHlwZW9mIGUuZm9vOyAvLyBudW1iZXJcbiAgICogICB0eXBlb2YgZS5iYXI7IC8vIHN0cmluZ1xuICAgKiB9KTtcbiAgICogc29tZS5vbihcImhpXCIsIGUgPT4ge1xuICAgKiAgIHR5cGVvZiBlLmZvby5iOyAvLyBib29sZWFuXG4gICAqIH0pO1xuICAgKiAvLyBJZiB5b3Ugd2FudCB0byBtb3JlIGtub3cgZXZlbnQgZGVzaWduLiBZb3UgY2FuIHNlZSBhcnRpY2xlLlxuICAgKiAvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnQvd2lraS9Ib3ctdG8tbWFrZS1Db21wb25lbnQtZXZlbnQtZGVzaWduJTNGXG4gICAqIGBgYFxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIHZhciBldmVudE5hbWUgPSBldmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEV2ZW50ID8gZXZlbnQuZXZlbnRUeXBlIDogZXZlbnQ7XG5cbiAgICB2YXIgaGFuZGxlcnMgPSBfX3NwcmVhZCh0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXSB8fCBbXSk7XG5cbiAgICBpZiAoaGFuZGxlcnMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEV2ZW50KSB7XG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChwYXJhbXMpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRXhlY3V0ZWQgZXZlbnQganVzdCBvbmUgdGltZS5cbiAgICogQGtvIOydtOuypO2KuOqwgCDtlZzrsojrp4wg7Iuk7ZaJ65Cc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCBvciBhbiBldmVudCBuYW1lIC0gZXZlbnQgaGFuZGxlciBtYXBwZWQgb2JqZWN0Ljxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIOydtOumhCDrmJDripQg7J2067Kk7Yq4IOydtOumhC3tlbjrk6Trn6wg7Jik67iM7KCd7Yq4PC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclRvQXR0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGl0c2VsZjxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQsIHsgQ29tcG9uZW50RXZlbnQgfSBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGhpOiBDb21wb25lbnRFdmVudDtcbiAgICogfT4ge1xuICAgKiAgIGhpKCkge1xuICAgKiAgICAgYWxlcnQoXCJoaVwiKTtcbiAgICogICB9XG4gICAqICAgdGhpbmcoKSB7XG4gICAqICAgICB0aGlzLm9uY2UoXCJoaVwiLCB0aGlzLmhpKTtcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogdmFyIHNvbWUgPSBuZXcgU29tZSgpO1xuICAgKiBzb21lLnRoaW5nKCk7XG4gICAqIHNvbWUudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQoXCJoaVwiKSk7XG4gICAqIC8vIGZpcmUgYWxlcnQoXCJoaVwiKTtcbiAgICogc29tZS50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudChcImhpXCIpKTtcbiAgICogLy8gTm90aGluZyBoYXBwZW5zXG4gICAqIGBgYFxuICAgKi9cblxuXG4gIF9fcHJvdG8ub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXJUb0F0dGFjaCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIiAmJiBpc1VuZGVmaW5lZChoYW5kbGVyVG9BdHRhY2gpKSB7XG4gICAgICB2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgIHRoaXMub25jZShrZXksIGV2ZW50SGFzaFtrZXldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIGxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuXG5cbiAgICAgICAgaGFuZGxlclRvQXR0YWNoLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoYXJncykpO1xuXG4gICAgICAgIF90aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyXzEpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyXzEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZXZlbnQgaGFzIGJlZW4gYXR0YWNoZWQgdG8gYSBjb21wb25lbnQuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag7J2067Kk7Yq46rCAIOuTseuhneuQkOuKlOyngCDtmZXsnbjtlZzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ0g7Jes67aA66W8IO2ZleyduO2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IGlzIGF0dGFjaGVkLiA8a28+7J2067Kk7Yq4IOuTseuhnSDsl6zrtoA8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5oYXNPbihcImhpXCIpOy8vIGNoZWNrIGhpIGV2ZW50LlxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG5cblxuICBfX3Byb3RvLmhhc09uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICB9O1xuICAvKipcbiAgICogQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBjb21wb25lbnQuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag7J2067Kk7Yq466W8IOuTseuhne2VnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgb3IgYW4gZXZlbnQgbmFtZSAtIGV2ZW50IGhhbmRsZXIgbWFwcGVkIG9iamVjdC48a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDsnbTrpoQg65iQ64qUIOydtOuypO2KuCDsnbTrpoQt7ZW465Ok65+sIOyYpOu4jOygne2KuDwva28+XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJUb0F0dGFjaCBUaGUgaGFuZGxlciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7ZW465Ok65+sIO2VqOyImDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHNvbWUoKSB7XG4gICAqICAgICB0aGlzLm9uKFwiaGlcIix0aGlzLmhpKTsgLy9hdHRhY2ggZXZlbnRcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuXG5cbiAgX19wcm90by5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXJUb0F0dGFjaCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcIm9iamVjdFwiICYmIGlzVW5kZWZpbmVkKGhhbmRsZXJUb0F0dGFjaCkpIHtcbiAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgIHRoaXMub24obmFtZSwgZXZlbnRIYXNoW25hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG5cbiAgICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgaGFuZGxlckxpc3QgPSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlckxpc3QucHVzaChoYW5kbGVyVG9BdHRhY2gpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGV0YWNoZXMgYW4gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50Ljxici8+SWYgdGhlIGBldmVudE5hbWVgIGlzIG5vdCBnaXZlbiB0aGlzIHdpbGwgZGV0YWNoIGFsbCBldmVudCBoYW5kbGVycyBhdHRhY2hlZC48YnIvPklmIHRoZSBgaGFuZGxlclRvRGV0YWNoYCBpcyBub3QgZ2l2ZW4sIHRoaXMgd2lsbCBkZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzIGZvciBgZXZlbnROYW1lYC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDrk7HroZ3rkJwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpC48YnIvPmBldmVudE5hbWVg7J20IOyjvOyWtOyngOyngCDslYrslZjsnYQg6rK97JqwIOuqqOuToCDsnbTrsqTtirgg7ZW465Ok65+s66W8IOygnOqxsO2VnOuLpC48YnIvPmBoYW5kbGVyVG9BdHRhY2hg6rCAIOyjvOyWtOyngOyngCDslYrslZjsnYQg6rK97JqwIGBldmVudE5hbWVg7JeQIO2VtOuLue2VmOuKlCDrqqjrk6Ag7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJzqsbDtlZzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nP30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDsnbTrpoQ8L2tvPlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uP30gaGFuZGxlclRvRGV0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBpdHNlbGYgPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHNvbWUoKSB7XG4gICAqICAgICB0aGlzLm9mZihcImhpXCIsdGhpcy5oaSk7IC8vZGV0YWNoIGV2ZW50XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cblxuXG4gIF9fcHJvdG8ub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlclRvRGV0YWNoKSB7XG4gICAgdmFyIGVfMSwgX2E7IC8vIERldGFjaCBhbGwgZXZlbnQgaGFuZGxlcnMuXG5cblxuICAgIGlmIChpc1VuZGVmaW5lZChldmVudE5hbWUpKSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gRGV0YWNoIGFsbCBoYW5kbGVycyBmb3IgZXZlbnRuYW1lIG9yIGRldGFjaCBldmVudCBoYW5kbGVycyBieSBvYmplY3QuXG5cblxuICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyVG9EZXRhY2gpKSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV2ZW50SGFzaCA9IGV2ZW50TmFtZTtcblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50SGFzaCkge1xuICAgICAgICAgIHRoaXMub2ZmKG5hbWUsIGV2ZW50SGFzaFtuYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9IC8vIERldGFjaCBzaW5nbGUgZXZlbnQgaGFuZGxlclxuXG5cbiAgICB2YXIgaGFuZGxlckxpc3QgPSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcblxuICAgIGlmIChoYW5kbGVyTGlzdCkge1xuICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGhhbmRsZXJMaXN0XzEgPSBfX3ZhbHVlcyhoYW5kbGVyTGlzdCksIGhhbmRsZXJMaXN0XzFfMSA9IGhhbmRsZXJMaXN0XzEubmV4dCgpOyAhaGFuZGxlckxpc3RfMV8xLmRvbmU7IGhhbmRsZXJMaXN0XzFfMSA9IGhhbmRsZXJMaXN0XzEubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXJGdW5jdGlvbiA9IGhhbmRsZXJMaXN0XzFfMS52YWx1ZTtcblxuICAgICAgICAgIGlmIChoYW5kbGVyRnVuY3Rpb24gPT09IGhhbmRsZXJUb0RldGFjaCkge1xuICAgICAgICAgICAgaGFuZGxlckxpc3Quc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyTGlzdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlkeCsrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChoYW5kbGVyTGlzdF8xXzEgJiYgIWhhbmRsZXJMaXN0XzFfMS5kb25lICYmIChfYSA9IGhhbmRsZXJMaXN0XzEucmV0dXJuKSkgX2EuY2FsbChoYW5kbGVyTGlzdF8xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFZlcnNpb24gaW5mbyBzdHJpbmdcbiAgICogQGtvIOuyhOyghOygleuztCDrrLjsnpDsl7RcbiAgICogQG5hbWUgVkVSU0lPTlxuICAgKiBAc3RhdGljXG4gICAqIEBleGFtcGxlXG4gICAqIENvbXBvbmVudC5WRVJTSU9OOyAgLy8gZXgpIDMuMC4wXG4gICAqIEBtZW1iZXJvZiBDb21wb25lbnRcbiAgICovXG5cblxuICBDb21wb25lbnQuVkVSU0lPTiA9IFwiMy4wLjJcIjtcbiAgcmV0dXJuIENvbXBvbmVudDtcbn0oKTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxudmFyIENvbXBvbmVudEV2ZW50JDEgPSBDb21wb25lbnRFdmVudDtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuZXhwb3J0IHsgQ29tcG9uZW50RXZlbnQkMSBhcyBDb21wb25lbnRFdmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50LmVzbS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@egjs/component/dist/component.esm.js\n')},"./node_modules/@egjs/flicking-plugins/dist/pagination.css":
/*!*****************************************************************!*\
  !*** ./node_modules/@egjs/flicking-plugins/dist/pagination.css ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !../../../css-loader??ref--6-oneOf-3-1!../../../postcss-loader/src??ref--6-oneOf-3-2!./pagination.css */ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/@egjs/flicking-plugins/dist/pagination.css");\nif(typeof content === \'string\') content = [[module.i, content, \'\']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(/*! ../../../vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default\nvar update = add("f8647b18", content, false, {"sourceMap":false,"shadowMode":false});\n// Hot Module Replacement\nif(true) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(/*! !../../../css-loader??ref--6-oneOf-3-1!../../../postcss-loader/src??ref--6-oneOf-3-2!./pagination.css */ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/@egjs/flicking-plugins/dist/pagination.css", function() {\n     var newContent = __webpack_require__(/*! !../../../css-loader??ref--6-oneOf-3-1!../../../postcss-loader/src??ref--6-oneOf-3-2!./pagination.css */ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/@egjs/flicking-plugins/dist/pagination.css");\n     if(typeof newContent === \'string\') newContent = [[module.i, newContent, \'\']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvZmxpY2tpbmctcGx1Z2lucy9kaXN0L3BhZ2luYXRpb24uY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL2ZsaWNraW5nLXBsdWdpbnMvZGlzdC9wYWdpbmF0aW9uLmNzcz8yMjc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtb25lT2YtMy0xIS4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTMtMiEuL3BhZ2luYXRpb24uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiZjg2NDdiMThcIiwgY29udGVudCwgZmFsc2UsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtb25lT2YtMy0xIS4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTMtMiEuL3BhZ2luYXRpb24uY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi1vbmVPZi0zLTEhLi4vLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTYtb25lT2YtMy0yIS4vcGFnaW5hdGlvbi5jc3NcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@egjs/flicking-plugins/dist/pagination.css\n')},"./node_modules/@egjs/flicking-plugins/dist/plugins.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@egjs/flicking-plugins/dist/plugins.esm.js ***!
  \*****************************************************************/
/*! exports provided: ARROW, Arrow, AutoPlay, Fade, PAGINATION, Pagination, Parallax, Perspective, SYNC, Sync */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARROW", function() { return ARROW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Arrow", function() { return Arrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutoPlay", function() { return AutoPlay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fade", function() { return Fade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PAGINATION", function() { return PAGINATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pagination", function() { return Pagination; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parallax", function() { return Parallax; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Perspective", function() { return Perspective; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SYNC", function() { return SYNC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sync", function() { return Sync; });\n/* harmony import */ var _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @egjs/flicking */ "./node_modules/@egjs/flicking/dist/flicking.esm.js");\n/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/flicking-plugins\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-flicking-plugins\nversion: 4.4.0\n*/\n\n\n/**\n * You can apply parallax effect while panel is moving.\n * @ko 패널들을 움직이면서 parallax 효과를 부여할 수 있습니다.\n * @memberof Flicking.Plugins\n */\n\nvar Parallax =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {string} selector Selector of the element to apply parallax effect<ko> Parallax 효과를 적용할 엘리먼트의 선택자 </ko>\n   * @param {number} scale Effect amplication scale<ko>효과 증폭도</ko>\n   * @example\n   * ```ts\n   * flicking.addPlugins(new Parallax("img", 1));\n   * ```\n   */\n  function Parallax(selector, scale) {\n    var _this = this;\n\n    if (selector === void 0) {\n      selector = "";\n    }\n\n    if (scale === void 0) {\n      scale = 1;\n    }\n\n    this.update = function () {\n      _this._onMove();\n    };\n\n    this._onMove = function () {\n      var flicking = _this._flicking;\n      if (!flicking) return;\n      var panels = flicking.visiblePanels;\n      panels.forEach(function (panel) {\n        var progress = panel.outsetProgress;\n        var el = panel.element;\n        var target = _this._selector ? el.querySelector(_this._selector) : el;\n        var parentTarget = target.parentNode;\n        var rect = target.getBoundingClientRect();\n        var parentRect = parentTarget.getBoundingClientRect();\n        var position = (parentRect.width - rect.width) / 2 * progress * _this._scale;\n        var transform = "translate(-50%) translate(" + position + "px)";\n        var style = target.style;\n        style.cssText += "transform: " + transform + ";-webkit-transform: " + transform + ";-ms-transform:" + transform;\n      });\n    };\n\n    this._flicking = null;\n    this._selector = selector;\n    this._scale = scale;\n  }\n\n  var __proto = Parallax.prototype;\n  Object.defineProperty(__proto, "selector", {\n    get: function () {\n      return this._selector;\n    },\n    set: function (val) {\n      this._selector = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "scale", {\n    get: function () {\n      return this._scale;\n    },\n    set: function (val) {\n      this._scale = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (flicking) {\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onMove);\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].AFTER_RESIZE, this.update);\n\n    this._onMove();\n  };\n\n  __proto.destroy = function () {\n    if (!this._flicking) return;\n\n    this._flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onMove);\n\n    this._flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].AFTER_RESIZE, this.update);\n\n    this._flicking = null;\n  };\n\n  return Parallax;\n}();\n\n/**\n * You can apply fade in / out effect while panel is moving.\n * @ko 패널들을 움직이면서 fade in / out 효과를 부여할 수 있습니다.\n * @memberof Flicking.Plugins\n */\n\nvar Fade =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param - The selector of the element to which the fade effect is to be applied. If the selector is blank, it applies to panel element. <ko>Fade 효과를 적용할 대상의 선택자. 선택자가 공백이면 패널 엘리먼트에 적용된다.</ko>\n   * @param - Effect amplication scale<ko>효과 증폭도</ko>\n   * @example\n   * ```ts\n   * flicking.addPlugins(new Fade("p", 1));\n   * ```\n   */\n  function Fade(selector, scale) {\n    var _this = this;\n\n    if (selector === void 0) {\n      selector = "";\n    }\n\n    if (scale === void 0) {\n      scale = 1;\n    }\n\n    this.update = function () {\n      _this._onMove();\n    };\n\n    this._onMove = function () {\n      var flicking = _this._flicking;\n      var selector = _this._selector;\n      var scale = _this._scale;\n      if (!flicking) return;\n      var panels = flicking.visiblePanels;\n      panels.forEach(function (panel) {\n        var progress = panel.outsetProgress;\n        var el = panel.element;\n        var target = selector ? el.querySelector(selector) : el;\n        var opacity = Math.min(1, Math.max(0, 1 - Math.abs(progress * scale)));\n        target.style.opacity = "" + opacity;\n      });\n    };\n\n    this._flicking = null;\n    this._selector = selector;\n    this._scale = scale;\n  }\n\n  var __proto = Fade.prototype;\n  Object.defineProperty(__proto, "selector", {\n    get: function () {\n      return this._selector;\n    },\n    set: function (val) {\n      this._selector = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "scale", {\n    get: function () {\n      return this._scale;\n    },\n    set: function (val) {\n      this._scale = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (flicking) {\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onMove);\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].AFTER_RESIZE, this.update);\n\n    this._onMove();\n  };\n\n  __proto.destroy = function () {\n    if (!this._flicking) return;\n\n    this._flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onMove);\n\n    this._flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].AFTER_RESIZE, this.update);\n\n    this._flicking = null;\n  };\n\n  return Fade;\n}();\n\n/**\n * Plugin that allow you to automatically move to the next/previous panel, on a specific time basis\n * @ko 일정 시간마다, 자동으로 다음/이전 패널로 넘어가도록 할 수 있는 플러그인\n * @memberof Flicking.Plugins\n */\n\nvar AutoPlay =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {AutoPlayOptions} options Options for the AutoPlay instance.<ko>AutoPlay 옵션</ko>\n   * @param {number} options.duration Time to wait before moving on to the next panel.<ko>다음 패널로 움직이기까지 대기 시간</ko>\n   * @param {"PREV" | "NEXT"} options.direction The direction in which the panel moves.<ko>패널이 움직이는 방향</ko>\n   * @param {boolean} options.stopOnHover Whether to stop when mouse hover upon the element.<ko>엘리먼트에 마우스를 올렸을 때 AutoPlay를 정지할지 여부</ko>\n   * @example\n   * ```ts\n   * flicking.addPlugins(new AutoPlay({ duration: 2000, direction: "NEXT" }));\n   * ```\n   */\n  function AutoPlay(_a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.duration,\n        duration = _c === void 0 ? 2000 : _c,\n        _d = _b.direction,\n        direction = _d === void 0 ? _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["DIRECTION"].NEXT : _d,\n        _e = _b.stopOnHover,\n        stopOnHover = _e === void 0 ? false : _e;\n    /* Internal Values */\n\n\n    this._flicking = null;\n    this._timerId = 0;\n    this._mouseEntered = false;\n\n    this.play = function () {\n      var flicking = _this._flicking;\n      var direction = _this._direction;\n\n      if (!flicking) {\n        return;\n      }\n\n      _this.stop();\n\n      if (_this._mouseEntered || flicking.animating) {\n        return;\n      }\n\n      _this._timerId = window.setTimeout(function () {\n        if (direction === _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["DIRECTION"].NEXT) {\n          flicking.next().catch(function () {\n            return void 0;\n          });\n        } else {\n          flicking.prev().catch(function () {\n            return void 0;\n          });\n        }\n\n        _this.play();\n      }, _this._duration);\n    };\n\n    this.stop = function () {\n      clearTimeout(_this._timerId);\n    };\n\n    this._onMouseEnter = function () {\n      _this._mouseEntered = true;\n\n      _this.stop();\n    };\n\n    this._onMouseLeave = function () {\n      _this._mouseEntered = false;\n\n      _this.play();\n    };\n\n    this._duration = duration;\n    this._direction = direction;\n    this._stopOnHover = stopOnHover;\n  }\n\n  var __proto = AutoPlay.prototype;\n  Object.defineProperty(__proto, "duration", {\n    get: function () {\n      return this._duration;\n    },\n    set: function (val) {\n      this._duration = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "direction", {\n    get: function () {\n      return this._direction;\n    },\n    set: function (val) {\n      this._direction = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "stopOnHover", {\n    get: function () {\n      return this._stopOnHover;\n    },\n    set: function (val) {\n      this._stopOnHover = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (flicking) {\n    var _a;\n\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    flicking.on((_a = {}, _a[_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_START] = this.stop, _a[_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].HOLD_START] = this.stop, _a[_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_END] = this.play, _a[_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].SELECT] = this.play, _a));\n    this._flicking = flicking;\n\n    if (this._stopOnHover) {\n      var targetEl = this._flicking.element;\n      targetEl.addEventListener("mouseenter", this._onMouseEnter, false);\n      targetEl.addEventListener("mouseleave", this._onMouseLeave, false);\n    }\n\n    this.play();\n  };\n\n  __proto.destroy = function () {\n    var flicking = this._flicking;\n    this._mouseEntered = false;\n    this.stop();\n\n    if (!flicking) {\n      return;\n    }\n\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_START, this.stop);\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].HOLD_START, this.stop);\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_END, this.play);\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].SELECT, this.play);\n    var targetEl = flicking.element;\n    targetEl.removeEventListener("mouseenter", this._onMouseEnter, false);\n    targetEl.removeEventListener("mouseleave", this._onMouseLeave, false);\n    this._flicking = null;\n  };\n\n  __proto.update = function () {// DO-NOTHING\n  };\n\n  return AutoPlay;\n}();\n\nvar BROWSER = {\n  CLICK: "click",\n  MOUSE_DOWN: "mousedown",\n  TOUCH_START: "touchstart"\n};\n\nvar ARROW = {\n  PREV_SELECTOR: ".flicking-arrow-prev",\n  NEXT_SELECTOR: ".flicking-arrow-next",\n  DISABLED_CLASS: "flicking-arrow-disabled"\n};\nvar PAGINATION = {\n  SELECTOR: ".flicking-pagination",\n  PREFIX: "flicking-pagination",\n  BULLET_WRAPPER_SUFFIX: "bullets",\n  BULLET_SUFFIX: "bullet",\n  BULLET_ACTIVE_SUFFIX: "bullet-active",\n  FRACTION_WRAPPER_SUFFIX: "fraction",\n  FRACTION_CURRENT_SUFFIX: "fraction-current",\n  FRACTION_TOTAL_SUFFIX: "fraction-total",\n  SCROLL_UNINIT_SUFFIX: "uninitialized",\n  SCROLL_WRAPPER_SUFFIX: "scroll",\n  SCROLL_SLIDER_SUFFIX: "slider",\n  SCROLL_PREV_SUFFIX: "bullet-prev",\n  SCROLL_NEXT_SUFFIX: "bullet-next",\n  TYPE: {\n    BULLET: "bullet",\n    FRACTION: "fraction",\n    SCROLL: "scroll"\n  }\n};\nvar SYNC = {\n  TYPE: {\n    CAMERA: "camera",\n    INDEX: "index"\n  }\n};\n\nvar addClass = function (el, className) {\n  if (!el) return;\n\n  if (el.classList) {\n    el.classList.add(className);\n  } else {\n    var classes = el.className.split(" ");\n\n    if (classes.indexOf(className) < 0) {\n      el.className = el.className + " " + className;\n    }\n  }\n};\nvar removeClass = function (el, className) {\n  if (!el) return;\n\n  if (el.classList) {\n    el.classList.remove(className);\n  } else {\n    var classRegex = new RegExp("( |^)" + className + "( |$)", "g");\n    el.className.replace(classRegex, " ");\n  }\n};\nvar getElement = function (selector, parent, pluginName) {\n  var el = parent.querySelector(selector);\n\n  if (!el) {\n    throw new Error("[Flicking-" + pluginName + "] Couldn\'t find element with the given selector: " + selector);\n  }\n\n  return el;\n};\n\n/**\n * A plugin to easily create prev/right arrow button of Flicking\n * @ko 이전/다음 버튼을 쉽게 만들 수 있는 플러그인\n * @memberof Flicking.Plugins\n */\n\nvar Arrow =\n/*#__PURE__*/\nfunction () {\n  function Arrow(_a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.parentEl,\n        parentEl = _c === void 0 ? null : _c,\n        _d = _b.prevElSelector,\n        prevElSelector = _d === void 0 ? ARROW.PREV_SELECTOR : _d,\n        _e = _b.nextElSelector,\n        nextElSelector = _e === void 0 ? ARROW.NEXT_SELECTOR : _e,\n        _f = _b.disabledClass,\n        disabledClass = _f === void 0 ? ARROW.DISABLED_CLASS : _f,\n        _g = _b.moveCount,\n        moveCount = _g === void 0 ? 1 : _g,\n        _h = _b.moveByViewportSize,\n        moveByViewportSize = _h === void 0 ? false : _h;\n    /* Internal Values */\n\n\n    this._flicking = null;\n\n    this._preventInputPropagation = function (e) {\n      e.stopPropagation();\n    };\n\n    this._onPrevClick = function () {\n      var flicking = _this._flicking;\n      var camera = flicking.camera;\n      var anchorPoints = camera.anchorPoints;\n      if (flicking.animating || anchorPoints.length <= 0) return;\n      var firstAnchor = anchorPoints[0];\n      var moveCount = _this._moveCount;\n\n      if (_this._moveByViewportSize) {\n        flicking.control.moveToPosition(camera.position - camera.size, flicking.duration).catch(_this._onCatch);\n      } else {\n        if (flicking.circularEnabled) {\n          var targetPanel = flicking.currentPanel;\n\n          for (var i = 0; i < moveCount; i++) {\n            targetPanel = targetPanel.prev();\n          }\n\n          targetPanel.focus().catch(_this._onCatch);\n        } else if (flicking.index > firstAnchor.panel.index) {\n          flicking.moveTo(Math.max(flicking.index - moveCount, firstAnchor.panel.index)).catch(_this._onCatch);\n        } else if (camera.position > camera.range.min) {\n          flicking.moveTo(flicking.index).catch(_this._onCatch);\n        }\n      }\n    };\n\n    this._onNextClick = function () {\n      var flicking = _this._flicking;\n      var camera = flicking.camera;\n      var anchorPoints = camera.anchorPoints;\n      if (flicking.animating || anchorPoints.length <= 0) return;\n      var lastAnchor = anchorPoints[anchorPoints.length - 1];\n      var moveCount = _this._moveCount;\n\n      if (_this._moveByViewportSize) {\n        flicking.control.moveToPosition(camera.position + camera.size, flicking.duration).catch(_this._onCatch);\n      } else {\n        if (flicking.circularEnabled) {\n          var targetPanel = flicking.currentPanel;\n\n          for (var i = 0; i < moveCount; i++) {\n            targetPanel = targetPanel.next();\n          }\n\n          targetPanel.focus().catch(_this._onCatch);\n        } else if (flicking.index < lastAnchor.panel.index) {\n          flicking.moveTo(Math.min(flicking.index + moveCount, lastAnchor.panel.index)).catch(_this._onCatch);\n        } else if (camera.position > camera.range.min) {\n          flicking.moveTo(flicking.index).catch(_this._onCatch);\n        }\n      }\n    };\n\n    this._onAnimation = function () {\n      var flicking = _this._flicking;\n      var camera = flicking.camera;\n      var controller = flicking.control.controller;\n\n      if (flicking.holding) {\n        _this._updateClass(camera.position);\n      } else {\n        _this._updateClass(controller.animatingContext.end);\n      }\n    };\n\n    this._onCatch = function (err) {\n      if (err instanceof _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["FlickingError"]) return;\n      throw err;\n    };\n\n    this._parentEl = parentEl;\n    this._prevElSelector = prevElSelector;\n    this._nextElSelector = nextElSelector;\n    this._disabledClass = disabledClass;\n    this._moveCount = moveCount;\n    this._moveByViewportSize = moveByViewportSize;\n  }\n\n  var __proto = Arrow.prototype;\n  Object.defineProperty(__proto, "prevEl", {\n    get: function () {\n      return this._prevEl;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "nextEl", {\n    get: function () {\n      return this._nextEl;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "parentEl", {\n    get: function () {\n      return this._parentEl;\n    },\n    set: function (val) {\n      this._parentEl = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "prevElSelector", {\n    get: function () {\n      return this._prevElSelector;\n    },\n    set: function (val) {\n      this._prevElSelector = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "nextElSelector", {\n    get: function () {\n      return this._nextElSelector;\n    },\n    set: function (val) {\n      this._nextElSelector = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "disabledClass", {\n    get: function () {\n      return this._disabledClass;\n    },\n    set: function (val) {\n      this._disabledClass = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "moveCount", {\n    get: function () {\n      return this._moveCount;\n    },\n    set: function (val) {\n      this._moveCount = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "moveByViewportSize", {\n    get: function () {\n      return this._moveByViewportSize;\n    },\n    set: function (val) {\n      this._moveByViewportSize = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (flicking) {\n    var _this = this;\n\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onAnimation);\n    var parentEl = this._parentEl ? this._parentEl : flicking.element;\n    var prevEl = getElement(this._prevElSelector, parentEl, "Arrow");\n    var nextEl = getElement(this._nextElSelector, parentEl, "Arrow");\n    [BROWSER.MOUSE_DOWN, BROWSER.TOUCH_START].forEach(function (evt) {\n      prevEl.addEventListener(evt, _this._preventInputPropagation, {\n        passive: true\n      });\n      nextEl.addEventListener(evt, _this._preventInputPropagation, {\n        passive: true\n      });\n    });\n    prevEl.addEventListener(BROWSER.CLICK, this._onPrevClick);\n    nextEl.addEventListener(BROWSER.CLICK, this._onNextClick);\n    this._prevEl = prevEl;\n    this._nextEl = nextEl;\n    this.update();\n  };\n\n  __proto.destroy = function () {\n    var _this = this;\n\n    var flicking = this._flicking;\n\n    if (!flicking) {\n      return;\n    }\n\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onAnimation);\n    var prevEl = this._prevEl;\n    var nextEl = this._nextEl;\n    [BROWSER.MOUSE_DOWN, BROWSER.TOUCH_START].forEach(function (evt) {\n      prevEl.removeEventListener(evt, _this._preventInputPropagation);\n      nextEl.removeEventListener(evt, _this._preventInputPropagation);\n    });\n    prevEl.removeEventListener(BROWSER.CLICK, this._onPrevClick);\n    nextEl.removeEventListener(BROWSER.CLICK, this._onNextClick);\n    this._flicking = null;\n  };\n\n  __proto.update = function () {\n    this._updateClass(this._flicking.camera.position);\n  };\n\n  __proto._updateClass = function (pos) {\n    var flicking = this._flicking;\n    var disabledClass = this._disabledClass;\n    var prevEl = this._prevEl;\n    var nextEl = this._nextEl;\n    var cameraRange = flicking.camera.range;\n    var stopAtPrevEdge = flicking.circularEnabled ? false : pos <= cameraRange.min;\n    var stopAtNextEdge = flicking.circularEnabled ? false : pos >= cameraRange.max;\n\n    if (stopAtPrevEdge) {\n      addClass(prevEl, disabledClass);\n    } else {\n      removeClass(prevEl, disabledClass);\n    }\n\n    if (stopAtNextEdge) {\n      addClass(nextEl, disabledClass);\n    } else {\n      removeClass(nextEl, disabledClass);\n    }\n  };\n\n  return Arrow;\n}();\n\n/**\n * Plugin for synchronizing multiple flickings\n * @ko 다양한 형태로 Flicking들이 같이 움직이게 할 수 있습니다.\n * @memberof Flicking.Plugins\n */\n\nvar Sync =\n/*#__PURE__*/\nfunction () {\n  /** */\n  function Sync(_a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.type,\n        type = _c === void 0 ? SYNC.TYPE.CAMERA : _c,\n        _d = _b.synchronizedFlickingOptions,\n        synchronizedFlickingOptions = _d === void 0 ? [] : _d;\n    /* Internal Values */\n\n\n    this._flicking = null;\n\n    this._addEvents = function () {\n      var type = _this._type;\n      var synced = _this._synchronizedFlickingOptions;\n      synced.forEach(function (_a) {\n        var flicking = _a.flicking,\n            isSlidable = _a.isSlidable,\n            isClickable = _a.isClickable;\n\n        if (type === SYNC.TYPE.CAMERA) {\n          flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, _this._onMove);\n          flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_START, _this._onMoveStart);\n          flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_END, _this._onMoveEnd);\n        }\n\n        if (type === SYNC.TYPE.INDEX && isSlidable) {\n          flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_CHANGE, _this._onIndexChange);\n          flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_RESTORE, _this._onIndexChange);\n        }\n\n        if (isClickable) {\n          flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].SELECT, _this._onSelect);\n        }\n      });\n    };\n\n    this._removeEvents = function () {\n      var type = _this._type;\n      var synced = _this._synchronizedFlickingOptions;\n      synced.forEach(function (_a) {\n        var flicking = _a.flicking,\n            isSlidable = _a.isSlidable,\n            isClickable = _a.isClickable;\n\n        if (type === SYNC.TYPE.CAMERA) {\n          flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, _this._onMove);\n          flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_START, _this._onMoveStart);\n          flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_END, _this._onMoveEnd);\n        }\n\n        if (type === SYNC.TYPE.INDEX && isSlidable) {\n          flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_CHANGE, _this._onIndexChange);\n          flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_RESTORE, _this._onIndexChange);\n        }\n\n        if (isClickable) {\n          flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].SELECT, _this._onSelect);\n        }\n      });\n    };\n\n    this._onIndexChange = function (e) {\n      var flicking = e.currentTarget;\n\n      if (!flicking.initialized) {\n        return;\n      }\n\n      _this._synchronizeByIndex(flicking, e.index);\n    };\n\n    this._onMove = function (e) {\n      var camera = e.currentTarget.camera;\n      var progress = (camera.position - camera.range.min) / camera.rangeDiff;\n\n      _this._synchronizedFlickingOptions.forEach(function (_a) {\n        var flicking = _a.flicking;\n        if (flicking === e.currentTarget) return;\n        var targetPosition = 0;\n\n        if (camera.position < camera.range.min) {\n          targetPosition = camera.position;\n        } else if (camera.position > camera.range.max) {\n          targetPosition = flicking.camera.range.max + camera.position - camera.range.max;\n        } else {\n          targetPosition = flicking.camera.range.min + flicking.camera.rangeDiff * progress;\n        }\n\n        void flicking.camera.lookAt(targetPosition);\n      });\n    };\n\n    this._onMoveStart = function (e) {\n      _this._synchronizedFlickingOptions.forEach(function (_a) {\n        var flicking = _a.flicking;\n\n        if (flicking !== e.currentTarget) {\n          flicking.disableInput();\n        }\n      });\n    };\n\n    this._onMoveEnd = function (e) {\n      _this._synchronizedFlickingOptions.forEach(function (_a) {\n        var flicking = _a.flicking;\n\n        if (flicking !== e.currentTarget) {\n          flicking.enableInput();\n          flicking.control.updateInput();\n        }\n      });\n    };\n\n    this._onSelect = function (e) {\n      void e.currentTarget.moveTo(e.index).catch(function () {\n        return void 0;\n      });\n\n      _this._synchronizeByIndex(e.currentTarget, e.index);\n    };\n\n    this._synchronizeByIndex = function (activeFlicking, index) {\n      var synchronizedFlickingOptions = _this._synchronizedFlickingOptions;\n\n      _this._preventEvent(function () {\n        synchronizedFlickingOptions.forEach(function (options) {\n          // Active class should be applied same to the Flicking which triggered event\n          _this._updateClass(options, index);\n\n          var flicking = options.flicking;\n          if (flicking === activeFlicking) return;\n          var targetIndex = Object(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["clamp"])(index, 0, flicking.panels.length);\n\n          if (flicking.animating) {\n            // Reserve moveTo once previous animation is finished\n            flicking.once(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE_END, function () {\n              void flicking.moveTo(targetIndex).catch(function () {\n                return void 0;\n              });\n            });\n          } else {\n            void flicking.moveTo(targetIndex);\n          }\n        });\n      });\n    };\n\n    this._updateClass = function (_a, index) {\n      var flicking = _a.flicking,\n          activeClass = _a.activeClass;\n      if (!activeClass) return;\n      flicking.panels.forEach(function (panel) {\n        if (panel.index === index) {\n          addClass(panel.element, activeClass);\n        } else {\n          removeClass(panel.element, activeClass);\n        }\n      });\n    };\n\n    this._type = type;\n    this._synchronizedFlickingOptions = synchronizedFlickingOptions;\n  }\n\n  var __proto = Sync.prototype;\n  Object.defineProperty(__proto, "type", {\n    get: function () {\n      return this._type;\n    },\n    set: function (val) {\n      this._type = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "synchronizedFlickingOptions", {\n    get: function () {\n      return this._synchronizedFlickingOptions;\n    },\n    set: function (val) {\n      this._synchronizedFlickingOptions = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (flicking) {\n    var _this = this;\n\n    var synced = this._synchronizedFlickingOptions;\n\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n\n    this._addEvents();\n\n    synced.forEach(function (options) {\n      var syncedFlicking = options.flicking;\n\n      _this._updateClass(options, syncedFlicking.defaultIndex);\n    });\n  };\n\n  __proto.destroy = function () {\n    var flicking = this._flicking;\n\n    if (!flicking) {\n      return;\n    }\n\n    this._removeEvents();\n\n    this._flicking = null;\n  };\n\n  __proto.update = function () {\n    var _this = this;\n\n    this._synchronizedFlickingOptions.forEach(function (options) {\n      _this._updateClass(options, options.flicking.index);\n    });\n  };\n\n  __proto._preventEvent = function (fn) {\n    this._removeEvents();\n\n    fn();\n\n    this._addEvents();\n  };\n\n  return Sync;\n}();\n\n/* eslint-disable no-underscore-dangle */\n/**\n * You can apply perspective effect while panel is moving.\n * @ko 패널들을 움직이면서 입체감을 부여할 수 있습니다.\n * @memberof Flicking.Plugins\n */\n\nvar Perspective =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param - The selector of the element to which the perspective effect is to be applied. If the selector is blank, it applies to panel element. <ko>입체 효과를 적용할 대상의 선택자. 선택자가 공백이면 패널 엘리먼트에 적용된다.</ko>\n   * @param - Effect amplication scale.<ko>효과 증폭도</ko>\n   * @param - Effect amplication rotate.<ko>회전 증폭도</ko>\n   * @param - The value of perspective CSS property. <ko>css perspective 속성 값</ko>\n   * @example\n   * ```ts\n   * flicking.addPlugins(new Perspective({ selector: "p", scale: 1, rotate: 1, perspective = 1000 }));\n   * ```\n   */\n  function Perspective(_a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.selector,\n        selector = _c === void 0 ? "" : _c,\n        _d = _b.scale,\n        scale = _d === void 0 ? 1 : _d,\n        _e = _b.rotate,\n        rotate = _e === void 0 ? 1 : _e,\n        _f = _b.perspective,\n        perspective = _f === void 0 ? 1000 : _f;\n\n    this.update = function () {\n      _this._onMove();\n    };\n\n    this._onMove = function () {\n      var flicking = _this._flicking;\n      var selector = _this._selector;\n      var scale = _this._scale;\n      var rotate = _this._rotate;\n      var perspective = _this._perspective;\n      if (!flicking) return;\n      var horizontal = flicking.horizontal;\n      var panels = flicking.visiblePanels;\n      panels.forEach(function (panel) {\n        var progress = panel.outsetProgress;\n        var el = panel.element;\n        var target = selector ? el.querySelector(selector) : el;\n        var panelScale = 1 / (Math.abs(progress * scale) + 1);\n        var rotateDegree = progress > 0 ? Math.min(90, progress * 100 * rotate) : Math.max(-90, progress * 100 * rotate);\n\n        var _a = horizontal ? [0, rotateDegree] : [rotateDegree, 0],\n            rotateX = _a[0],\n            rotateY = _a[1];\n\n        target.style.transform = "perspective(" + perspective + "px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg) scale(" + panelScale + ")";\n      });\n    };\n\n    this._flicking = null;\n    this._selector = selector;\n    this._scale = scale;\n    this._rotate = rotate;\n    this._perspective = perspective;\n  }\n\n  var __proto = Perspective.prototype;\n  Object.defineProperty(__proto, "selector", {\n    get: function () {\n      return this._selector;\n    },\n    set: function (val) {\n      this._selector = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "scale", {\n    get: function () {\n      return this._scale;\n    },\n    set: function (val) {\n      this._scale = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "rotate", {\n    get: function () {\n      return this._rotate;\n    },\n    set: function (val) {\n      this._rotate = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "perspective", {\n    get: function () {\n      return this._perspective;\n    },\n    set: function (val) {\n      this._perspective = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (flicking) {\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onMove);\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].AFTER_RESIZE, this.update);\n\n    this._onMove();\n  };\n\n  __proto.destroy = function () {\n    if (!this._flicking) return;\n\n    this._flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].MOVE, this._onMove);\n\n    this._flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].AFTER_RESIZE, this.update);\n\n    this._flicking = null;\n  };\n\n  return Perspective;\n}();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || from);\n}\n\nvar Renderer =\n/*#__PURE__*/\nfunction () {\n  function Renderer(_a) {\n    var flicking = _a.flicking,\n        pagination = _a.pagination,\n        wrapper = _a.wrapper;\n    this._flicking = flicking;\n    this._pagination = pagination;\n    this._wrapper = wrapper;\n  }\n\n  return Renderer;\n}();\n\nvar BulletRenderer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(BulletRenderer, _super);\n\n  function BulletRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._childs = [];\n    return _this;\n  }\n\n  var __proto = BulletRenderer.prototype;\n\n  __proto.render = function () {\n    var flicking = this._flicking;\n    var pagination = this._pagination;\n    var renderBullet = pagination.renderBullet;\n    var bulletWrapperClass = pagination.classPrefix + "-" + PAGINATION.BULLET_WRAPPER_SUFFIX;\n    var bulletClass = pagination.classPrefix + "-" + PAGINATION.BULLET_SUFFIX;\n    var bulletActiveClass = pagination.classPrefix + "-" + PAGINATION.BULLET_ACTIVE_SUFFIX;\n    var anchorPoints = flicking.camera.anchorPoints;\n    var wrapper = this._wrapper;\n    addClass(wrapper, bulletWrapperClass);\n    wrapper.innerHTML = anchorPoints.map(function (_, index) {\n      return renderBullet(bulletClass, index);\n    }).join("\\n");\n    var bullets = [].slice.call(wrapper.children);\n    bullets.forEach(function (bullet, index) {\n      var anchorPoint = anchorPoints[index];\n\n      if (anchorPoint.panel.index === flicking.index) {\n        addClass(bullet, bulletActiveClass);\n      }\n\n      bullet.addEventListener(BROWSER.MOUSE_DOWN, function (e) {\n        e.stopPropagation();\n      });\n      bullet.addEventListener(BROWSER.TOUCH_START, function (e) {\n        e.stopPropagation();\n      }, {\n        passive: true\n      });\n      bullet.addEventListener(BROWSER.CLICK, function () {\n        flicking.moveTo(anchorPoint.panel.index).catch(function (err) {\n          if (err instanceof _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["FlickingError"]) return;\n          throw err;\n        });\n      });\n    });\n    this._childs = bullets;\n  };\n\n  __proto.update = function (index) {\n    var flicking = this._flicking;\n    var pagination = this._pagination;\n    var bullets = this._childs;\n    var activeClass = pagination.classPrefix + "-" + PAGINATION.BULLET_ACTIVE_SUFFIX;\n    var anchorPoints = flicking.camera.anchorPoints;\n    if (anchorPoints.length <= 0) return;\n    bullets.forEach(function (bullet) {\n      removeClass(bullet, activeClass);\n    });\n    var anchorOffset = anchorPoints[0].panel.index;\n    var activeBullet = bullets[index - anchorOffset];\n    addClass(activeBullet, activeClass);\n  };\n\n  return BulletRenderer;\n}(Renderer);\n\nvar FractionRenderer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(FractionRenderer, _super);\n\n  function FractionRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  var __proto = FractionRenderer.prototype;\n\n  __proto.render = function () {\n    var flicking = this._flicking;\n    var wrapper = this._wrapper;\n    var pagination = this._pagination;\n    var fractionWrapperClass = pagination.classPrefix + "-" + PAGINATION.FRACTION_WRAPPER_SUFFIX;\n    var fractionCurrentClass = pagination.classPrefix + "-" + PAGINATION.FRACTION_CURRENT_SUFFIX;\n    var fractionTotalClass = pagination.classPrefix + "-" + PAGINATION.FRACTION_TOTAL_SUFFIX;\n    addClass(wrapper, fractionWrapperClass);\n    wrapper.innerHTML = pagination.renderFraction(fractionCurrentClass, fractionTotalClass);\n    this.update(flicking.index);\n  };\n\n  __proto.update = function (index) {\n    var flicking = this._flicking;\n    var wrapper = this._wrapper;\n    var pagination = this._pagination;\n    var fractionCurrentClass = pagination.classPrefix + "-" + PAGINATION.FRACTION_CURRENT_SUFFIX;\n    var fractionTotalClass = pagination.classPrefix + "-" + PAGINATION.FRACTION_TOTAL_SUFFIX;\n    var currentWrapper = wrapper.querySelector("." + fractionCurrentClass);\n    var totalWrapper = wrapper.querySelector("." + fractionTotalClass);\n    var anchorPoints = flicking.camera.anchorPoints;\n    var currentIndex = anchorPoints.length > 0 ? index - anchorPoints[0].panel.index + 1 : 0;\n    currentWrapper.innerHTML = pagination.fractionCurrentFormat(currentIndex);\n    totalWrapper.innerHTML = pagination.fractionTotalFormat(anchorPoints.length);\n  };\n\n  return FractionRenderer;\n}(Renderer);\n\nvar ScrollBulletRenderer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ScrollBulletRenderer, _super);\n\n  function ScrollBulletRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._bullets = [];\n    _this._bulletSize = 0;\n    _this._previousIndex = -1;\n    _this._sliderIndex = -1;\n\n    _this.moveTo = function (index) {\n      var pagination = _this._pagination;\n      var sliderEl = _this._wrapper.firstElementChild;\n      var bulletSize = _this._bulletSize;\n      var wrapperSize = bulletSize * pagination.bulletCount;\n      sliderEl.style.transform = "translate(" + (wrapperSize / 2 - (index + 0.5) * bulletSize) + "px)";\n      _this._sliderIndex = index;\n    };\n\n    return _this;\n  }\n\n  var __proto = ScrollBulletRenderer.prototype;\n\n  __proto.render = function () {\n    var wrapper = this._wrapper;\n    var flicking = this._flicking;\n    var pagination = this._pagination;\n    var renderBullet = pagination.renderBullet;\n    var anchorPoints = flicking.camera.anchorPoints;\n    var dynamicWrapperClass = pagination.classPrefix + "-" + PAGINATION.SCROLL_WRAPPER_SUFFIX;\n    var bulletClass = pagination.classPrefix + "-" + PAGINATION.BULLET_SUFFIX;\n    var sliderClass = pagination.classPrefix + "-" + PAGINATION.SCROLL_SLIDER_SUFFIX;\n    var uninitClass = pagination.classPrefix + "-" + PAGINATION.SCROLL_UNINIT_SUFFIX;\n    var sliderEl = document.createElement("div");\n    addClass(sliderEl, sliderClass);\n    addClass(wrapper, uninitClass);\n    addClass(wrapper, dynamicWrapperClass);\n    wrapper.appendChild(sliderEl);\n    sliderEl.innerHTML = anchorPoints.map(function (_, index) {\n      return renderBullet(bulletClass, index);\n    }).join("\\n");\n    var bullets = [].slice.call(sliderEl.children);\n    bullets.forEach(function (bullet, index) {\n      var anchorPoint = anchorPoints[index];\n      bullet.addEventListener(BROWSER.MOUSE_DOWN, function (e) {\n        e.stopPropagation();\n      });\n      bullet.addEventListener(BROWSER.TOUCH_START, function (e) {\n        e.stopPropagation();\n      }, {\n        passive: true\n      });\n      bullet.addEventListener(BROWSER.CLICK, function () {\n        flicking.moveTo(anchorPoint.panel.index).catch(function (err) {\n          if (err instanceof _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["FlickingError"]) return;\n          throw err;\n        });\n      });\n    });\n    if (bullets.length <= 0) return;\n    var bulletStyle = getComputedStyle(bullets[0]);\n    var bulletSize = bullets[0].clientWidth + parseFloat(bulletStyle.marginLeft) + parseFloat(bulletStyle.marginRight);\n    wrapper.style.width = bulletSize * pagination.bulletCount + "px";\n    this._bullets = bullets;\n    this._bulletSize = bulletSize;\n    this.update(this._flicking.index);\n    window.requestAnimationFrame(function () {\n      removeClass(wrapper, uninitClass);\n    });\n  };\n\n  __proto.update = function (index) {\n    var pagination = this._pagination;\n    var flicking = this._flicking;\n    var bullets = this._bullets;\n    var prevIndex = this._previousIndex;\n    var anchorPoints = flicking.camera.anchorPoints;\n    var anchorOffset = anchorPoints[0].panel.index;\n    var activeIndex = index - anchorOffset;\n    if (anchorPoints.length <= 0) return;\n    var bulletActiveClass = pagination.classPrefix + "-" + PAGINATION.BULLET_ACTIVE_SUFFIX;\n    var prevClassPrefix = pagination.classPrefix + "-" + PAGINATION.SCROLL_PREV_SUFFIX;\n    var nextClassPrefix = pagination.classPrefix + "-" + PAGINATION.SCROLL_NEXT_SUFFIX;\n\n    var bulletPrevClass = function (offset) {\n      return "" + prevClassPrefix + (offset > 1 ? offset : "");\n    };\n\n    var bulletNextClass = function (offset) {\n      return "" + nextClassPrefix + (offset > 1 ? offset : "");\n    };\n\n    var prevClassRegex = new RegExp("^" + prevClassPrefix);\n    var nextClassRegex = new RegExp("^" + nextClassPrefix);\n    bullets.forEach(function (bullet, idx) {\n      var indexOffset = idx - activeIndex;\n      var classList = bullet.className.split(" ");\n\n      for (var _i = 0, classList_1 = classList; _i < classList_1.length; _i++) {\n        var className = classList_1[_i];\n\n        if (className === bulletActiveClass || prevClassRegex.test(className) || nextClassRegex.test(className)) {\n          removeClass(bullet, className);\n        }\n      }\n\n      if (indexOffset === 0) {\n        addClass(bullet, bulletActiveClass);\n      } else if (indexOffset > 0) {\n        addClass(bullet, bulletNextClass(Math.abs(indexOffset)));\n      } else {\n        addClass(bullet, bulletPrevClass(Math.abs(indexOffset)));\n      }\n    });\n    pagination.scrollOnChange(activeIndex, {\n      total: bullets.length,\n      prevIndex: prevIndex,\n      sliderIndex: this._sliderIndex,\n      direction: activeIndex > prevIndex ? _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["DIRECTION"].NEXT : _egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["DIRECTION"].PREV,\n      bullets: __spreadArray([], bullets),\n      moveTo: this.moveTo\n    });\n    this._previousIndex = activeIndex;\n  };\n\n  return ScrollBulletRenderer;\n}(Renderer);\n\n/**\n * @memberof Flicking.Plugins\n */\n\nvar Pagination =\n/*#__PURE__*/\nfunction () {\n  function Pagination(_a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.parentEl,\n        parentEl = _c === void 0 ? null : _c,\n        _d = _b.selector,\n        selector = _d === void 0 ? PAGINATION.SELECTOR : _d,\n        _e = _b.type,\n        type = _e === void 0 ? PAGINATION.TYPE.BULLET : _e,\n        _f = _b.classPrefix,\n        classPrefix = _f === void 0 ? PAGINATION.PREFIX : _f,\n        _g = _b.bulletCount,\n        bulletCount = _g === void 0 ? 5 : _g,\n        _h = _b.renderBullet,\n        renderBullet = _h === void 0 ? function (className) {\n      return "<span class=\\"" + className + "\\"></span>";\n    } : _h,\n        _j = _b.renderFraction,\n        renderFraction = _j === void 0 ? function (currentClass, totalClass) {\n      return "<span class=\\"" + currentClass + "\\"></span>/<span class=\\"" + totalClass + "\\"></span>";\n    } : _j,\n        _k = _b.fractionCurrentFormat,\n        fractionCurrentFormat = _k === void 0 ? function (index) {\n      return index.toString();\n    } : _k,\n        _l = _b.fractionTotalFormat,\n        fractionTotalFormat = _l === void 0 ? function (index) {\n      return index.toString();\n    } : _l,\n        _m = _b.scrollOnChange,\n        scrollOnChange = _m === void 0 ? function (index, ctx) {\n      return ctx.moveTo(index);\n    } : _m;\n    /* Internal Values */\n\n\n    this._flicking = null;\n\n    this.update = function () {\n      _this._removeAllChilds();\n\n      _this._renderer.render();\n    };\n\n    this._onIndexChange = function (evt) {\n      _this._renderer.update(evt.index);\n    };\n\n    this._parentEl = parentEl;\n    this._selector = selector;\n    this._type = type;\n    this._classPrefix = classPrefix;\n    this._bulletCount = bulletCount;\n    this._renderBullet = renderBullet;\n    this._renderFraction = renderFraction;\n    this._fractionCurrentFormat = fractionCurrentFormat;\n    this._fractionTotalFormat = fractionTotalFormat;\n    this._scrollOnChange = scrollOnChange;\n  }\n\n  var __proto = Pagination.prototype;\n  Object.defineProperty(__proto, "parentEl", {\n    get: function () {\n      return this._parentEl;\n    },\n    set: function (val) {\n      this._parentEl = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "selector", {\n    get: function () {\n      return this._selector;\n    },\n    set: function (val) {\n      this._selector = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "type", {\n    get: function () {\n      return this._type;\n    },\n    set: function (val) {\n      this._type = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "classPrefix", {\n    get: function () {\n      return this._classPrefix;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "bulletCount", {\n    get: function () {\n      return this._bulletCount;\n    },\n    set: function (val) {\n      this._bulletCount = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "renderBullet", {\n    get: function () {\n      return this._renderBullet;\n    },\n    set: function (val) {\n      this._renderBullet = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "renderFraction", {\n    get: function () {\n      return this._renderFraction;\n    },\n    set: function (val) {\n      this._renderFraction = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "fractionCurrentFormat", {\n    get: function () {\n      return this._fractionCurrentFormat;\n    },\n    set: function (val) {\n      this._fractionCurrentFormat = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "fractionTotalFormat", {\n    get: function () {\n      return this._fractionTotalFormat;\n    },\n    set: function (val) {\n      this._fractionTotalFormat = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "scrollOnChange", {\n    get: function () {\n      return this._scrollOnChange;\n    },\n    set: function (val) {\n      this._scrollOnChange = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, "bulletWrapperclassPrefixClass", {\n    set: function (val) {\n      this._classPrefix = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (flicking) {\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n    var type = this._type;\n    var selector = this._selector;\n    var parentEl = this._parentEl ? this._parentEl : flicking.element;\n    var wrapper = parentEl.querySelector(selector);\n\n    if (!wrapper) {\n      throw new Error("[Flicking-Pagination] Couldn\'t find element with the given selector: " + selector);\n    }\n\n    this._wrapper = wrapper;\n    this._renderer = this._createRenderer(type);\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_CHANGE, this._onIndexChange);\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_RESTORE, this._onIndexChange);\n    flicking.on(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].PANEL_CHANGE, this.update);\n    this.update();\n  };\n\n  __proto.destroy = function () {\n    var flicking = this._flicking;\n\n    if (!flicking) {\n      return;\n    }\n\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_CHANGE, this._onIndexChange);\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].WILL_RESTORE, this._onIndexChange);\n    flicking.off(_egjs_flicking__WEBPACK_IMPORTED_MODULE_0__["EVENTS"].PANEL_CHANGE, this.update);\n\n    this._removeAllChilds();\n\n    this._flicking = null;\n  };\n\n  __proto._createRenderer = function (type) {\n    var options = {\n      flicking: this._flicking,\n      pagination: this,\n      wrapper: this._wrapper\n    };\n\n    switch (type) {\n      case PAGINATION.TYPE.BULLET:\n        return new BulletRenderer(options);\n\n      case PAGINATION.TYPE.FRACTION:\n        return new FractionRenderer(options);\n\n      case PAGINATION.TYPE.SCROLL:\n        return new ScrollBulletRenderer(options);\n\n      default:\n        throw new Error("[Flicking-Pagination] type \\"" + type + "\\" is not supported.");\n    }\n  };\n\n  __proto._removeAllChilds = function () {\n    var wrapper = this._wrapper;\n\n    while (wrapper.firstChild) {\n      wrapper.removeChild(wrapper.firstChild);\n    }\n  };\n\n  return Pagination;\n}();\n\n/**\n * @namespace Flicking\n */\n\n\n//# sourceMappingURL=plugins.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvZmxpY2tpbmctcGx1Z2lucy9kaXN0L3BsdWdpbnMuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL2ZsaWNraW5nLXBsdWdpbnMvZGlzdC9wbHVnaW5zLmVzbS5qcz80MWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvZmxpY2tpbmctcGx1Z2luc1xubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1mbGlja2luZy1wbHVnaW5zXG52ZXJzaW9uOiA0LjQuMFxuKi9cbmltcG9ydCB7IEVWRU5UUywgRElSRUNUSU9OLCBGbGlja2luZ0Vycm9yLCBjbGFtcCB9IGZyb20gJ0BlZ2pzL2ZsaWNraW5nJztcblxuLyoqXG4gKiBZb3UgY2FuIGFwcGx5IHBhcmFsbGF4IGVmZmVjdCB3aGlsZSBwYW5lbCBpcyBtb3ZpbmcuXG4gKiBAa28g7Yyo64SQ65Ok7J2EIOybgOyngeydtOuptOyEnCBwYXJhbGxheCDtmqjqs7zrpbwg67aA7Jes7ZWgIOyImCDsnojsirXri4jri6QuXG4gKiBAbWVtYmVyb2YgRmxpY2tpbmcuUGx1Z2luc1xuICovXG5cbnZhciBQYXJhbGxheCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3Igb2YgdGhlIGVsZW1lbnQgdG8gYXBwbHkgcGFyYWxsYXggZWZmZWN0PGtvPiBQYXJhbGxheCDtmqjqs7zrpbwg7KCB7Jqp7ZWgIOyXmOumrOuovO2KuOydmCDshKDtg53snpAgPC9rbz5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIEVmZmVjdCBhbXBsaWNhdGlvbiBzY2FsZTxrbz7tmqjqs7wg7Kad7Y+t64+EPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogZmxpY2tpbmcuYWRkUGx1Z2lucyhuZXcgUGFyYWxsYXgoXCJpbWdcIiwgMSkpO1xuICAgKiBgYGBcbiAgICovXG4gIGZ1bmN0aW9uIFBhcmFsbGF4KHNlbGVjdG9yLCBzY2FsZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoc2VsZWN0b3IgPT09IHZvaWQgMCkge1xuICAgICAgc2VsZWN0b3IgPSBcIlwiO1xuICAgIH1cblxuICAgIGlmIChzY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzY2FsZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fb25Nb3ZlKCk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZyA9IF90aGlzLl9mbGlja2luZztcbiAgICAgIGlmICghZmxpY2tpbmcpIHJldHVybjtcbiAgICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy52aXNpYmxlUGFuZWxzO1xuICAgICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHBhbmVsLm91dHNldFByb2dyZXNzO1xuICAgICAgICB2YXIgZWwgPSBwYW5lbC5lbGVtZW50O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gX3RoaXMuX3NlbGVjdG9yID8gZWwucXVlcnlTZWxlY3RvcihfdGhpcy5fc2VsZWN0b3IpIDogZWw7XG4gICAgICAgIHZhciBwYXJlbnRUYXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwYXJlbnRSZWN0ID0gcGFyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSAocGFyZW50UmVjdC53aWR0aCAtIHJlY3Qud2lkdGgpIC8gMiAqIHByb2dyZXNzICogX3RoaXMuX3NjYWxlO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoLTUwJSkgdHJhbnNsYXRlKFwiICsgcG9zaXRpb24gKyBcInB4KVwiO1xuICAgICAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgKz0gXCJ0cmFuc2Zvcm06IFwiICsgdHJhbnNmb3JtICsgXCI7LXdlYmtpdC10cmFuc2Zvcm06IFwiICsgdHJhbnNmb3JtICsgXCI7LW1zLXRyYW5zZm9ybTpcIiArIHRyYW5zZm9ybTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBQYXJhbGxheC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInNlbGVjdG9yXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RvcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fc2VsZWN0b3IgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInNjYWxlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fc2NhbGUgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgaWYgKHRoaXMuX2ZsaWNraW5nKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIGZsaWNraW5nLm9uKEVWRU5UUy5NT1ZFLCB0aGlzLl9vbk1vdmUpO1xuICAgIGZsaWNraW5nLm9uKEVWRU5UUy5BRlRFUl9SRVNJWkUsIHRoaXMudXBkYXRlKTtcblxuICAgIHRoaXMuX29uTW92ZSgpO1xuICB9O1xuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2ZsaWNraW5nKSByZXR1cm47XG5cbiAgICB0aGlzLl9mbGlja2luZy5vZmYoRVZFTlRTLk1PVkUsIHRoaXMuX29uTW92ZSk7XG5cbiAgICB0aGlzLl9mbGlja2luZy5vZmYoRVZFTlRTLkFGVEVSX1JFU0laRSwgdGhpcy51cGRhdGUpO1xuXG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQYXJhbGxheDtcbn0oKTtcblxuLyoqXG4gKiBZb3UgY2FuIGFwcGx5IGZhZGUgaW4gLyBvdXQgZWZmZWN0IHdoaWxlIHBhbmVsIGlzIG1vdmluZy5cbiAqIEBrbyDtjKjrhJDrk6TsnYQg7JuA7KeB7J2066m07IScIGZhZGUgaW4gLyBvdXQg7Zqo6rO866W8IOu2gOyXrO2VoCDsiJgg7J6I7Iq164uI64ukLlxuICogQG1lbWJlcm9mIEZsaWNraW5nLlBsdWdpbnNcbiAqL1xuXG52YXIgRmFkZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBUaGUgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGZhZGUgZWZmZWN0IGlzIHRvIGJlIGFwcGxpZWQuIElmIHRoZSBzZWxlY3RvciBpcyBibGFuaywgaXQgYXBwbGllcyB0byBwYW5lbCBlbGVtZW50LiA8a28+RmFkZSDtmqjqs7zrpbwg7KCB7Jqp7ZWgIOuMgOyDgeydmCDshKDtg53snpAuIOyEoO2DneyekOqwgCDqs7XrsLHsnbTrqbQg7Yyo64SQIOyXmOumrOuovO2KuOyXkCDsoIHsmqnrkJzri6QuPC9rbz5cbiAgICogQHBhcmFtIC0gRWZmZWN0IGFtcGxpY2F0aW9uIHNjYWxlPGtvPu2aqOqzvCDspp3tj63rj4Q8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBmbGlja2luZy5hZGRQbHVnaW5zKG5ldyBGYWRlKFwicFwiLCAxKSk7XG4gICAqIGBgYFxuICAgKi9cbiAgZnVuY3Rpb24gRmFkZShzZWxlY3Rvciwgc2NhbGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHNlbGVjdG9yID09PSB2b2lkIDApIHtcbiAgICAgIHNlbGVjdG9yID0gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgc2NhbGUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX29uTW92ZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLl9vbk1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSBfdGhpcy5fZmxpY2tpbmc7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBfdGhpcy5fc2VsZWN0b3I7XG4gICAgICB2YXIgc2NhbGUgPSBfdGhpcy5fc2NhbGU7XG4gICAgICBpZiAoIWZsaWNraW5nKSByZXR1cm47XG4gICAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcudmlzaWJsZVBhbmVscztcbiAgICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBwYW5lbC5vdXRzZXRQcm9ncmVzcztcbiAgICAgICAgdmFyIGVsID0gcGFuZWwuZWxlbWVudDtcbiAgICAgICAgdmFyIHRhcmdldCA9IHNlbGVjdG9yID8gZWwucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBlbDtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCAxIC0gTWF0aC5hYnMocHJvZ3Jlc3MgKiBzY2FsZSkpKTtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSBcIlwiICsgb3BhY2l0eTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBGYWRlLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic2VsZWN0b3JcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9zZWxlY3RvciA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic2NhbGVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9zY2FsZSA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICBpZiAodGhpcy5fZmxpY2tpbmcpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgZmxpY2tpbmcub24oRVZFTlRTLk1PVkUsIHRoaXMuX29uTW92ZSk7XG4gICAgZmxpY2tpbmcub24oRVZFTlRTLkFGVEVSX1JFU0laRSwgdGhpcy51cGRhdGUpO1xuXG4gICAgdGhpcy5fb25Nb3ZlKCk7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fZmxpY2tpbmcpIHJldHVybjtcblxuICAgIHRoaXMuX2ZsaWNraW5nLm9mZihFVkVOVFMuTU9WRSwgdGhpcy5fb25Nb3ZlKTtcblxuICAgIHRoaXMuX2ZsaWNraW5nLm9mZihFVkVOVFMuQUZURVJfUkVTSVpFLCB0aGlzLnVwZGF0ZSk7XG5cbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEZhZGU7XG59KCk7XG5cbi8qKlxuICogUGx1Z2luIHRoYXQgYWxsb3cgeW91IHRvIGF1dG9tYXRpY2FsbHkgbW92ZSB0byB0aGUgbmV4dC9wcmV2aW91cyBwYW5lbCwgb24gYSBzcGVjaWZpYyB0aW1lIGJhc2lzXG4gKiBAa28g7J287KCVIOyLnOqwhOuniOuLpCwg7J6Q64+Z7Jy866GcIOuLpOydjC/snbTsoIQg7Yyo64SQ66GcIOuEmOyWtOqwgOuPhOuhnSDtlaAg7IiYIOyeiOuKlCDtlIzrn6zqt7jsnbhcbiAqIEBtZW1iZXJvZiBGbGlja2luZy5QbHVnaW5zXG4gKi9cblxudmFyIEF1dG9QbGF5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXV0b1BsYXlPcHRpb25zfSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBBdXRvUGxheSBpbnN0YW5jZS48a28+QXV0b1BsYXkg7Ji17IWYPC9rbz5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZHVyYXRpb24gVGltZSB0byB3YWl0IGJlZm9yZSBtb3Zpbmcgb24gdG8gdGhlIG5leHQgcGFuZWwuPGtvPuuLpOydjCDtjKjrhJDroZwg7JuA7KeB7J206riw6rmM7KeAIOuMgOq4sCDsi5zqsIQ8L2tvPlxuICAgKiBAcGFyYW0ge1wiUFJFVlwiIHwgXCJORVhUXCJ9IG9wdGlvbnMuZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIHBhbmVsIG1vdmVzLjxrbz7tjKjrhJDsnbQg7JuA7KeB7J2064qUIOuwqe2WpTwva28+XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zdG9wT25Ib3ZlciBXaGV0aGVyIHRvIHN0b3Agd2hlbiBtb3VzZSBob3ZlciB1cG9uIHRoZSBlbGVtZW50Ljxrbz7sl5jrpqzrqLztirjsl5Ag66eI7Jqw7Iqk66W8IOyYrOuguOydhCDrlYwgQXV0b1BsYXnrpbwg7KCV7KeA7ZWg7KeAIOyXrOu2gDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGZsaWNraW5nLmFkZFBsdWdpbnMobmV3IEF1dG9QbGF5KHsgZHVyYXRpb246IDIwMDAsIGRpcmVjdGlvbjogXCJORVhUXCIgfSkpO1xuICAgKiBgYGBcbiAgICovXG4gIGZ1bmN0aW9uIEF1dG9QbGF5KF9hKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICBfYyA9IF9iLmR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvbiA9IF9jID09PSB2b2lkIDAgPyAyMDAwIDogX2MsXG4gICAgICAgIF9kID0gX2IuZGlyZWN0aW9uLFxuICAgICAgICBkaXJlY3Rpb24gPSBfZCA9PT0gdm9pZCAwID8gRElSRUNUSU9OLk5FWFQgOiBfZCxcbiAgICAgICAgX2UgPSBfYi5zdG9wT25Ib3ZlcixcbiAgICAgICAgc3RvcE9uSG92ZXIgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZTtcbiAgICAvKiBJbnRlcm5hbCBWYWx1ZXMgKi9cblxuXG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVySWQgPSAwO1xuICAgIHRoaXMuX21vdXNlRW50ZXJlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gX3RoaXMuX2ZsaWNraW5nO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IF90aGlzLl9kaXJlY3Rpb247XG5cbiAgICAgIGlmICghZmxpY2tpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zdG9wKCk7XG5cbiAgICAgIGlmIChfdGhpcy5fbW91c2VFbnRlcmVkIHx8IGZsaWNraW5nLmFuaW1hdGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl90aW1lcklkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTkVYVCkge1xuICAgICAgICAgIGZsaWNraW5nLm5leHQoKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsaWNraW5nLnByZXYoKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMucGxheSgpO1xuICAgICAgfSwgX3RoaXMuX2R1cmF0aW9uKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl90aW1lcklkKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX21vdXNlRW50ZXJlZCA9IHRydWU7XG5cbiAgICAgIF90aGlzLnN0b3AoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX21vdXNlRW50ZXJlZCA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy5wbGF5KCk7XG4gICAgfTtcblxuICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHRoaXMuX3N0b3BPbkhvdmVyID0gc3RvcE9uSG92ZXI7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEF1dG9QbGF5LnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZHVyYXRpb25cIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZGlyZWN0aW9uXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb247XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic3RvcE9uSG92ZXJcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BPbkhvdmVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9zdG9wT25Ib3ZlciA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgX2E7XG5cbiAgICBpZiAodGhpcy5fZmxpY2tpbmcpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGZsaWNraW5nLm9uKChfYSA9IHt9LCBfYVtFVkVOVFMuTU9WRV9TVEFSVF0gPSB0aGlzLnN0b3AsIF9hW0VWRU5UUy5IT0xEX1NUQVJUXSA9IHRoaXMuc3RvcCwgX2FbRVZFTlRTLk1PVkVfRU5EXSA9IHRoaXMucGxheSwgX2FbRVZFTlRTLlNFTEVDVF0gPSB0aGlzLnBsYXksIF9hKSk7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcblxuICAgIGlmICh0aGlzLl9zdG9wT25Ib3Zlcikge1xuICAgICAgdmFyIHRhcmdldEVsID0gdGhpcy5fZmxpY2tpbmcuZWxlbWVudDtcbiAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuX29uTW91c2VFbnRlciwgZmFsc2UpO1xuICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5fb25Nb3VzZUxlYXZlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5KCk7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHRoaXMuX21vdXNlRW50ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgaWYgKCFmbGlja2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZsaWNraW5nLm9mZihFVkVOVFMuTU9WRV9TVEFSVCwgdGhpcy5zdG9wKTtcbiAgICBmbGlja2luZy5vZmYoRVZFTlRTLkhPTERfU1RBUlQsIHRoaXMuc3RvcCk7XG4gICAgZmxpY2tpbmcub2ZmKEVWRU5UUy5NT1ZFX0VORCwgdGhpcy5wbGF5KTtcbiAgICBmbGlja2luZy5vZmYoRVZFTlRTLlNFTEVDVCwgdGhpcy5wbGF5KTtcbiAgICB2YXIgdGFyZ2V0RWwgPSBmbGlja2luZy5lbGVtZW50O1xuICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuX29uTW91c2VFbnRlciwgZmFsc2UpO1xuICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuX29uTW91c2VMZWF2ZSwgZmFsc2UpO1xuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsvLyBETy1OT1RISU5HXG4gIH07XG5cbiAgcmV0dXJuIEF1dG9QbGF5O1xufSgpO1xuXG52YXIgQlJPV1NFUiA9IHtcbiAgQ0xJQ0s6IFwiY2xpY2tcIixcbiAgTU9VU0VfRE9XTjogXCJtb3VzZWRvd25cIixcbiAgVE9VQ0hfU1RBUlQ6IFwidG91Y2hzdGFydFwiXG59O1xuXG52YXIgQVJST1cgPSB7XG4gIFBSRVZfU0VMRUNUT1I6IFwiLmZsaWNraW5nLWFycm93LXByZXZcIixcbiAgTkVYVF9TRUxFQ1RPUjogXCIuZmxpY2tpbmctYXJyb3ctbmV4dFwiLFxuICBESVNBQkxFRF9DTEFTUzogXCJmbGlja2luZy1hcnJvdy1kaXNhYmxlZFwiXG59O1xudmFyIFBBR0lOQVRJT04gPSB7XG4gIFNFTEVDVE9SOiBcIi5mbGlja2luZy1wYWdpbmF0aW9uXCIsXG4gIFBSRUZJWDogXCJmbGlja2luZy1wYWdpbmF0aW9uXCIsXG4gIEJVTExFVF9XUkFQUEVSX1NVRkZJWDogXCJidWxsZXRzXCIsXG4gIEJVTExFVF9TVUZGSVg6IFwiYnVsbGV0XCIsXG4gIEJVTExFVF9BQ1RJVkVfU1VGRklYOiBcImJ1bGxldC1hY3RpdmVcIixcbiAgRlJBQ1RJT05fV1JBUFBFUl9TVUZGSVg6IFwiZnJhY3Rpb25cIixcbiAgRlJBQ1RJT05fQ1VSUkVOVF9TVUZGSVg6IFwiZnJhY3Rpb24tY3VycmVudFwiLFxuICBGUkFDVElPTl9UT1RBTF9TVUZGSVg6IFwiZnJhY3Rpb24tdG90YWxcIixcbiAgU0NST0xMX1VOSU5JVF9TVUZGSVg6IFwidW5pbml0aWFsaXplZFwiLFxuICBTQ1JPTExfV1JBUFBFUl9TVUZGSVg6IFwic2Nyb2xsXCIsXG4gIFNDUk9MTF9TTElERVJfU1VGRklYOiBcInNsaWRlclwiLFxuICBTQ1JPTExfUFJFVl9TVUZGSVg6IFwiYnVsbGV0LXByZXZcIixcbiAgU0NST0xMX05FWFRfU1VGRklYOiBcImJ1bGxldC1uZXh0XCIsXG4gIFRZUEU6IHtcbiAgICBCVUxMRVQ6IFwiYnVsbGV0XCIsXG4gICAgRlJBQ1RJT046IFwiZnJhY3Rpb25cIixcbiAgICBTQ1JPTEw6IFwic2Nyb2xsXCJcbiAgfVxufTtcbnZhciBTWU5DID0ge1xuICBUWVBFOiB7XG4gICAgQ0FNRVJBOiBcImNhbWVyYVwiLFxuICAgIElOREVYOiBcImluZGV4XCJcbiAgfVxufTtcblxudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcbiAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuXG4gICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgfVxuICB9XG59O1xudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcbiAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNsYXNzUmVnZXggPSBuZXcgUmVnRXhwKFwiKCB8XilcIiArIGNsYXNzTmFtZSArIFwiKCB8JClcIiwgXCJnXCIpO1xuICAgIGVsLmNsYXNzTmFtZS5yZXBsYWNlKGNsYXNzUmVnZXgsIFwiIFwiKTtcbiAgfVxufTtcbnZhciBnZXRFbGVtZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJlbnQsIHBsdWdpbk5hbWUpIHtcbiAgdmFyIGVsID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gIGlmICghZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbRmxpY2tpbmctXCIgKyBwbHVnaW5OYW1lICsgXCJdIENvdWxkbid0IGZpbmQgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvcjogXCIgKyBzZWxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gZWw7XG59O1xuXG4vKipcbiAqIEEgcGx1Z2luIHRvIGVhc2lseSBjcmVhdGUgcHJldi9yaWdodCBhcnJvdyBidXR0b24gb2YgRmxpY2tpbmdcbiAqIEBrbyDsnbTsoIQv64uk7J2MIOuyhO2KvOydhCDsib3qsowg66eM65OkIOyImCDsnojripQg7ZSM65+s6re47J24XG4gKiBAbWVtYmVyb2YgRmxpY2tpbmcuUGx1Z2luc1xuICovXG5cbnZhciBBcnJvdyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFycm93KF9hKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICBfYyA9IF9iLnBhcmVudEVsLFxuICAgICAgICBwYXJlbnRFbCA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2MsXG4gICAgICAgIF9kID0gX2IucHJldkVsU2VsZWN0b3IsXG4gICAgICAgIHByZXZFbFNlbGVjdG9yID0gX2QgPT09IHZvaWQgMCA/IEFSUk9XLlBSRVZfU0VMRUNUT1IgOiBfZCxcbiAgICAgICAgX2UgPSBfYi5uZXh0RWxTZWxlY3RvcixcbiAgICAgICAgbmV4dEVsU2VsZWN0b3IgPSBfZSA9PT0gdm9pZCAwID8gQVJST1cuTkVYVF9TRUxFQ1RPUiA6IF9lLFxuICAgICAgICBfZiA9IF9iLmRpc2FibGVkQ2xhc3MsXG4gICAgICAgIGRpc2FibGVkQ2xhc3MgPSBfZiA9PT0gdm9pZCAwID8gQVJST1cuRElTQUJMRURfQ0xBU1MgOiBfZixcbiAgICAgICAgX2cgPSBfYi5tb3ZlQ291bnQsXG4gICAgICAgIG1vdmVDb3VudCA9IF9nID09PSB2b2lkIDAgPyAxIDogX2csXG4gICAgICAgIF9oID0gX2IubW92ZUJ5Vmlld3BvcnRTaXplLFxuICAgICAgICBtb3ZlQnlWaWV3cG9ydFNpemUgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaDtcbiAgICAvKiBJbnRlcm5hbCBWYWx1ZXMgKi9cblxuXG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuXG4gICAgdGhpcy5fcHJldmVudElucHV0UHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25QcmV2Q2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSBfdGhpcy5fZmxpY2tpbmc7XG4gICAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgICAgdmFyIGFuY2hvclBvaW50cyA9IGNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgICBpZiAoZmxpY2tpbmcuYW5pbWF0aW5nIHx8IGFuY2hvclBvaW50cy5sZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgICAgdmFyIGZpcnN0QW5jaG9yID0gYW5jaG9yUG9pbnRzWzBdO1xuICAgICAgdmFyIG1vdmVDb3VudCA9IF90aGlzLl9tb3ZlQ291bnQ7XG5cbiAgICAgIGlmIChfdGhpcy5fbW92ZUJ5Vmlld3BvcnRTaXplKSB7XG4gICAgICAgIGZsaWNraW5nLmNvbnRyb2wubW92ZVRvUG9zaXRpb24oY2FtZXJhLnBvc2l0aW9uIC0gY2FtZXJhLnNpemUsIGZsaWNraW5nLmR1cmF0aW9uKS5jYXRjaChfdGhpcy5fb25DYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldFBhbmVsID0gZmxpY2tpbmcuY3VycmVudFBhbmVsO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3ZlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdGFyZ2V0UGFuZWwgPSB0YXJnZXRQYW5lbC5wcmV2KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0UGFuZWwuZm9jdXMoKS5jYXRjaChfdGhpcy5fb25DYXRjaCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmxpY2tpbmcuaW5kZXggPiBmaXJzdEFuY2hvci5wYW5lbC5pbmRleCkge1xuICAgICAgICAgIGZsaWNraW5nLm1vdmVUbyhNYXRoLm1heChmbGlja2luZy5pbmRleCAtIG1vdmVDb3VudCwgZmlyc3RBbmNob3IucGFuZWwuaW5kZXgpKS5jYXRjaChfdGhpcy5fb25DYXRjaCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FtZXJhLnBvc2l0aW9uID4gY2FtZXJhLnJhbmdlLm1pbikge1xuICAgICAgICAgIGZsaWNraW5nLm1vdmVUbyhmbGlja2luZy5pbmRleCkuY2F0Y2goX3RoaXMuX29uQ2F0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX29uTmV4dENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gX3RoaXMuX2ZsaWNraW5nO1xuICAgICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICAgIHZhciBhbmNob3JQb2ludHMgPSBjYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgICAgaWYgKGZsaWNraW5nLmFuaW1hdGluZyB8fCBhbmNob3JQb2ludHMubGVuZ3RoIDw9IDApIHJldHVybjtcbiAgICAgIHZhciBsYXN0QW5jaG9yID0gYW5jaG9yUG9pbnRzW2FuY2hvclBvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBtb3ZlQ291bnQgPSBfdGhpcy5fbW92ZUNvdW50O1xuXG4gICAgICBpZiAoX3RoaXMuX21vdmVCeVZpZXdwb3J0U2l6ZSkge1xuICAgICAgICBmbGlja2luZy5jb250cm9sLm1vdmVUb1Bvc2l0aW9uKGNhbWVyYS5wb3NpdGlvbiArIGNhbWVyYS5zaXplLCBmbGlja2luZy5kdXJhdGlvbikuY2F0Y2goX3RoaXMuX29uQ2F0Y2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCkge1xuICAgICAgICAgIHZhciB0YXJnZXRQYW5lbCA9IGZsaWNraW5nLmN1cnJlbnRQYW5lbDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW92ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRhcmdldFBhbmVsID0gdGFyZ2V0UGFuZWwubmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldFBhbmVsLmZvY3VzKCkuY2F0Y2goX3RoaXMuX29uQ2F0Y2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGZsaWNraW5nLmluZGV4IDwgbGFzdEFuY2hvci5wYW5lbC5pbmRleCkge1xuICAgICAgICAgIGZsaWNraW5nLm1vdmVUbyhNYXRoLm1pbihmbGlja2luZy5pbmRleCArIG1vdmVDb3VudCwgbGFzdEFuY2hvci5wYW5lbC5pbmRleCkpLmNhdGNoKF90aGlzLl9vbkNhdGNoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW1lcmEucG9zaXRpb24gPiBjYW1lcmEucmFuZ2UubWluKSB7XG4gICAgICAgICAgZmxpY2tpbmcubW92ZVRvKGZsaWNraW5nLmluZGV4KS5jYXRjaChfdGhpcy5fb25DYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fb25BbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSBfdGhpcy5fZmxpY2tpbmc7XG4gICAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBmbGlja2luZy5jb250cm9sLmNvbnRyb2xsZXI7XG5cbiAgICAgIGlmIChmbGlja2luZy5ob2xkaW5nKSB7XG4gICAgICAgIF90aGlzLl91cGRhdGVDbGFzcyhjYW1lcmEucG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZUNsYXNzKGNvbnRyb2xsZXIuYW5pbWF0aW5nQ29udGV4dC5lbmQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9vbkNhdGNoID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEZsaWNraW5nRXJyb3IpIHJldHVybjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9O1xuXG4gICAgdGhpcy5fcGFyZW50RWwgPSBwYXJlbnRFbDtcbiAgICB0aGlzLl9wcmV2RWxTZWxlY3RvciA9IHByZXZFbFNlbGVjdG9yO1xuICAgIHRoaXMuX25leHRFbFNlbGVjdG9yID0gbmV4dEVsU2VsZWN0b3I7XG4gICAgdGhpcy5fZGlzYWJsZWRDbGFzcyA9IGRpc2FibGVkQ2xhc3M7XG4gICAgdGhpcy5fbW92ZUNvdW50ID0gbW92ZUNvdW50O1xuICAgIHRoaXMuX21vdmVCeVZpZXdwb3J0U2l6ZSA9IG1vdmVCeVZpZXdwb3J0U2l6ZTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gQXJyb3cucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwcmV2RWxcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZFbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibmV4dEVsXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZXh0RWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhcmVudEVsXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRFbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcGFyZW50RWwgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInByZXZFbFNlbGVjdG9yXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2RWxTZWxlY3RvcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcHJldkVsU2VsZWN0b3IgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm5leHRFbFNlbGVjdG9yXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZXh0RWxTZWxlY3RvcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fbmV4dEVsU2VsZWN0b3IgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImRpc2FibGVkQ2xhc3NcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkQ2xhc3M7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVkQ2xhc3MgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm1vdmVDb3VudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUNvdW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9tb3ZlQ291bnQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm1vdmVCeVZpZXdwb3J0U2l6ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUJ5Vmlld3BvcnRTaXplO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9tb3ZlQnlWaWV3cG9ydFNpemUgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9mbGlja2luZykge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICBmbGlja2luZy5vbihFVkVOVFMuTU9WRSwgdGhpcy5fb25BbmltYXRpb24pO1xuICAgIHZhciBwYXJlbnRFbCA9IHRoaXMuX3BhcmVudEVsID8gdGhpcy5fcGFyZW50RWwgOiBmbGlja2luZy5lbGVtZW50O1xuICAgIHZhciBwcmV2RWwgPSBnZXRFbGVtZW50KHRoaXMuX3ByZXZFbFNlbGVjdG9yLCBwYXJlbnRFbCwgXCJBcnJvd1wiKTtcbiAgICB2YXIgbmV4dEVsID0gZ2V0RWxlbWVudCh0aGlzLl9uZXh0RWxTZWxlY3RvciwgcGFyZW50RWwsIFwiQXJyb3dcIik7XG4gICAgW0JST1dTRVIuTU9VU0VfRE9XTiwgQlJPV1NFUi5UT1VDSF9TVEFSVF0uZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBwcmV2RWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIF90aGlzLl9wcmV2ZW50SW5wdXRQcm9wYWdhdGlvbiwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG5leHRFbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgX3RoaXMuX3ByZXZlbnRJbnB1dFByb3BhZ2F0aW9uLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHByZXZFbC5hZGRFdmVudExpc3RlbmVyKEJST1dTRVIuQ0xJQ0ssIHRoaXMuX29uUHJldkNsaWNrKTtcbiAgICBuZXh0RWwuYWRkRXZlbnRMaXN0ZW5lcihCUk9XU0VSLkNMSUNLLCB0aGlzLl9vbk5leHRDbGljayk7XG4gICAgdGhpcy5fcHJldkVsID0gcHJldkVsO1xuICAgIHRoaXMuX25leHRFbCA9IG5leHRFbDtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG5cbiAgICBpZiAoIWZsaWNraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmxpY2tpbmcub2ZmKEVWRU5UUy5NT1ZFLCB0aGlzLl9vbkFuaW1hdGlvbik7XG4gICAgdmFyIHByZXZFbCA9IHRoaXMuX3ByZXZFbDtcbiAgICB2YXIgbmV4dEVsID0gdGhpcy5fbmV4dEVsO1xuICAgIFtCUk9XU0VSLk1PVVNFX0RPV04sIEJST1dTRVIuVE9VQ0hfU1RBUlRdLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xuICAgICAgcHJldkVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBfdGhpcy5fcHJldmVudElucHV0UHJvcGFnYXRpb24pO1xuICAgICAgbmV4dEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBfdGhpcy5fcHJldmVudElucHV0UHJvcGFnYXRpb24pO1xuICAgIH0pO1xuICAgIHByZXZFbC5yZW1vdmVFdmVudExpc3RlbmVyKEJST1dTRVIuQ0xJQ0ssIHRoaXMuX29uUHJldkNsaWNrKTtcbiAgICBuZXh0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihCUk9XU0VSLkNMSUNLLCB0aGlzLl9vbk5leHRDbGljayk7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZUNsYXNzKHRoaXMuX2ZsaWNraW5nLmNhbWVyYS5wb3NpdGlvbik7XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlQ2xhc3MgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIGRpc2FibGVkQ2xhc3MgPSB0aGlzLl9kaXNhYmxlZENsYXNzO1xuICAgIHZhciBwcmV2RWwgPSB0aGlzLl9wcmV2RWw7XG4gICAgdmFyIG5leHRFbCA9IHRoaXMuX25leHRFbDtcbiAgICB2YXIgY2FtZXJhUmFuZ2UgPSBmbGlja2luZy5jYW1lcmEucmFuZ2U7XG4gICAgdmFyIHN0b3BBdFByZXZFZGdlID0gZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkID8gZmFsc2UgOiBwb3MgPD0gY2FtZXJhUmFuZ2UubWluO1xuICAgIHZhciBzdG9wQXROZXh0RWRnZSA9IGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCA/IGZhbHNlIDogcG9zID49IGNhbWVyYVJhbmdlLm1heDtcblxuICAgIGlmIChzdG9wQXRQcmV2RWRnZSkge1xuICAgICAgYWRkQ2xhc3MocHJldkVsLCBkaXNhYmxlZENsYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQ2xhc3MocHJldkVsLCBkaXNhYmxlZENsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RvcEF0TmV4dEVkZ2UpIHtcbiAgICAgIGFkZENsYXNzKG5leHRFbCwgZGlzYWJsZWRDbGFzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUNsYXNzKG5leHRFbCwgZGlzYWJsZWRDbGFzcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBBcnJvdztcbn0oKTtcblxuLyoqXG4gKiBQbHVnaW4gZm9yIHN5bmNocm9uaXppbmcgbXVsdGlwbGUgZmxpY2tpbmdzXG4gKiBAa28g64uk7JaR7ZWcIO2Yle2DnOuhnCBGbGlja2luZ+uTpOydtCDqsJnsnbQg7JuA7KeB7J206rKMIO2VoCDsiJgg7J6I7Iq164uI64ukLlxuICogQG1lbWJlcm9mIEZsaWNraW5nLlBsdWdpbnNcbiAqL1xuXG52YXIgU3luYyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBTeW5jKF9hKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICBfYyA9IF9iLnR5cGUsXG4gICAgICAgIHR5cGUgPSBfYyA9PT0gdm9pZCAwID8gU1lOQy5UWVBFLkNBTUVSQSA6IF9jLFxuICAgICAgICBfZCA9IF9iLnN5bmNocm9uaXplZEZsaWNraW5nT3B0aW9ucyxcbiAgICAgICAgc3luY2hyb25pemVkRmxpY2tpbmdPcHRpb25zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2Q7XG4gICAgLyogSW50ZXJuYWwgVmFsdWVzICovXG5cblxuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcblxuICAgIHRoaXMuX2FkZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0eXBlID0gX3RoaXMuX3R5cGU7XG4gICAgICB2YXIgc3luY2VkID0gX3RoaXMuX3N5bmNocm9uaXplZEZsaWNraW5nT3B0aW9ucztcbiAgICAgIHN5bmNlZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZmxpY2tpbmcgPSBfYS5mbGlja2luZyxcbiAgICAgICAgICAgIGlzU2xpZGFibGUgPSBfYS5pc1NsaWRhYmxlLFxuICAgICAgICAgICAgaXNDbGlja2FibGUgPSBfYS5pc0NsaWNrYWJsZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gU1lOQy5UWVBFLkNBTUVSQSkge1xuICAgICAgICAgIGZsaWNraW5nLm9uKEVWRU5UUy5NT1ZFLCBfdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgICBmbGlja2luZy5vbihFVkVOVFMuTU9WRV9TVEFSVCwgX3RoaXMuX29uTW92ZVN0YXJ0KTtcbiAgICAgICAgICBmbGlja2luZy5vbihFVkVOVFMuTU9WRV9FTkQsIF90aGlzLl9vbk1vdmVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFNZTkMuVFlQRS5JTkRFWCAmJiBpc1NsaWRhYmxlKSB7XG4gICAgICAgICAgZmxpY2tpbmcub24oRVZFTlRTLldJTExfQ0hBTkdFLCBfdGhpcy5fb25JbmRleENoYW5nZSk7XG4gICAgICAgICAgZmxpY2tpbmcub24oRVZFTlRTLldJTExfUkVTVE9SRSwgX3RoaXMuX29uSW5kZXhDaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2xpY2thYmxlKSB7XG4gICAgICAgICAgZmxpY2tpbmcub24oRVZFTlRTLlNFTEVDVCwgX3RoaXMuX29uU2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuX3JlbW92ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0eXBlID0gX3RoaXMuX3R5cGU7XG4gICAgICB2YXIgc3luY2VkID0gX3RoaXMuX3N5bmNocm9uaXplZEZsaWNraW5nT3B0aW9ucztcbiAgICAgIHN5bmNlZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZmxpY2tpbmcgPSBfYS5mbGlja2luZyxcbiAgICAgICAgICAgIGlzU2xpZGFibGUgPSBfYS5pc1NsaWRhYmxlLFxuICAgICAgICAgICAgaXNDbGlja2FibGUgPSBfYS5pc0NsaWNrYWJsZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gU1lOQy5UWVBFLkNBTUVSQSkge1xuICAgICAgICAgIGZsaWNraW5nLm9mZihFVkVOVFMuTU9WRSwgX3RoaXMuX29uTW92ZSk7XG4gICAgICAgICAgZmxpY2tpbmcub2ZmKEVWRU5UUy5NT1ZFX1NUQVJULCBfdGhpcy5fb25Nb3ZlU3RhcnQpO1xuICAgICAgICAgIGZsaWNraW5nLm9mZihFVkVOVFMuTU9WRV9FTkQsIF90aGlzLl9vbk1vdmVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFNZTkMuVFlQRS5JTkRFWCAmJiBpc1NsaWRhYmxlKSB7XG4gICAgICAgICAgZmxpY2tpbmcub2ZmKEVWRU5UUy5XSUxMX0NIQU5HRSwgX3RoaXMuX29uSW5kZXhDaGFuZ2UpO1xuICAgICAgICAgIGZsaWNraW5nLm9mZihFVkVOVFMuV0lMTF9SRVNUT1JFLCBfdGhpcy5fb25JbmRleENoYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDbGlja2FibGUpIHtcbiAgICAgICAgICBmbGlja2luZy5vZmYoRVZFTlRTLlNFTEVDVCwgX3RoaXMuX29uU2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uSW5kZXhDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGZsaWNraW5nID0gZS5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICBpZiAoIWZsaWNraW5nLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX3N5bmNocm9uaXplQnlJbmRleChmbGlja2luZywgZS5pbmRleCk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY2FtZXJhID0gZS5jdXJyZW50VGFyZ2V0LmNhbWVyYTtcbiAgICAgIHZhciBwcm9ncmVzcyA9IChjYW1lcmEucG9zaXRpb24gLSBjYW1lcmEucmFuZ2UubWluKSAvIGNhbWVyYS5yYW5nZURpZmY7XG5cbiAgICAgIF90aGlzLl9zeW5jaHJvbml6ZWRGbGlja2luZ09wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGZsaWNraW5nID0gX2EuZmxpY2tpbmc7XG4gICAgICAgIGlmIChmbGlja2luZyA9PT0gZS5jdXJyZW50VGFyZ2V0KSByZXR1cm47XG4gICAgICAgIHZhciB0YXJnZXRQb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKGNhbWVyYS5wb3NpdGlvbiA8IGNhbWVyYS5yYW5nZS5taW4pIHtcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbiA9IGNhbWVyYS5wb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChjYW1lcmEucG9zaXRpb24gPiBjYW1lcmEucmFuZ2UubWF4KSB7XG4gICAgICAgICAgdGFyZ2V0UG9zaXRpb24gPSBmbGlja2luZy5jYW1lcmEucmFuZ2UubWF4ICsgY2FtZXJhLnBvc2l0aW9uIC0gY2FtZXJhLnJhbmdlLm1heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbiA9IGZsaWNraW5nLmNhbWVyYS5yYW5nZS5taW4gKyBmbGlja2luZy5jYW1lcmEucmFuZ2VEaWZmICogcHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2b2lkIGZsaWNraW5nLmNhbWVyYS5sb29rQXQodGFyZ2V0UG9zaXRpb24pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTW92ZVN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLl9zeW5jaHJvbml6ZWRGbGlja2luZ09wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGZsaWNraW5nID0gX2EuZmxpY2tpbmc7XG5cbiAgICAgICAgaWYgKGZsaWNraW5nICE9PSBlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBmbGlja2luZy5kaXNhYmxlSW5wdXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTW92ZUVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5fc3luY2hyb25pemVkRmxpY2tpbmdPcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBmbGlja2luZyA9IF9hLmZsaWNraW5nO1xuXG4gICAgICAgIGlmIChmbGlja2luZyAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgZmxpY2tpbmcuZW5hYmxlSW5wdXQoKTtcbiAgICAgICAgICBmbGlja2luZy5jb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLl9vblNlbGVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2b2lkIGUuY3VycmVudFRhcmdldC5tb3ZlVG8oZS5pbmRleCkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLl9zeW5jaHJvbml6ZUJ5SW5kZXgoZS5jdXJyZW50VGFyZ2V0LCBlLmluZGV4KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fc3luY2hyb25pemVCeUluZGV4ID0gZnVuY3Rpb24gKGFjdGl2ZUZsaWNraW5nLCBpbmRleCkge1xuICAgICAgdmFyIHN5bmNocm9uaXplZEZsaWNraW5nT3B0aW9ucyA9IF90aGlzLl9zeW5jaHJvbml6ZWRGbGlja2luZ09wdGlvbnM7XG5cbiAgICAgIF90aGlzLl9wcmV2ZW50RXZlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzeW5jaHJvbml6ZWRGbGlja2luZ09wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgIC8vIEFjdGl2ZSBjbGFzcyBzaG91bGQgYmUgYXBwbGllZCBzYW1lIHRvIHRoZSBGbGlja2luZyB3aGljaCB0cmlnZ2VyZWQgZXZlbnRcbiAgICAgICAgICBfdGhpcy5fdXBkYXRlQ2xhc3Mob3B0aW9ucywgaW5kZXgpO1xuXG4gICAgICAgICAgdmFyIGZsaWNraW5nID0gb3B0aW9ucy5mbGlja2luZztcbiAgICAgICAgICBpZiAoZmxpY2tpbmcgPT09IGFjdGl2ZUZsaWNraW5nKSByZXR1cm47XG4gICAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gY2xhbXAoaW5kZXgsIDAsIGZsaWNraW5nLnBhbmVscy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKGZsaWNraW5nLmFuaW1hdGluZykge1xuICAgICAgICAgICAgLy8gUmVzZXJ2ZSBtb3ZlVG8gb25jZSBwcmV2aW91cyBhbmltYXRpb24gaXMgZmluaXNoZWRcbiAgICAgICAgICAgIGZsaWNraW5nLm9uY2UoRVZFTlRTLk1PVkVfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZvaWQgZmxpY2tpbmcubW92ZVRvKHRhcmdldEluZGV4KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdm9pZCBmbGlja2luZy5tb3ZlVG8odGFyZ2V0SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3MgPSBmdW5jdGlvbiAoX2EsIGluZGV4KSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSBfYS5mbGlja2luZyxcbiAgICAgICAgICBhY3RpdmVDbGFzcyA9IF9hLmFjdGl2ZUNsYXNzO1xuICAgICAgaWYgKCFhY3RpdmVDbGFzcykgcmV0dXJuO1xuICAgICAgZmxpY2tpbmcucGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIGlmIChwYW5lbC5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBhZGRDbGFzcyhwYW5lbC5lbGVtZW50LCBhY3RpdmVDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MocGFuZWwuZWxlbWVudCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fc3luY2hyb25pemVkRmxpY2tpbmdPcHRpb25zID0gc3luY2hyb25pemVkRmxpY2tpbmdPcHRpb25zO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBTeW5jLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidHlwZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fdHlwZSA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic3luY2hyb25pemVkRmxpY2tpbmdPcHRpb25zXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zeW5jaHJvbml6ZWRGbGlja2luZ09wdGlvbnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3N5bmNocm9uaXplZEZsaWNraW5nT3B0aW9ucyA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHN5bmNlZCA9IHRoaXMuX3N5bmNocm9uaXplZEZsaWNraW5nT3B0aW9ucztcblxuICAgIGlmICh0aGlzLl9mbGlja2luZykge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcblxuICAgIHRoaXMuX2FkZEV2ZW50cygpO1xuXG4gICAgc3luY2VkLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzeW5jZWRGbGlja2luZyA9IG9wdGlvbnMuZmxpY2tpbmc7XG5cbiAgICAgIF90aGlzLl91cGRhdGVDbGFzcyhvcHRpb25zLCBzeW5jZWRGbGlja2luZy5kZWZhdWx0SW5kZXgpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcblxuICAgIGlmICghZmxpY2tpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudHMoKTtcblxuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fc3luY2hyb25pemVkRmxpY2tpbmdPcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIF90aGlzLl91cGRhdGVDbGFzcyhvcHRpb25zLCBvcHRpb25zLmZsaWNraW5nLmluZGV4KTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9wcmV2ZW50RXZlbnQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB0aGlzLl9yZW1vdmVFdmVudHMoKTtcblxuICAgIGZuKCk7XG5cbiAgICB0aGlzLl9hZGRFdmVudHMoKTtcbiAgfTtcblxuICByZXR1cm4gU3luYztcbn0oKTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbi8qKlxuICogWW91IGNhbiBhcHBseSBwZXJzcGVjdGl2ZSBlZmZlY3Qgd2hpbGUgcGFuZWwgaXMgbW92aW5nLlxuICogQGtvIO2MqOuEkOuTpOydhCDsm4Dsp4HsnbTrqbTshJwg7J6F7LK06rCQ7J2EIOu2gOyXrO2VoCDsiJgg7J6I7Iq164uI64ukLlxuICogQG1lbWJlcm9mIEZsaWNraW5nLlBsdWdpbnNcbiAqL1xuXG52YXIgUGVyc3BlY3RpdmUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIC0gVGhlIHNlbGVjdG9yIG9mIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBwZXJzcGVjdGl2ZSBlZmZlY3QgaXMgdG8gYmUgYXBwbGllZC4gSWYgdGhlIHNlbGVjdG9yIGlzIGJsYW5rLCBpdCBhcHBsaWVzIHRvIHBhbmVsIGVsZW1lbnQuIDxrbz7snoXssrQg7Zqo6rO866W8IOyggeyaqe2VoCDrjIDsg4HsnZgg7ISg7YOd7J6QLiDshKDtg53snpDqsIAg6rO167Cx7J2066m0IO2MqOuEkCDsl5jrpqzrqLztirjsl5Ag7KCB7Jqp65Cc64ukLjwva28+XG4gICAqIEBwYXJhbSAtIEVmZmVjdCBhbXBsaWNhdGlvbiBzY2FsZS48a28+7Zqo6rO8IOymne2PreuPhDwva28+XG4gICAqIEBwYXJhbSAtIEVmZmVjdCBhbXBsaWNhdGlvbiByb3RhdGUuPGtvPu2ajOyghCDspp3tj63rj4Q8L2tvPlxuICAgKiBAcGFyYW0gLSBUaGUgdmFsdWUgb2YgcGVyc3BlY3RpdmUgQ1NTIHByb3BlcnR5LiA8a28+Y3NzIHBlcnNwZWN0aXZlIOyGjeyEsSDqsJI8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBmbGlja2luZy5hZGRQbHVnaW5zKG5ldyBQZXJzcGVjdGl2ZSh7IHNlbGVjdG9yOiBcInBcIiwgc2NhbGU6IDEsIHJvdGF0ZTogMSwgcGVyc3BlY3RpdmUgPSAxMDAwIH0pKTtcbiAgICogYGBgXG4gICAqL1xuICBmdW5jdGlvbiBQZXJzcGVjdGl2ZShfYSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSxcbiAgICAgICAgX2MgPSBfYi5zZWxlY3RvcixcbiAgICAgICAgc2VsZWN0b3IgPSBfYyA9PT0gdm9pZCAwID8gXCJcIiA6IF9jLFxuICAgICAgICBfZCA9IF9iLnNjYWxlLFxuICAgICAgICBzY2FsZSA9IF9kID09PSB2b2lkIDAgPyAxIDogX2QsXG4gICAgICAgIF9lID0gX2Iucm90YXRlLFxuICAgICAgICByb3RhdGUgPSBfZSA9PT0gdm9pZCAwID8gMSA6IF9lLFxuICAgICAgICBfZiA9IF9iLnBlcnNwZWN0aXZlLFxuICAgICAgICBwZXJzcGVjdGl2ZSA9IF9mID09PSB2b2lkIDAgPyAxMDAwIDogX2Y7XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9vbk1vdmUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25Nb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gX3RoaXMuX2ZsaWNraW5nO1xuICAgICAgdmFyIHNlbGVjdG9yID0gX3RoaXMuX3NlbGVjdG9yO1xuICAgICAgdmFyIHNjYWxlID0gX3RoaXMuX3NjYWxlO1xuICAgICAgdmFyIHJvdGF0ZSA9IF90aGlzLl9yb3RhdGU7XG4gICAgICB2YXIgcGVyc3BlY3RpdmUgPSBfdGhpcy5fcGVyc3BlY3RpdmU7XG4gICAgICBpZiAoIWZsaWNraW5nKSByZXR1cm47XG4gICAgICB2YXIgaG9yaXpvbnRhbCA9IGZsaWNraW5nLmhvcml6b250YWw7XG4gICAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcudmlzaWJsZVBhbmVscztcbiAgICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBwYW5lbC5vdXRzZXRQcm9ncmVzcztcbiAgICAgICAgdmFyIGVsID0gcGFuZWwuZWxlbWVudDtcbiAgICAgICAgdmFyIHRhcmdldCA9IHNlbGVjdG9yID8gZWwucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBlbDtcbiAgICAgICAgdmFyIHBhbmVsU2NhbGUgPSAxIC8gKE1hdGguYWJzKHByb2dyZXNzICogc2NhbGUpICsgMSk7XG4gICAgICAgIHZhciByb3RhdGVEZWdyZWUgPSBwcm9ncmVzcyA+IDAgPyBNYXRoLm1pbig5MCwgcHJvZ3Jlc3MgKiAxMDAgKiByb3RhdGUpIDogTWF0aC5tYXgoLTkwLCBwcm9ncmVzcyAqIDEwMCAqIHJvdGF0ZSk7XG5cbiAgICAgICAgdmFyIF9hID0gaG9yaXpvbnRhbCA/IFswLCByb3RhdGVEZWdyZWVdIDogW3JvdGF0ZURlZ3JlZSwgMF0sXG4gICAgICAgICAgICByb3RhdGVYID0gX2FbMF0sXG4gICAgICAgICAgICByb3RhdGVZID0gX2FbMV07XG5cbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwicGVyc3BlY3RpdmUoXCIgKyBwZXJzcGVjdGl2ZSArIFwicHgpIHJvdGF0ZVgoXCIgKyByb3RhdGVYICsgXCJkZWcpIHJvdGF0ZVkoXCIgKyByb3RhdGVZICsgXCJkZWcpIHNjYWxlKFwiICsgcGFuZWxTY2FsZSArIFwiKVwiO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5fcm90YXRlID0gcm90YXRlO1xuICAgIHRoaXMuX3BlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFBlcnNwZWN0aXZlLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic2VsZWN0b3JcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9zZWxlY3RvciA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic2NhbGVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9zY2FsZSA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicm90YXRlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb3RhdGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3JvdGF0ZSA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGVyc3BlY3RpdmVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BlcnNwZWN0aXZlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9wZXJzcGVjdGl2ZSA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICBpZiAodGhpcy5fZmxpY2tpbmcpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgZmxpY2tpbmcub24oRVZFTlRTLk1PVkUsIHRoaXMuX29uTW92ZSk7XG4gICAgZmxpY2tpbmcub24oRVZFTlRTLkFGVEVSX1JFU0laRSwgdGhpcy51cGRhdGUpO1xuXG4gICAgdGhpcy5fb25Nb3ZlKCk7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fZmxpY2tpbmcpIHJldHVybjtcblxuICAgIHRoaXMuX2ZsaWNraW5nLm9mZihFVkVOVFMuTU9WRSwgdGhpcy5fb25Nb3ZlKTtcblxuICAgIHRoaXMuX2ZsaWNraW5nLm9mZihFVkVOVFMuQUZURVJfUkVTSVpFLCB0aGlzLnVwZGF0ZSk7XG5cbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFBlcnNwZWN0aXZlO1xufSgpO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBmcm9tKTtcbn1cblxudmFyIFJlbmRlcmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVuZGVyZXIoX2EpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBfYS5mbGlja2luZyxcbiAgICAgICAgcGFnaW5hdGlvbiA9IF9hLnBhZ2luYXRpb24sXG4gICAgICAgIHdyYXBwZXIgPSBfYS53cmFwcGVyO1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fcGFnaW5hdGlvbiA9IHBhZ2luYXRpb247XG4gICAgdGhpcy5fd3JhcHBlciA9IHdyYXBwZXI7XG4gIH1cblxuICByZXR1cm4gUmVuZGVyZXI7XG59KCk7XG5cbnZhciBCdWxsZXRSZW5kZXJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCdWxsZXRSZW5kZXJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBCdWxsZXRSZW5kZXJlcigpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLl9jaGlsZHMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEJ1bGxldFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcGFnaW5hdGlvbiA9IHRoaXMuX3BhZ2luYXRpb247XG4gICAgdmFyIHJlbmRlckJ1bGxldCA9IHBhZ2luYXRpb24ucmVuZGVyQnVsbGV0O1xuICAgIHZhciBidWxsZXRXcmFwcGVyQ2xhc3MgPSBwYWdpbmF0aW9uLmNsYXNzUHJlZml4ICsgXCItXCIgKyBQQUdJTkFUSU9OLkJVTExFVF9XUkFQUEVSX1NVRkZJWDtcbiAgICB2YXIgYnVsbGV0Q2xhc3MgPSBwYWdpbmF0aW9uLmNsYXNzUHJlZml4ICsgXCItXCIgKyBQQUdJTkFUSU9OLkJVTExFVF9TVUZGSVg7XG4gICAgdmFyIGJ1bGxldEFjdGl2ZUNsYXNzID0gcGFnaW5hdGlvbi5jbGFzc1ByZWZpeCArIFwiLVwiICsgUEFHSU5BVElPTi5CVUxMRVRfQUNUSVZFX1NVRkZJWDtcbiAgICB2YXIgYW5jaG9yUG9pbnRzID0gZmxpY2tpbmcuY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICB2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXI7XG4gICAgYWRkQ2xhc3Mod3JhcHBlciwgYnVsbGV0V3JhcHBlckNsYXNzKTtcbiAgICB3cmFwcGVyLmlubmVySFRNTCA9IGFuY2hvclBvaW50cy5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVuZGVyQnVsbGV0KGJ1bGxldENsYXNzLCBpbmRleCk7XG4gICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB2YXIgYnVsbGV0cyA9IFtdLnNsaWNlLmNhbGwod3JhcHBlci5jaGlsZHJlbik7XG4gICAgYnVsbGV0cy5mb3JFYWNoKGZ1bmN0aW9uIChidWxsZXQsIGluZGV4KSB7XG4gICAgICB2YXIgYW5jaG9yUG9pbnQgPSBhbmNob3JQb2ludHNbaW5kZXhdO1xuXG4gICAgICBpZiAoYW5jaG9yUG9pbnQucGFuZWwuaW5kZXggPT09IGZsaWNraW5nLmluZGV4KSB7XG4gICAgICAgIGFkZENsYXNzKGJ1bGxldCwgYnVsbGV0QWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBidWxsZXQuYWRkRXZlbnRMaXN0ZW5lcihCUk9XU0VSLk1PVVNFX0RPV04sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGJ1bGxldC5hZGRFdmVudExpc3RlbmVyKEJST1dTRVIuVE9VQ0hfU1RBUlQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnVsbGV0LmFkZEV2ZW50TGlzdGVuZXIoQlJPV1NFUi5DTElDSywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmbGlja2luZy5tb3ZlVG8oYW5jaG9yUG9pbnQucGFuZWwuaW5kZXgpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRmxpY2tpbmdFcnJvcikgcmV0dXJuO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9jaGlsZHMgPSBidWxsZXRzO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHBhZ2luYXRpb24gPSB0aGlzLl9wYWdpbmF0aW9uO1xuICAgIHZhciBidWxsZXRzID0gdGhpcy5fY2hpbGRzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uQlVMTEVUX0FDVElWRV9TVUZGSVg7XG4gICAgdmFyIGFuY2hvclBvaW50cyA9IGZsaWNraW5nLmNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgaWYgKGFuY2hvclBvaW50cy5sZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgIGJ1bGxldHMuZm9yRWFjaChmdW5jdGlvbiAoYnVsbGV0KSB7XG4gICAgICByZW1vdmVDbGFzcyhidWxsZXQsIGFjdGl2ZUNsYXNzKTtcbiAgICB9KTtcbiAgICB2YXIgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yUG9pbnRzWzBdLnBhbmVsLmluZGV4O1xuICAgIHZhciBhY3RpdmVCdWxsZXQgPSBidWxsZXRzW2luZGV4IC0gYW5jaG9yT2Zmc2V0XTtcbiAgICBhZGRDbGFzcyhhY3RpdmVCdWxsZXQsIGFjdGl2ZUNsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gQnVsbGV0UmVuZGVyZXI7XG59KFJlbmRlcmVyKTtcblxudmFyIEZyYWN0aW9uUmVuZGVyZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRnJhY3Rpb25SZW5kZXJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGcmFjdGlvblJlbmRlcmVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gRnJhY3Rpb25SZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyO1xuICAgIHZhciBwYWdpbmF0aW9uID0gdGhpcy5fcGFnaW5hdGlvbjtcbiAgICB2YXIgZnJhY3Rpb25XcmFwcGVyQ2xhc3MgPSBwYWdpbmF0aW9uLmNsYXNzUHJlZml4ICsgXCItXCIgKyBQQUdJTkFUSU9OLkZSQUNUSU9OX1dSQVBQRVJfU1VGRklYO1xuICAgIHZhciBmcmFjdGlvbkN1cnJlbnRDbGFzcyA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uRlJBQ1RJT05fQ1VSUkVOVF9TVUZGSVg7XG4gICAgdmFyIGZyYWN0aW9uVG90YWxDbGFzcyA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uRlJBQ1RJT05fVE9UQUxfU1VGRklYO1xuICAgIGFkZENsYXNzKHdyYXBwZXIsIGZyYWN0aW9uV3JhcHBlckNsYXNzKTtcbiAgICB3cmFwcGVyLmlubmVySFRNTCA9IHBhZ2luYXRpb24ucmVuZGVyRnJhY3Rpb24oZnJhY3Rpb25DdXJyZW50Q2xhc3MsIGZyYWN0aW9uVG90YWxDbGFzcyk7XG4gICAgdGhpcy51cGRhdGUoZmxpY2tpbmcuaW5kZXgpO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyO1xuICAgIHZhciBwYWdpbmF0aW9uID0gdGhpcy5fcGFnaW5hdGlvbjtcbiAgICB2YXIgZnJhY3Rpb25DdXJyZW50Q2xhc3MgPSBwYWdpbmF0aW9uLmNsYXNzUHJlZml4ICsgXCItXCIgKyBQQUdJTkFUSU9OLkZSQUNUSU9OX0NVUlJFTlRfU1VGRklYO1xuICAgIHZhciBmcmFjdGlvblRvdGFsQ2xhc3MgPSBwYWdpbmF0aW9uLmNsYXNzUHJlZml4ICsgXCItXCIgKyBQQUdJTkFUSU9OLkZSQUNUSU9OX1RPVEFMX1NVRkZJWDtcbiAgICB2YXIgY3VycmVudFdyYXBwZXIgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBmcmFjdGlvbkN1cnJlbnRDbGFzcyk7XG4gICAgdmFyIHRvdGFsV3JhcHBlciA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcihcIi5cIiArIGZyYWN0aW9uVG90YWxDbGFzcyk7XG4gICAgdmFyIGFuY2hvclBvaW50cyA9IGZsaWNraW5nLmNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IGFuY2hvclBvaW50cy5sZW5ndGggPiAwID8gaW5kZXggLSBhbmNob3JQb2ludHNbMF0ucGFuZWwuaW5kZXggKyAxIDogMDtcbiAgICBjdXJyZW50V3JhcHBlci5pbm5lckhUTUwgPSBwYWdpbmF0aW9uLmZyYWN0aW9uQ3VycmVudEZvcm1hdChjdXJyZW50SW5kZXgpO1xuICAgIHRvdGFsV3JhcHBlci5pbm5lckhUTUwgPSBwYWdpbmF0aW9uLmZyYWN0aW9uVG90YWxGb3JtYXQoYW5jaG9yUG9pbnRzLmxlbmd0aCk7XG4gIH07XG5cbiAgcmV0dXJuIEZyYWN0aW9uUmVuZGVyZXI7XG59KFJlbmRlcmVyKTtcblxudmFyIFNjcm9sbEJ1bGxldFJlbmRlcmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNjcm9sbEJ1bGxldFJlbmRlcmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNjcm9sbEJ1bGxldFJlbmRlcmVyKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuX2J1bGxldHMgPSBbXTtcbiAgICBfdGhpcy5fYnVsbGV0U2l6ZSA9IDA7XG4gICAgX3RoaXMuX3ByZXZpb3VzSW5kZXggPSAtMTtcbiAgICBfdGhpcy5fc2xpZGVySW5kZXggPSAtMTtcblxuICAgIF90aGlzLm1vdmVUbyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIHBhZ2luYXRpb24gPSBfdGhpcy5fcGFnaW5hdGlvbjtcbiAgICAgIHZhciBzbGlkZXJFbCA9IF90aGlzLl93cmFwcGVyLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgdmFyIGJ1bGxldFNpemUgPSBfdGhpcy5fYnVsbGV0U2l6ZTtcbiAgICAgIHZhciB3cmFwcGVyU2l6ZSA9IGJ1bGxldFNpemUgKiBwYWdpbmF0aW9uLmJ1bGxldENvdW50O1xuICAgICAgc2xpZGVyRWwuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyAod3JhcHBlclNpemUgLyAyIC0gKGluZGV4ICsgMC41KSAqIGJ1bGxldFNpemUpICsgXCJweClcIjtcbiAgICAgIF90aGlzLl9zbGlkZXJJbmRleCA9IGluZGV4O1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFNjcm9sbEJ1bGxldFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXI7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHBhZ2luYXRpb24gPSB0aGlzLl9wYWdpbmF0aW9uO1xuICAgIHZhciByZW5kZXJCdWxsZXQgPSBwYWdpbmF0aW9uLnJlbmRlckJ1bGxldDtcbiAgICB2YXIgYW5jaG9yUG9pbnRzID0gZmxpY2tpbmcuY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICB2YXIgZHluYW1pY1dyYXBwZXJDbGFzcyA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uU0NST0xMX1dSQVBQRVJfU1VGRklYO1xuICAgIHZhciBidWxsZXRDbGFzcyA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uQlVMTEVUX1NVRkZJWDtcbiAgICB2YXIgc2xpZGVyQ2xhc3MgPSBwYWdpbmF0aW9uLmNsYXNzUHJlZml4ICsgXCItXCIgKyBQQUdJTkFUSU9OLlNDUk9MTF9TTElERVJfU1VGRklYO1xuICAgIHZhciB1bmluaXRDbGFzcyA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uU0NST0xMX1VOSU5JVF9TVUZGSVg7XG4gICAgdmFyIHNsaWRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBhZGRDbGFzcyhzbGlkZXJFbCwgc2xpZGVyQ2xhc3MpO1xuICAgIGFkZENsYXNzKHdyYXBwZXIsIHVuaW5pdENsYXNzKTtcbiAgICBhZGRDbGFzcyh3cmFwcGVyLCBkeW5hbWljV3JhcHBlckNsYXNzKTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNsaWRlckVsKTtcbiAgICBzbGlkZXJFbC5pbm5lckhUTUwgPSBhbmNob3JQb2ludHMubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlbmRlckJ1bGxldChidWxsZXRDbGFzcywgaW5kZXgpO1xuICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgdmFyIGJ1bGxldHMgPSBbXS5zbGljZS5jYWxsKHNsaWRlckVsLmNoaWxkcmVuKTtcbiAgICBidWxsZXRzLmZvckVhY2goZnVuY3Rpb24gKGJ1bGxldCwgaW5kZXgpIHtcbiAgICAgIHZhciBhbmNob3JQb2ludCA9IGFuY2hvclBvaW50c1tpbmRleF07XG4gICAgICBidWxsZXQuYWRkRXZlbnRMaXN0ZW5lcihCUk9XU0VSLk1PVVNFX0RPV04sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGJ1bGxldC5hZGRFdmVudExpc3RlbmVyKEJST1dTRVIuVE9VQ0hfU1RBUlQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnVsbGV0LmFkZEV2ZW50TGlzdGVuZXIoQlJPV1NFUi5DTElDSywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmbGlja2luZy5tb3ZlVG8oYW5jaG9yUG9pbnQucGFuZWwuaW5kZXgpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRmxpY2tpbmdFcnJvcikgcmV0dXJuO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoYnVsbGV0cy5sZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgIHZhciBidWxsZXRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoYnVsbGV0c1swXSk7XG4gICAgdmFyIGJ1bGxldFNpemUgPSBidWxsZXRzWzBdLmNsaWVudFdpZHRoICsgcGFyc2VGbG9hdChidWxsZXRTdHlsZS5tYXJnaW5MZWZ0KSArIHBhcnNlRmxvYXQoYnVsbGV0U3R5bGUubWFyZ2luUmlnaHQpO1xuICAgIHdyYXBwZXIuc3R5bGUud2lkdGggPSBidWxsZXRTaXplICogcGFnaW5hdGlvbi5idWxsZXRDb3VudCArIFwicHhcIjtcbiAgICB0aGlzLl9idWxsZXRzID0gYnVsbGV0cztcbiAgICB0aGlzLl9idWxsZXRTaXplID0gYnVsbGV0U2l6ZTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLl9mbGlja2luZy5pbmRleCk7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVDbGFzcyh3cmFwcGVyLCB1bmluaXRDbGFzcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by51cGRhdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcGFnaW5hdGlvbiA9IHRoaXMuX3BhZ2luYXRpb247XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIGJ1bGxldHMgPSB0aGlzLl9idWxsZXRzO1xuICAgIHZhciBwcmV2SW5kZXggPSB0aGlzLl9wcmV2aW91c0luZGV4O1xuICAgIHZhciBhbmNob3JQb2ludHMgPSBmbGlja2luZy5jYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIHZhciBhbmNob3JPZmZzZXQgPSBhbmNob3JQb2ludHNbMF0ucGFuZWwuaW5kZXg7XG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gaW5kZXggLSBhbmNob3JPZmZzZXQ7XG4gICAgaWYgKGFuY2hvclBvaW50cy5sZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgIHZhciBidWxsZXRBY3RpdmVDbGFzcyA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uQlVMTEVUX0FDVElWRV9TVUZGSVg7XG4gICAgdmFyIHByZXZDbGFzc1ByZWZpeCA9IHBhZ2luYXRpb24uY2xhc3NQcmVmaXggKyBcIi1cIiArIFBBR0lOQVRJT04uU0NST0xMX1BSRVZfU1VGRklYO1xuICAgIHZhciBuZXh0Q2xhc3NQcmVmaXggPSBwYWdpbmF0aW9uLmNsYXNzUHJlZml4ICsgXCItXCIgKyBQQUdJTkFUSU9OLlNDUk9MTF9ORVhUX1NVRkZJWDtcblxuICAgIHZhciBidWxsZXRQcmV2Q2xhc3MgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZXZDbGFzc1ByZWZpeCArIChvZmZzZXQgPiAxID8gb2Zmc2V0IDogXCJcIik7XG4gICAgfTtcblxuICAgIHZhciBidWxsZXROZXh0Q2xhc3MgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICByZXR1cm4gXCJcIiArIG5leHRDbGFzc1ByZWZpeCArIChvZmZzZXQgPiAxID8gb2Zmc2V0IDogXCJcIik7XG4gICAgfTtcblxuICAgIHZhciBwcmV2Q2xhc3NSZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwcmV2Q2xhc3NQcmVmaXgpO1xuICAgIHZhciBuZXh0Q2xhc3NSZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuZXh0Q2xhc3NQcmVmaXgpO1xuICAgIGJ1bGxldHMuZm9yRWFjaChmdW5jdGlvbiAoYnVsbGV0LCBpZHgpIHtcbiAgICAgIHZhciBpbmRleE9mZnNldCA9IGlkeCAtIGFjdGl2ZUluZGV4O1xuICAgICAgdmFyIGNsYXNzTGlzdCA9IGJ1bGxldC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIGNsYXNzTGlzdF8xID0gY2xhc3NMaXN0OyBfaSA8IGNsYXNzTGlzdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NMaXN0XzFbX2ldO1xuXG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IGJ1bGxldEFjdGl2ZUNsYXNzIHx8IHByZXZDbGFzc1JlZ2V4LnRlc3QoY2xhc3NOYW1lKSB8fCBuZXh0Q2xhc3NSZWdleC50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhidWxsZXQsIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGFkZENsYXNzKGJ1bGxldCwgYnVsbGV0QWN0aXZlQ2xhc3MpO1xuICAgICAgfSBlbHNlIGlmIChpbmRleE9mZnNldCA+IDApIHtcbiAgICAgICAgYWRkQ2xhc3MoYnVsbGV0LCBidWxsZXROZXh0Q2xhc3MoTWF0aC5hYnMoaW5kZXhPZmZzZXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDbGFzcyhidWxsZXQsIGJ1bGxldFByZXZDbGFzcyhNYXRoLmFicyhpbmRleE9mZnNldCkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwYWdpbmF0aW9uLnNjcm9sbE9uQ2hhbmdlKGFjdGl2ZUluZGV4LCB7XG4gICAgICB0b3RhbDogYnVsbGV0cy5sZW5ndGgsXG4gICAgICBwcmV2SW5kZXg6IHByZXZJbmRleCxcbiAgICAgIHNsaWRlckluZGV4OiB0aGlzLl9zbGlkZXJJbmRleCxcbiAgICAgIGRpcmVjdGlvbjogYWN0aXZlSW5kZXggPiBwcmV2SW5kZXggPyBESVJFQ1RJT04uTkVYVCA6IERJUkVDVElPTi5QUkVWLFxuICAgICAgYnVsbGV0czogX19zcHJlYWRBcnJheShbXSwgYnVsbGV0cyksXG4gICAgICBtb3ZlVG86IHRoaXMubW92ZVRvXG4gICAgfSk7XG4gICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IGFjdGl2ZUluZGV4O1xuICB9O1xuXG4gIHJldHVybiBTY3JvbGxCdWxsZXRSZW5kZXJlcjtcbn0oUmVuZGVyZXIpO1xuXG4vKipcbiAqIEBtZW1iZXJvZiBGbGlja2luZy5QbHVnaW5zXG4gKi9cblxudmFyIFBhZ2luYXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYWdpbmF0aW9uKF9hKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICBfYyA9IF9iLnBhcmVudEVsLFxuICAgICAgICBwYXJlbnRFbCA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2MsXG4gICAgICAgIF9kID0gX2Iuc2VsZWN0b3IsXG4gICAgICAgIHNlbGVjdG9yID0gX2QgPT09IHZvaWQgMCA/IFBBR0lOQVRJT04uU0VMRUNUT1IgOiBfZCxcbiAgICAgICAgX2UgPSBfYi50eXBlLFxuICAgICAgICB0eXBlID0gX2UgPT09IHZvaWQgMCA/IFBBR0lOQVRJT04uVFlQRS5CVUxMRVQgOiBfZSxcbiAgICAgICAgX2YgPSBfYi5jbGFzc1ByZWZpeCxcbiAgICAgICAgY2xhc3NQcmVmaXggPSBfZiA9PT0gdm9pZCAwID8gUEFHSU5BVElPTi5QUkVGSVggOiBfZixcbiAgICAgICAgX2cgPSBfYi5idWxsZXRDb3VudCxcbiAgICAgICAgYnVsbGV0Q291bnQgPSBfZyA9PT0gdm9pZCAwID8gNSA6IF9nLFxuICAgICAgICBfaCA9IF9iLnJlbmRlckJ1bGxldCxcbiAgICAgICAgcmVuZGVyQnVsbGV0ID0gX2ggPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBcIjxzcGFuIGNsYXNzPVxcXCJcIiArIGNsYXNzTmFtZSArIFwiXFxcIj48L3NwYW4+XCI7XG4gICAgfSA6IF9oLFxuICAgICAgICBfaiA9IF9iLnJlbmRlckZyYWN0aW9uLFxuICAgICAgICByZW5kZXJGcmFjdGlvbiA9IF9qID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoY3VycmVudENsYXNzLCB0b3RhbENsYXNzKSB7XG4gICAgICByZXR1cm4gXCI8c3BhbiBjbGFzcz1cXFwiXCIgKyBjdXJyZW50Q2xhc3MgKyBcIlxcXCI+PC9zcGFuPi88c3BhbiBjbGFzcz1cXFwiXCIgKyB0b3RhbENsYXNzICsgXCJcXFwiPjwvc3Bhbj5cIjtcbiAgICB9IDogX2osXG4gICAgICAgIF9rID0gX2IuZnJhY3Rpb25DdXJyZW50Rm9ybWF0LFxuICAgICAgICBmcmFjdGlvbkN1cnJlbnRGb3JtYXQgPSBfayA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXgudG9TdHJpbmcoKTtcbiAgICB9IDogX2ssXG4gICAgICAgIF9sID0gX2IuZnJhY3Rpb25Ub3RhbEZvcm1hdCxcbiAgICAgICAgZnJhY3Rpb25Ub3RhbEZvcm1hdCA9IF9sID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleC50b1N0cmluZygpO1xuICAgIH0gOiBfbCxcbiAgICAgICAgX20gPSBfYi5zY3JvbGxPbkNoYW5nZSxcbiAgICAgICAgc2Nyb2xsT25DaGFuZ2UgPSBfbSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGluZGV4LCBjdHgpIHtcbiAgICAgIHJldHVybiBjdHgubW92ZVRvKGluZGV4KTtcbiAgICB9IDogX207XG4gICAgLyogSW50ZXJuYWwgVmFsdWVzICovXG5cblxuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX3JlbW92ZUFsbENoaWxkcygpO1xuXG4gICAgICBfdGhpcy5fcmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uSW5kZXhDaGFuZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBfdGhpcy5fcmVuZGVyZXIudXBkYXRlKGV2dC5pbmRleCk7XG4gICAgfTtcblxuICAgIHRoaXMuX3BhcmVudEVsID0gcGFyZW50RWw7XG4gICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICB0aGlzLl9jbGFzc1ByZWZpeCA9IGNsYXNzUHJlZml4O1xuICAgIHRoaXMuX2J1bGxldENvdW50ID0gYnVsbGV0Q291bnQ7XG4gICAgdGhpcy5fcmVuZGVyQnVsbGV0ID0gcmVuZGVyQnVsbGV0O1xuICAgIHRoaXMuX3JlbmRlckZyYWN0aW9uID0gcmVuZGVyRnJhY3Rpb247XG4gICAgdGhpcy5fZnJhY3Rpb25DdXJyZW50Rm9ybWF0ID0gZnJhY3Rpb25DdXJyZW50Rm9ybWF0O1xuICAgIHRoaXMuX2ZyYWN0aW9uVG90YWxGb3JtYXQgPSBmcmFjdGlvblRvdGFsRm9ybWF0O1xuICAgIHRoaXMuX3Njcm9sbE9uQ2hhbmdlID0gc2Nyb2xsT25DaGFuZ2U7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFBhZ2luYXRpb24ucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYXJlbnRFbFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50RWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3BhcmVudEVsID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzZWxlY3RvclwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0b3I7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3NlbGVjdG9yID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ0eXBlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl90eXBlID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjbGFzc1ByZWZpeFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xhc3NQcmVmaXg7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImJ1bGxldENvdW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9idWxsZXRDb3VudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYnVsbGV0Q291bnQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlckJ1bGxldFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQnVsbGV0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9yZW5kZXJCdWxsZXQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlckZyYWN0aW9uXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJGcmFjdGlvbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcmVuZGVyRnJhY3Rpb24gPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImZyYWN0aW9uQ3VycmVudEZvcm1hdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZnJhY3Rpb25DdXJyZW50Rm9ybWF0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9mcmFjdGlvbkN1cnJlbnRGb3JtYXQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImZyYWN0aW9uVG90YWxGb3JtYXRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZyYWN0aW9uVG90YWxGb3JtYXQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2ZyYWN0aW9uVG90YWxGb3JtYXQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInNjcm9sbE9uQ2hhbmdlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxPbkNoYW5nZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fc2Nyb2xsT25DaGFuZ2UgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImJ1bGxldFdyYXBwZXJjbGFzc1ByZWZpeENsYXNzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2NsYXNzUHJlZml4ID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIGlmICh0aGlzLl9mbGlja2luZykge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy5fc2VsZWN0b3I7XG4gICAgdmFyIHBhcmVudEVsID0gdGhpcy5fcGFyZW50RWwgPyB0aGlzLl9wYXJlbnRFbCA6IGZsaWNraW5nLmVsZW1lbnQ7XG4gICAgdmFyIHdyYXBwZXIgPSBwYXJlbnRFbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGlmICghd3JhcHBlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0ZsaWNraW5nLVBhZ2luYXRpb25dIENvdWxkbid0IGZpbmQgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvcjogXCIgKyBzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdGhpcy5fd3JhcHBlciA9IHdyYXBwZXI7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih0eXBlKTtcbiAgICBmbGlja2luZy5vbihFVkVOVFMuV0lMTF9DSEFOR0UsIHRoaXMuX29uSW5kZXhDaGFuZ2UpO1xuICAgIGZsaWNraW5nLm9uKEVWRU5UUy5XSUxMX1JFU1RPUkUsIHRoaXMuX29uSW5kZXhDaGFuZ2UpO1xuICAgIGZsaWNraW5nLm9uKEVWRU5UUy5QQU5FTF9DSEFOR0UsIHRoaXMudXBkYXRlKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcblxuICAgIGlmICghZmxpY2tpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmbGlja2luZy5vZmYoRVZFTlRTLldJTExfQ0hBTkdFLCB0aGlzLl9vbkluZGV4Q2hhbmdlKTtcbiAgICBmbGlja2luZy5vZmYoRVZFTlRTLldJTExfUkVTVE9SRSwgdGhpcy5fb25JbmRleENoYW5nZSk7XG4gICAgZmxpY2tpbmcub2ZmKEVWRU5UUy5QQU5FTF9DSEFOR0UsIHRoaXMudXBkYXRlKTtcblxuICAgIHRoaXMuX3JlbW92ZUFsbENoaWxkcygpO1xuXG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8uX2NyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGZsaWNraW5nOiB0aGlzLl9mbGlja2luZyxcbiAgICAgIHBhZ2luYXRpb246IHRoaXMsXG4gICAgICB3cmFwcGVyOiB0aGlzLl93cmFwcGVyXG4gICAgfTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBQQUdJTkFUSU9OLlRZUEUuQlVMTEVUOlxuICAgICAgICByZXR1cm4gbmV3IEJ1bGxldFJlbmRlcmVyKG9wdGlvbnMpO1xuXG4gICAgICBjYXNlIFBBR0lOQVRJT04uVFlQRS5GUkFDVElPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvblJlbmRlcmVyKG9wdGlvbnMpO1xuXG4gICAgICBjYXNlIFBBR0lOQVRJT04uVFlQRS5TQ1JPTEw6XG4gICAgICAgIHJldHVybiBuZXcgU2Nyb2xsQnVsbGV0UmVuZGVyZXIob3B0aW9ucyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltGbGlja2luZy1QYWdpbmF0aW9uXSB0eXBlIFxcXCJcIiArIHR5cGUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uX3JlbW92ZUFsbENoaWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXI7XG5cbiAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQYWdpbmF0aW9uO1xufSgpO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgRmxpY2tpbmdcbiAqL1xuXG5leHBvcnQgeyBBUlJPVywgQXJyb3csIEF1dG9QbGF5LCBGYWRlLCBQQUdJTkFUSU9OLCBQYWdpbmF0aW9uLCBQYXJhbGxheCwgUGVyc3BlY3RpdmUsIFNZTkMsIFN5bmMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@egjs/flicking-plugins/dist/plugins.esm.js\n')},"./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/@egjs/flicking-plugins/dist/pagination.css":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--6-oneOf-3-1!./node_modules/postcss-loader/src??ref--6-oneOf-3-2!./node_modules/@egjs/flicking-plugins/dist/pagination.css ***!
  \*****************************************************************************************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(/*! ../../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);\n// imports\n\n\n// module\nexports.push([module.i, ".flicking-pagination {\\n  position: absolute;\\n  left: 0;\\n  bottom: 10px;\\n  width: 100%;\\n  text-align: center;\\n  z-index: 2;\\n}\\n\\n.flicking-pagination-bullets,\\n.flicking-pagination-scroll {\\n  font-size: 0;\\n}\\n\\n.flicking-pagination-scroll {\\n  left: 50%;\\n  -webkit-transform: translate(-50%);\\n      -ms-transform: translate(-50%);\\n          transform: translate(-50%);\\n  white-space: nowrap;\\n  overflow: hidden;\\n}\\n\\n.flicking-pagination-scroll .flicking-pagination-slider {\\n  -webkit-transition: .2s transform;\\n  transition: .2s transform;\\n}\\n.flicking-pagination-scroll.flicking-pagination-uninitialized .flicking-pagination-slider,\\n.flicking-pagination-scroll.flicking-pagination-uninitialized .flicking-pagination-bullet {\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n\\n.flicking-pagination-bullet {\\n  display: inline-block;\\n  width: 8px;\\n  height: 8px;\\n  margin: 0 4px;\\n  border-radius: 50%;\\n  background-color: rgb(10 10 10 / 10%);\\n  cursor: pointer;\\n  font-size: 1rem;\\n}\\n\\n.flicking-pagination-scroll .flicking-pagination-bullet {\\n  vertical-align: middle;\\n  position: relative;\\n  -webkit-transition: .2s transform;\\n  transition: .2s transform;\\n}\\n\\n.flicking-pagination-bullet-active {\\n  background-color: #f2a65e;\\n}\\n\\n.flicking-pagination-scroll .flicking-pagination-bullet {\\n  vertical-align: middle;\\n  position: relative;\\n  -webkit-transition: .2s transform,.2s left;\\n  transition: .2s transform,.2s left;\\n  -webkit-transform: scale(0);\\n      -ms-transform: scale(0);\\n          transform: scale(0);\\n}\\n\\n.flicking-pagination-scroll .flicking-pagination-bullet-active {\\n  -webkit-transform: scale(1);\\n      -ms-transform: scale(1);\\n          transform: scale(1);\\n}\\n\\n.flicking-pagination-scroll .flicking-pagination-bullet-prev,\\n.flicking-pagination-scroll .flicking-pagination-bullet-next {\\n  -webkit-transform: scale(0.66);\\n      -ms-transform: scale(0.66);\\n          transform: scale(0.66);\\n}\\n\\n.flicking-pagination-scroll .flicking-pagination-bullet-prev2,\\n.flicking-pagination-scroll .flicking-pagination-bullet-next2 {\\n  -webkit-transform: scale(0.33);\\n      -ms-transform: scale(0.33);\\n          transform: scale(0.33);\\n}\\n", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9AZWdqcy9mbGlja2luZy1wbHVnaW5zL2Rpc3QvcGFnaW5hdGlvbi5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVnanMvZmxpY2tpbmctcGx1Z2lucy9kaXN0L3BhZ2luYXRpb24uY3NzPzFhNzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5mbGlja2luZy1wYWdpbmF0aW9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICBib3R0b206IDEwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHotaW5kZXg6IDI7XFxufVxcblxcbi5mbGlja2luZy1wYWdpbmF0aW9uLWJ1bGxldHMsXFxuLmZsaWNraW5nLXBhZ2luYXRpb24tc2Nyb2xsIHtcXG4gIGZvbnQtc2l6ZTogMDtcXG59XFxuXFxuLmZsaWNraW5nLXBhZ2luYXRpb24tc2Nyb2xsIHtcXG4gIGxlZnQ6IDUwJTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSk7XFxuICAgICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlKTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uZmxpY2tpbmctcGFnaW5hdGlvbi1zY3JvbGwgLmZsaWNraW5nLXBhZ2luYXRpb24tc2xpZGVyIHtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogLjJzIHRyYW5zZm9ybTtcXG4gIHRyYW5zaXRpb246IC4ycyB0cmFuc2Zvcm07XFxufVxcbi5mbGlja2luZy1wYWdpbmF0aW9uLXNjcm9sbC5mbGlja2luZy1wYWdpbmF0aW9uLXVuaW5pdGlhbGl6ZWQgLmZsaWNraW5nLXBhZ2luYXRpb24tc2xpZGVyLFxcbi5mbGlja2luZy1wYWdpbmF0aW9uLXNjcm9sbC5mbGlja2luZy1wYWdpbmF0aW9uLXVuaW5pdGlhbGl6ZWQgLmZsaWNraW5nLXBhZ2luYXRpb24tYnVsbGV0IHtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogbm9uZTtcXG4gIHRyYW5zaXRpb246IG5vbmU7XFxufVxcblxcbi5mbGlja2luZy1wYWdpbmF0aW9uLWJ1bGxldCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogOHB4O1xcbiAgaGVpZ2h0OiA4cHg7XFxuICBtYXJnaW46IDAgNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDEwIDEwIDEwIC8gMTAlKTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG59XFxuXFxuLmZsaWNraW5nLXBhZ2luYXRpb24tc2Nyb2xsIC5mbGlja2luZy1wYWdpbmF0aW9uLWJ1bGxldCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAuMnMgdHJhbnNmb3JtO1xcbiAgdHJhbnNpdGlvbjogLjJzIHRyYW5zZm9ybTtcXG59XFxuXFxuLmZsaWNraW5nLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjJhNjVlO1xcbn1cXG5cXG4uZmxpY2tpbmctcGFnaW5hdGlvbi1zY3JvbGwgLmZsaWNraW5nLXBhZ2luYXRpb24tYnVsbGV0IHtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IC4ycyB0cmFuc2Zvcm0sLjJzIGxlZnQ7XFxuICB0cmFuc2l0aW9uOiAuMnMgdHJhbnNmb3JtLC4ycyBsZWZ0O1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbn1cXG5cXG4uZmxpY2tpbmctcGFnaW5hdGlvbi1zY3JvbGwgLmZsaWNraW5nLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZSB7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgLW1zLXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxufVxcblxcbi5mbGlja2luZy1wYWdpbmF0aW9uLXNjcm9sbCAuZmxpY2tpbmctcGFnaW5hdGlvbi1idWxsZXQtcHJldixcXG4uZmxpY2tpbmctcGFnaW5hdGlvbi1zY3JvbGwgLmZsaWNraW5nLXBhZ2luYXRpb24tYnVsbGV0LW5leHQge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNjYpO1xcbiAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuNjYpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNjYpO1xcbn1cXG5cXG4uZmxpY2tpbmctcGFnaW5hdGlvbi1zY3JvbGwgLmZsaWNraW5nLXBhZ2luYXRpb24tYnVsbGV0LXByZXYyLFxcbi5mbGlja2luZy1wYWdpbmF0aW9uLXNjcm9sbCAuZmxpY2tpbmctcGFnaW5hdGlvbi1idWxsZXQtbmV4dDIge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuMzMpO1xcbiAgICAgIC1tcy10cmFuc2Zvcm06IHNjYWxlKDAuMzMpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMzMpO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/@egjs/flicking-plugins/dist/pagination.css\n')}}]);